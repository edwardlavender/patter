[{"path":[]},{"path":"https://edwardlavender.github.io/patter/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://edwardlavender.github.io/patter/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://edwardlavender.github.io/patter/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://edwardlavender.github.io/patter/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://edwardlavender.github.io/patter/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement edward.lavender@eawag.ch. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://edwardlavender.github.io/patter/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://edwardlavender.github.io/patter/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://edwardlavender.github.io/patter/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://edwardlavender.github.io/patter/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://edwardlavender.github.io/patter/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://edwardlavender.github.io/patter/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://edwardlavender.github.io/patter/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 Edward Lavender Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://edwardlavender.github.io/patter/articles/a-methodology.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Methodology","text":"patter implements particle algorithms animal movement modelling, focus passive acoustic telemetry systems. statistical methodology integrates observations movement process-based framework accounts available information reconstruct movement paths emergent patterns space use animal tracking data (detections receivers archival (depth) time series). vignette qualitatively outlines methodology, providing entry point literature (Lavender et al., prep) package (Lavender et al., prep). See subsequent vignettes learn implement methodology using patter (type vignette(package = \"patter\") list vignettes).","code":""},{"path":"https://edwardlavender.github.io/patter/articles/a-methodology.html","id":"evolution","dir":"Articles","previous_headings":"","what":"Evolution","title":"Methodology","text":"statistical methodology patter unifies (refines) suite methods known flapper algorithms (Lavender et al., 2023). original presentation, flapper algorithms presented two parts: acoustic-container (AC) branch particle-filtering (PF) branch. AC-branch algorithms define set possible locations individual given data time step. AC algorithm handles information acoustic observations DC algorithm handles information depth observations (often collected alongside acoustic data). PF-branch algorithms refine AC-branch outputs given movement model. predecessor flapper package, AC-branch algorithms implemented via ac(), dc() acdc() outputs refined PF via pf() pf_simplify(). patter, streamlined, enhanced formalised original methodology within framework particle filtering smoothing (Doucet & Johansen, 2008). (Particle sampling algorithms remain added package.) particle filter, simulate individual states (typically, locations) using movement model, contingent upon past present observations. sample termed ‘particle’. patter, achieved single function (pf_filter()) integrates functions AC- PF-branch algorithms. particle filter refined particle smoothing. original flapper implementation, smoothing/sampling-like process implemented pf_simplify() involved pruning ‘dead ends’ forward run particle filter. imagine forward-running particle filter growing fungal network two points space (representing start end time series), dead ends side branches (simulated) fungal network fail reach end. However, two, related limitations ‘prune’ methodology. first removal dead ends tends bias particle samples, early samples (invariably sooner--later end dead-end) likely get killed later samples. known particle degeneracy. second particles contingent upon past (partial marginal distribution), embody information future (.e., full marginal). patter, particle smoothing mitigates issues (see pf_smoother_two_filter()). Particle sampling algorithms reconstruct movement trajectories currently implemented. See NEWS summary differences flapper patter.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/articles/a-methodology.html","id":"algorithm","dir":"Articles","previous_headings":"Forward simulation","what":"Algorithm","title":"Methodology","text":"Consider regular sequence time steps, along collected observations (regular irregular intervals). particle filter, run along time series, sampling particle (states locations compatible data properties movement) go. works follows: Proposals. time step, propose series candidate locations individual located. example, given previous location, simulate step lengths headings/turning angles movement model use ‘kick’ individual new locations. Likelihood. Calculate likelihood data, given proposal. likelihoods acoustic archival data given proposal can resolved equations AC DC algorithms (modifications thereof). example, AC algorithm calculates likelihood acoustic observations (presence absence detections receiver) according model detection probability, given proposal locations. Weights. Translate likelihoods sampling weights encapsulate information data movement model. Sampling. Periodically, sample NN proposals, replacement, line weights. process effectively kills particles incompatible data increases frequency likely proposals. process continues end time series. outcome set particle samples (partial marginal distributions), one time step.","code":""},{"path":"https://edwardlavender.github.io/patter/articles/a-methodology.html","id":"implementation","dir":"Articles","previous_headings":"Forward simulation","what":"Implementation","title":"Methodology","text":"implementation particle filter patter four step process: (optional) pat_setup_data() used validate input datasets; assemble_*() functions used prepare datasets; State type; movement model (ModelMove); observation models (ModelObs);","code":""},{"path":"https://edwardlavender.github.io/patter/articles/a-methodology.html","id":"smoothing","dir":"Articles","previous_headings":"","what":"Smoothing","title":"Methodology","text":"Particle smoothing algorithms re-weight particles filter, incorporating information past future well. words, smoothing generates approximation full marginal distribution individual’s latent state time step. time writing, implemented two-filter smoother via via pf_smoother_two_filter().","code":""},{"path":"https://edwardlavender.github.io/patter/articles/a-methodology.html","id":"mapping","dir":"Articles","previous_headings":"","what":"Mapping","title":"Methodology","text":"Patterns space use (utilisation distributions) can reconstructed using standard statistical techniques (see map_pou(), map_dens() map_hr_*() built-functions).","code":""},{"path":"https://edwardlavender.github.io/patter/articles/a-methodology.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Methodology","text":"Doucet, . & Johansen, . M. (2008). tutorial particle filtering smoothing: Fifteen years later. https://www.stats.ox.ac.uk/~doucet/doucet_johansen_tutorialPF2011.pdf. Lavender. E. et al. (2023). integrative modelling framework passive acoustic telemetry. Methods Ecology Evolution. https://doi.org/10.1111/2041-210X.14193.","code":""},{"path":"https://edwardlavender.github.io/patter/articles/b-workflow-outline.html","id":"set-up","dir":"Articles","previous_headings":"","what":"Set up","title":"Workflow outline","text":"Load patter package via library(patter). Connect Julia via julia_connect(). Set seed R Julia via set_seed().","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/articles/b-workflow-outline.html","id":"prepare-study-area","dir":"Articles","previous_headings":"Preparation","what":"Prepare study area","title":"Workflow outline","text":"Define terra::SpatRaster map study area: applications, map bathymetry SpatRaster (see ?dat_gebco ?glossary); Mask inhospitable habitats (e.g., land) using NAs; Export map Julia via set_map();","code":""},{"path":"https://edwardlavender.github.io/patter/articles/b-workflow-outline.html","id":"prepare-movement-model","dir":"Articles","previous_headings":"Preparation","what":"Prepare movement model","title":"Workflow outline","text":"Define State type: State defines components animal’s movement want track; example, want track x y locations, use StateXY; Define corresponding movement model (ModelMove) instance: movement model defines animal’s movement capacity; See ?ModelMove built-options instructions custom sub-types;","code":""},{"path":"https://edwardlavender.github.io/patter/articles/b-workflow-outline.html","id":"prepare-observations","dir":"Articles","previous_headings":"Preparation","what":"Prepare observations","title":"Workflow outline","text":"Define observational datasets: patter able work kind observational dataset; See datasets-mefs example datasets included package; Validate datasets: Datasets used patter require manual preparation analysis; False detections (e.g. ?glatos::false_detections()); Detection timing; Receiver locations; passive acoustic telemetry /archival data, patter provides pat_setup_data() function validates data format data types use patter; Define observation models (ModelObs) sub-types: Observation models link individual movements observations; See ?ModelObs built-observation models instructions custom sub-types; Collate observations observation model parameters: Define timeline interest; Extract observations particular individual; Observations arranged [data.table::data.table]s long-format; passive acoustic telemetry archival datasets, use pat_setup_data() assemble_*() functions assemble datasets required; Otherwise, see assemble_*() function documentation straightforward dataset assembly instructions; simulate datasets instead, see sim_*() functions;","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/articles/b-workflow-outline.html","id":"forward-filter","dir":"Articles","previous_headings":"Particle algorithms","what":"Forward filter","title":"Workflow outline","text":"returns list, includes states [data.table::data.table] defines possible states (locations) individual time step (according movement model observations);","code":""},{"path":"https://edwardlavender.github.io/patter/articles/b-workflow-outline.html","id":"two-filter-smoother","dir":"Articles","previous_headings":"Particle algorithms","what":"Two-filter smoother","title":"Workflow outline","text":"Implement particle filter forwards backwards; Implement two-filter smoother via pf_smoother_two_filter(): refines outputs filter;","code":""},{"path":"https://edwardlavender.github.io/patter/articles/b-workflow-outline.html","id":"mapping","dir":"Articles","previous_headings":"","what":"Mapping","title":"Workflow outline","text":"Plot particle positions via pf_plot_*(); Map utilisation distributions: Map probability--use via map_pou(); Map smoothed probability density via map_dens(); Map home ranges via map_hr_*();","code":""},{"path":"https://edwardlavender.github.io/patter/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Edward Lavender. Author, maintainer.","code":""},{"path":"https://edwardlavender.github.io/patter/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lavender E, Scheidegger , Albert C, Biber S, Illian J, Thorburn J, Smout S, Moor H (2025). “Particle algorithms animal movement modelling receiver arrays.” Methods Ecology Evolution, 00, 1–12. doi:10.1111/2041-210X.70028. Lavender E, Scheidegger , Albert C, Biber S, Illian J, Thorburn J, Smout S, Moor H (2025). “patter: Particle algorithms animal tracking R Julia.” Methods Ecology Evolution, 00, 1–8. doi:10.1111/2041-210X.70029. Lavender E, Scheidegger , Albert C, Biber S, Brodersen J, Aleynik D, Cole G, Dodd J, Wright P, Illian J, James M, Smout S, Thorburn J, Moor H (2025). “Animal tracking particle algorithms conservation.” bioRxiv. doi:10.1101/2025.02.13.638042. Lavender E, Biber S, Illian J, James M, Wright P, Thorburn J, Smout S (2023). “integrative modelling framework passive acoustic telemetry.” Methods Ecology Evolution, 14, 2626–2638. doi:10.1111/2041-210X.14193.","code":"@Article{Lavender2025a,   author = {Edward Lavender and Andreas Scheidegger and Carlo Albert and Stanisław W. Biber and Janine Illian and James Thorburn and Sophie Smout and Helen Moor},   title = {Particle algorithms for animal movement modelling in receiver arrays.},   journal = {Methods in Ecology and Evolution},   year = {2025},   volume = {00},   pages = {1–12},   doi = {10.1111/2041-210X.70028}, } @Article{Lavender2025b,   author = {Edward Lavender and Andreas Scheidegger and Carlo Albert and Stanisław W. Biber and Janine Illian and James Thorburn and Sophie Smout and Helen Moor},   title = {patter: Particle algorithms for animal tracking in R and Julia.},   journal = {Methods in Ecology and Evolution},   year = {2025},   volume = {00},   pages = {1–8},   doi = {10.1111/2041-210X.70029}, } @Article{Lavender2025c,   author = {Edward Lavender and Andreas Scheidegger and Carlo Albert and Stanisław W. Biber and Jakob Brodersen and Dmitry Aleynik and Georgina Cole and Jane Dodd and Peter J. Wright and Janine Illian and Mark James and Sophie Smout and James Thorburn and Helen Moor},   title = {Animal tracking with particle algorithms for conservation.},   journal = {bioRxiv},   year = {2025},   doi = {10.1101/2025.02.13.638042}, } @Article{Lavender2023,   author = {Edward Lavender and Stanisław W. Biber and Janine Illian and Mark James and Peter J. Wright and James Thorburn and Sophie Smout},   title = {An integrative modelling framework for passive acoustic telemetry.},   journal = {Methods in Ecology and Evolution},   year = {2023},   volume = {14},   pages = {2626–2638},   doi = {10.1111/2041-210X.14193}, }"},{"path":"https://edwardlavender.github.io/patter/index.html","id":"patter-","dir":"","previous_headings":"","what":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"Particle algorithms animal movement modelling R patter provides particle filtering, smoothing sampling algorithms animal movement modelling, focus passive acoustic telemetry systems. wraps enhances fast Julia backend (Patter.jl). methodology enables reconstruction movement paths patterns space use. patter unifies suite methods formerly known flapper algorithms supersedes experimental flapper package (Lavender et al., 2023). Note: patter new R package. Like new packages, use degree caution. Please share feedback issues. NEWS Welcome patter v.2.0.0! includes breaking changes. projects based earlier versions, use renv. future projects, patter v.2.0.0 recommended.","code":""},{"path":"https://edwardlavender.github.io/patter/index.html","id":"highlights","dir":"","previous_headings":"","what":"Highlights","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"patter designed reconstruct movement paths emergent patterns space use animal tracking data. powerful, flexible, process-orientated, particle-based framework used purpose. framework unifies flapper algorithms provides important opportunities development, exploit . essential functions pf_filter() pf_smoother_two_filter(): pf_filter() particle filter. simulates possible locations individual moving forwards time, accounting data (example, acoustic observations, depth observations observations) time point animal’s movement (partial marginal distribution). pf_smoother_two_filter() particle smoothing algorithm. time step, smoother accounts data past future (full marginal distribution) substantially refines maps space use. hope add backward sampling algorithms package due course.","code":""},{"path":"https://edwardlavender.github.io/patter/index.html","id":"evolution","dir":"","previous_headings":"","what":"Evolution","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"patter evolved experimental flapper package, : powerful, substantially revised methodology; Faster, overhauled internal routines; Simpler use maintain; Stable, fewer dependencies upgraded spatial ecosystem; Better tested, comprehensive unit tests; See NEWS summary evolution flapper patter. time writing (May 2024), patter streamlined flapper focuses implementation fast particle-based algorithms reconstruction movements patterns space use. Please get touch like see additional functionality brought patter.","code":""},{"path":"https://edwardlavender.github.io/patter/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"Note: patter works Windows, MacOS Linux (restrictions). Windows, everything work follow instructions . MacOS, additional set (compiler configuration) may required, depending set . Debian/Ubuntu, patter can used simultaneously use geospatial routines R Julia. Thus, can call library(terra) terra::foo() use patter routines exploit terra geospatial packages R sessions connected Julia session (via julia_connect()). haven’t tried Linux distributions. Package examples written MacOS may run safely Linux without modification. Check function documentation supported options share experience. case issues, able use Patter.jl directly, systems may simpler getting R Julia play together! Install R. package requires R version ≥ 4.1 (recent version recommended). can check version R console using R.version.string. Install build packages. Package installation configuration (may) require devtools, pkgbuild rmarkdown packages. Install : Linux, step may require system libraries (see ). Install system libraries. Windows, package building requires RTools. can check whether RTools installed pkgbuild::has_rtools(). RTools installed, necessary download install appropriate version RTools proceeding following instructions . MacOS, system-specific step (e.g., compiler configuration) may required. Follow steps address issues required system. Linux, suite system libraries, including GDAL, GEOS PROJ, required. See package DESCRIPTION required/suggested packages follow instructions system. Debian/Ubuntu, see r2u follow instructions get running. Click system dependency installation instructions Ubuntu. sudo apt update  # `make` utility required compile packages e.g., data.table sudo apt install build-essential  # Geospatial dependencies {terra} sudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable sudo apt install libgdal-dev libgeos-dev libproj-dev  # `ffpmeg` `libavfilter-dev` {av} (suggested) sudo apt install ffmpeg sudo apt install libavfilter-dev  # `GSL` {RcppGSL} {Rfast} (suggested) sudo apt install libgsl-dev  # `gfortran` {classInt} -> {sf} (suggested) sudo apt install gfortran  # `units` {units} -> {sf} (suggested) sudo apt install libudunits2-dev Install Julia. Julia high-performance programming language patter uses backend. Julia installed system, follow instructions install Julia. . Windows, easiest option download install Julia JuliaLang. installation, check Add Julia PATH. B. Another option use juliaup. users found easier MacOS don’t worry finding right Julia installation architecture. Install juliaup installer, following instructions . example, MacOS, open shell (Terminal) type: shell, install Julia (release version) via juliaup: Note: Install recent Julia version. README last built 2025-04-18 Julia 1.11.5. Setup JuliaCall. next step set JuliaCall, provides integration R Julia. julia_setup() fails 'Julia found', tell R location Julia binary via JULIA_HOME (see ?JuliaCall::julia_setup() JuliaCall README, well relevant patter GitHub issues troubleshooting ways get help). Install patter. install patter main branch, use: dependencies = TRUE argument ensures suggested packages also installed, required functions build vignettes. process may take several minutes. Set build_vignettes = FALSE faster installation. install patter development (dev) branch, available, use: branch may include bug fixes new features used caution. recommend using renv (similar) RStudio Projects track version patter use projects. ensure code continues work, even make breaking changes patter package evolves response user feedback. Connect Julia. start every R session, need connect R Julia (patter Patter.jl): first time run julia_connect(), connect Julia install (pre-compile) Patter.jl additional Julia dependencies. usually takes five minutes first run may take twenty minutes depending speed machine. Subsequent julia_connect() calls faster. Validate R—Julia connection. validate patter works system, run: return NULL, invisibly, case good go. Otherwise, function return error (R may crash). (optional) Run package checks. run package checks locally, follow instructions dev/001-check.R. See test-environments.md list systems currently run comprehensive testing latest results. run tests MacOS, Windows Linux systems selection recent R Julia versions. run tests using --date R Julia packages. Issue reports appreciated.","code":"install.packages(c(\"devtools\", \"pkgbuild\", \"rmarkdown\")) sudo apt update  # `make` utility required to compile packages e.g., data.table sudo apt install build-essential  # Geospatial dependencies for {terra} sudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable sudo apt install libgdal-dev libgeos-dev libproj-dev  # `ffpmeg` and `libavfilter-dev` for {av} (suggested) sudo apt install ffmpeg sudo apt install libavfilter-dev  # `GSL` for {RcppGSL} for {Rfast} (suggested) sudo apt install libgsl-dev  # `gfortran` for {classInt} -> {sf} (suggested) sudo apt install gfortran  # `units` for {units} -> {sf} (suggested) sudo apt install libudunits2-dev curl -fsSL https://install.julialang.org | sh juliaup update juliaup default release # Install the {JuliaCall} package: install.packages(\"JuliaCall\")  # Use the development version if the CRAN version is unavailable: devtools::install_github(\"JuliaInterop/JuliaCall\",                          dependencies = TRUE) # Run julia_setup() to set up the Julia installation  # * This includes an installJulia argument if the above Julia installation options fail  # * Set `JULIA_HOME` if Julia is not found (see `?julia_setup()`) # * Note this may take several minutes # * Set `rebuild = TRUE` if you've previously used JuliaCall on an older R version library(JuliaCall) julia <- julia_setup() # Validate the Julia installation: # * TRUE: `Julia` is working!  # * FALSE: `Julia` is not working (see below)!  isTRUE(try(julia_eval('true'), silent = TRUE)) devtools::install_github(\"edwardlavender/patter\",                           dependencies = TRUE,                           build_vignettes = rmarkdown::pandoc_available()) devtools::install_github(\"edwardlavender/patter@dev\",                           dependencies = TRUE,                           build_vignettes = rmarkdown::pandoc_available()) # Load & attach {patter}: library(patter)  # Option (A): Connect to `Julia`:  # * Set `JULIA_HOME` if 'Julia not found' # * Set `JULIA_PROJ` to use a local Julia project (recommended) # * Set `JULIA_NUM_THREADS` to exploit multi-threading (recommended) # * Set `.pkg_update = TRUE` if you've just installed a newer version of `patter` # * Set `JULIA_PATTER_SOURCE` = \"dev\" as well if you've installed from the `dev` branch # * See `julia_connect()` for further guidance julia <- julia_connect() julia_validate()"},{"path":[]},{"path":"https://edwardlavender.github.io/patter/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"introduction patter, use: vignette(\"-methodology\", package = \"patter\") conceptual introduction methodology; vignette(\"b-workflow-outline\", package = \"patter\") overview workflow; full list functions, see help(package = 'patter'). glossary key arguments, see glossary.","code":""},{"path":"https://edwardlavender.github.io/patter/index.html","id":"datasets","dir":"","previous_headings":"","what":"Datasets","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"example datasets Movement Ecology Flapper Skate project (datasets-mefs), inspired patter, see: dat_moorings acoustic receiver deployments; dat_detections acoustic detection time series; dat_archival archival (depth) time series; dat_gebco() bathymetry grid; dat_coast() coastline vector; dat_mpa() Marine Protected Area boundary validate new datasets use patter, see pat_setup_data() /assemble_*() function documentation. example algorithm outputs (datasets-algorithms), see: dat_path() example output sim_path_walk(); dat_coa() example output coa(); dat_pff() dat_pfb() example output pf_filter(); dat_tff() example output pf_smoother_two_filter();","code":""},{"path":"https://edwardlavender.github.io/patter/index.html","id":"set-up-julia","dir":"","previous_headings":"","what":"Set up Julia","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"link patter Patter.jl Julia backend, use: julia_connect() connect R Julia; julia_validate() validate R—Julia connection; set_seed() set seed R Julia; set_map() make SpatRaster study area available Julia; functions run start every R session.","code":""},{"path":"https://edwardlavender.github.io/patter/index.html","id":"abstract-types","dir":"","previous_headings":"","what":"Abstract Types","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"patter based three Abstract Types, defined Julia: State structures hold state (location) animal given time step; ModelMove structures hold movement model, used simulate new states; ModelObs structures hold observation model parameters, used evaluate correspondence simulated states observations;","code":""},{"path":"https://edwardlavender.github.io/patter/index.html","id":"simulation","dir":"","previous_headings":"","what":"Simulation","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"simulate animal movement time series, see: sim_path_walk() simulate movement path walk model (via ModelMove); sim_array() simulate acoustic array; sim_observations() simulate observational time series (via ModelObs); evaluate model skill reconstructing simulated patterns, see skill_*() functions: skill_mb() calculate mean bias; skill_me() calculate mean error; skill_rmse() calculate root mean squared error; skill_R() calculate Spearman’s rank correlation coefficient; skill_d() calculate index agreement;","code":""},{"path":"https://edwardlavender.github.io/patter/index.html","id":"data-exploration","dir":"","previous_headings":"","what":"Data exploration","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"help data acquisition, processing, checking preliminary analyses, see flapper package. facilitates: Data preparation; Spatial operations; Distance calculations; Movement analyses; Please submit feature request like functions flapper patter.","code":""},{"path":"https://edwardlavender.github.io/patter/index.html","id":"algorithms","dir":"","previous_headings":"","what":"Algorithms","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"main thrust patter provision fast, integrated modelling workflow based particle filtering reconstructing animal movement paths emergent patterns space use observational time series (focus passive acoustic telemetry systems). assemble datasets particle filtering, use assemble_*() functions: assemble_timeline() assembles timeline; assemble_acoustics() assembles acoustic time series; assemble_acoustics_containers() assembles corresponding time series acoustic containers; assemble_archival() assembles archival time series; assemble_custom() assembles custom time series; Ancillary time series structured way inclusion particle filter. implement particle filtering (PF) routines, use: pf_filter() implement particle filter; pf_smoother_two_filter() implement two-filter smoother; functions return pf_particles-class objects. convenience plotting functions, see: plot_xyt() plot particle locations; mapping utilisation distributions, use: map_pou() map probability--use; .im.SpatRaster(), convert SpatRasters pixel images; .owin.SpatRaster(), convert SpatRasters observation windows; .owin.sf(), convert sf objects observation windows; map_hr_prop() custom range; map_hr_core() ‘core’ range; map_hr_home() ‘home’ range; map_hr_full() full range;","code":""},{"path":"https://edwardlavender.github.io/patter/index.html","id":"options","dir":"","previous_headings":"","what":"Options","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"additional options patter, see: patter-progress monitor function progress;","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/index.html","id":"set-up","dir":"","previous_headings":"","what":"Set up","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"basic patter workflow reconstruct movement paths patterns space use animal tracking data. First, load essential packages: Second, connect R Julia set seed R Julia ensure reproducibility simulations: Third, define properties study area; namely, SpatRaster study area defines area within movements possible timeline model movements:","code":"library(patter) #> This is {patter} v.2.0.0. For an overview, see `?patter`. For support, raise an issue at https://github.com/edwardlavender/patter/issues. library(data.table) library(dtplyr) library(dplyr, warn.conflicts = FALSE) options(patter.verbose = FALSE) julia_connect() julia_validate() set_seed(123L) # Define map  # * Use file path on Linux  map <- dat_gebco() set_map(map)  # Define timeline  timeline <- seq(as.POSIXct(\"2016-03-17 01:50:00\", tz = \"UTC\"),                 as.POSIXct(\"2016-03-18 01:48:00\", tz = \"UTC\"),                  by = \"2 mins\")"},{"path":"https://edwardlavender.github.io/patter/index.html","id":"movement","dir":"","previous_headings":"","what":"Movement","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"reconstruct movements tagged flapper skate (Dipturus intermedius) within study area west coast Scotland, based electronic tagging tracking data. , need model individual’s movements series observation models connect movements observations. example, interested two-dimensional (x, y) location animal time (, animal’s ‘state’ object type StateXY). animal can move 750 m two minutes, resolution model movement, formulate random walk model accordingly based step lengths headings:","code":"# Define the animal's state: state      <- \"StateXY\"  # Formulate a corresponding movement model: mobility   <- 750.0 model_move <- model_move_xy(.mobility    = \"750.0\",                              .dbn_length  = \"truncated(Gamma(1, 250.0), upper = 750.0)\",                             .dbn_heading = \"Uniform(-pi, pi)\")  # Visualise realisations of the movement model (Windows/MacOS): # (Paths are coloured by time step from purple (start) to yellow (end)) map |>    sim_path_walk(.timeline   = timeline,                 .state      = state,                 .model_move = model_move,                  .n_path     = 4L,                  .one_page   = TRUE) |>    invisible()"},{"path":"https://edwardlavender.github.io/patter/index.html","id":"observations","dir":"","previous_headings":"","what":"Observations","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"collected acoustic archival (depth) observations tagged flapper skate. Let’s pull time series selected individual: Individual movements connected observations models observation process dataset. Without going details, bundle together observations parameters observation models: course, need acoustic archival data implement algorithms (just data collected flapper skate)—datasets can used just easily. simulate observations instead, see sim_observations().","code":"# Define acoustic detections det <-   dat_detections |>   filter(individual_id == 25L) |>   mutate(individual_id = NULL) |>   as.data.table()  # Define archival (depth) observations arc <-   dat_archival |>   filter(individual_id == 25L) |>   mutate(individual_id  = NULL,          depth_sigma    = 50,          depth_deep_eps = 50) |>   rename(obs = depth) |>   as.data.table() # ModelObsAcousticLogisTrunc acoustics <- assemble_acoustics(.timeline   = timeline,                                 .detections = det,                                 .moorings   = dat_moorings)  # ModelObsContainer containers <- assemble_acoustics_containers(.timeline  = timeline,                                              .acoustics = acoustics,                                              .mobility  = mobility)  # ModelObsDepthNormalTruncSeabed archival <- assemble_archival(.timeline = timeline,                               .archival = arc)  # Named lists of ModelObs sub-types and associated observations # * The container dataset is direction specific so we assemble two yobs lists yobs_fwd <- list(ModelObsAcousticLogisTrunc     = acoustics,                   ModelObsContainer              = containers$forward,                  ModelObsDepthNormalTruncSeabed = archival) yobs_bwd <- list(ModelObsAcousticLogisTrunc     = acoustics,                   ModelObsContainer              = containers$backward,                  ModelObsDepthNormalTruncSeabed = archival)"},{"path":"https://edwardlavender.github.io/patter/index.html","id":"particle-filter","dir":"","previous_headings":"","what":"Particle filter","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"now position run particle filter. runs simulation forwards (backwards) time, sampling states (locations, termed ‘particles’) consistent movement model observations including time point. end time series (data.table::data.table) particles approximate partial marginal distribution location animal, time step:","code":"# List filter arguments args <- list(.timeline   = timeline,              .state      = state,              .yobs       = yobs_fwd,              .model_move = model_move,              .n_record   = 1000L,              .n_particle = 1e4L)  # Forward run fwd <- do.call(pf_filter, args, quote = TRUE)  # Forward run outputs head(fwd$states) #>    path_id timestep           timestamp map_value        x       y #>      <int>    <int>              <POSc>     <num>    <num>   <num> #> 1:       1        1 2016-03-17 01:50:00  42.39980 709442.1 6252807 #> 2:       1        2 2016-03-17 01:52:00  49.42750 709292.4 6253022 #> 3:       1        3 2016-03-17 01:54:00  83.21526 709073.7 6253192 #> 4:       1        4 2016-03-17 01:56:00  37.55011 709685.4 6252670 #> 5:       1        5 2016-03-17 01:58:00  45.86026 709430.2 6252964 #> 6:       1        6 2016-03-17 02:00:00  46.53543 709252.1 6252852 head(fwd$diagnostics) #>    timestep           timestamp      ess     maxlp #>       <int>              <POSc>    <num>     <num> #> 1:        1 2016-03-17 01:50:00 4290.876 -4.934213 #> 2:        2 2016-03-17 01:52:00 6391.392 -4.915979 #> 3:        3 2016-03-17 01:54:00 7131.287 -4.913703 #> 4:        4 2016-03-17 01:56:00 4862.654 -4.546714 #> 5:        5 2016-03-17 01:58:00 4926.398 -4.917193 #> 6:        6 2016-03-17 02:00:00 6690.797 -4.896022 fwd$callstats #>              timestamp         routine n_particle n_iter    loglik convergence #>                 <POSc>          <char>      <int>  <int>     <num>      <lgcl> #> 1: 2025-04-18 16:11:53 filter: forward      10000      1 -3556.524        TRUE #>        time #>       <num> #> 1: 7.415571  # Backward run args$.yobs      <- yobs_bwd args$.direction <- \"backward\" bwd <- do.call(pf_filter, args, quote = TRUE)  # Backward run outputs head(bwd$states) #>    path_id timestep           timestamp map_value        x       y #>      <int>    <int>              <POSc>     <num>    <num>   <num> #> 1:       1        1 2016-03-17 01:50:00  42.39980 709458.5 6252790 #> 2:       1        2 2016-03-17 01:52:00  43.58479 709525.9 6253099 #> 3:       1        3 2016-03-17 01:54:00  45.88295 709363.9 6252886 #> 4:       1        4 2016-03-17 01:56:00  51.52599 709173.0 6251836 #> 5:       1        5 2016-03-17 01:58:00  42.54443 709499.0 6252997 #> 6:       1        6 2016-03-17 02:00:00  45.88295 709321.2 6252872 head(bwd$diagnostics) #>    timestep           timestamp      ess     maxlp #>       <int>              <POSc>    <num>     <num> #> 1:        1 2016-03-17 01:50:00 7085.354 -4.915860 #> 2:        2 2016-03-17 01:52:00 6648.213 -4.913576 #> 3:        3 2016-03-17 01:54:00 4777.271 -4.915514 #> 4:        4 2016-03-17 01:56:00 5172.635 -4.546961 #> 5:        5 2016-03-17 01:58:00 6692.765 -4.914546 #> 6:        6 2016-03-17 02:00:00 4977.524 -4.899462 bwd$callstats #>              timestamp          routine n_particle n_iter    loglik convergence #>                 <POSc>           <char>      <int>  <int>     <num>      <lgcl> #> 1: 2025-04-18 16:12:00 filter: backward      10000      1 -3558.672        TRUE #>        time #>       <num> #> 1: 1.042987"},{"path":"https://edwardlavender.github.io/patter/index.html","id":"particle-smoother","dir":"","previous_headings":"","what":"Particle smoother","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"Particle smoothers refine outputs particle filter. Smoothed particles approximate full marginal distribution location individual time step (accounting data step).","code":"# Set `vmap` for probability calculations # * Use file path rather on Linux  set_vmap(.map = map, .mobility = mobility)  # Run smoother  smo <- pf_smoother_two_filter(.n_particle = 750L, .n_sim = 100L)  # Smoother outputs head(smo$states) #>    path_id timestep           timestamp map_value        x       y #>      <int>    <int>              <POSc>     <num>    <num>   <num> #> 1:       1        1 2016-03-17 01:50:00  42.39980 709458.5 6252790 #> 2:       1        2 2016-03-17 01:52:00  52.98276 709339.1 6253123 #> 3:       1        3 2016-03-17 01:54:00  44.46762 709360.3 6252834 #> 4:       1        4 2016-03-17 01:56:00  73.27666 709147.1 6253184 #> 5:       1        5 2016-03-17 01:58:00  42.39980 709398.4 6252821 #> 6:       1        6 2016-03-17 02:00:00  84.47292 709282.8 6253530 head(smo$diagnostics) #>    timestep           timestamp      ess maxlp #>       <int>              <POSc>    <num> <num> #> 1:        1 2016-03-17 01:50:00 750.0000   NaN #> 2:        2 2016-03-17 01:52:00 668.7949   NaN #> 3:        3 2016-03-17 01:54:00 596.4778   NaN #> 4:        4 2016-03-17 01:56:00 387.9994   NaN #> 5:        5 2016-03-17 01:58:00 664.7221   NaN #> 6:        6 2016-03-17 02:00:00 645.6459   NaN smo$callstats #>              timestamp              routine n_particle n_iter loglik #>                 <POSc>               <char>      <int>  <int>  <num> #> 1: 2025-04-18 16:12:02 smoother: two-filter        750     NA    NaN #>    convergence     time #>         <lgcl>    <num> #> 1:        TRUE 3.355024"},{"path":"https://edwardlavender.github.io/patter/index.html","id":"mapping","dir":"","previous_headings":"","what":"Mapping","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"Particles can used reconstruct movement paths patterns space use. can estimate utilisation distribution particle samples follows:  basic workflow highly customisable. flexibility define species-specific movement models, include type observational dataset implement system-specific observation models. See vignettes function examples details reach queries.","code":"# Estimate UD # * This must be done in a separate R session on Linux  ud <- map_dens(.map   = map,                .coord = smo$states,                .sigma = bw.h)$ud #> Observation window is gridded.  # Add home range map_hr_home(ud, .add = TRUE) mtext(side = 4, \"Probability density\", line = -3)"},{"path":"https://edwardlavender.github.io/patter/index.html","id":"resources","dir":"","previous_headings":"","what":"Resources","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"full details methods, see references . information patter package, see: ?patter::patter overview package functions; ?patter::pf_filterfor information specific functions (pf_filter()); patter-workshops introductory materials; code examples, see: patter-demo simple demonstrations; patter-eval simulation-based workflow analysis; patter-flapper real-world analysis flapper skate; patter-trout real-world analysis lake trout; Note code base repositories may outdated.","code":""},{"path":"https://edwardlavender.github.io/patter/index.html","id":"disclaimer-and-troubleshooting","dir":"","previous_headings":"","what":"Disclaimer and troubleshooting","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"patter new R package. routines experimental. Researchers interested using package encouraged get touch methods package remain early stage evolution (edward.lavender@eawag.ch).","code":""},{"path":"https://edwardlavender.github.io/patter/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Particle Filters, Smoothers and Samplers for Animal Movement Modelling","text":"cite patter publications, please use: Lavender, E., Scheidegger, ., Albert, C., Biber, S. W., Illian, J., Thorburn, J., Smout, S., & Moor, H. (2025). Particle algorithms animal movement modelling receiver arrays. Methods Ecology Evolution, 00, 1–12. https://doi.org/10.1111/2041-210X.70028 Lavender, E., Scheidegger, ., Albert, C., Biber, S. W., Illian, J., Thorburn, J., Smout, S., & Moor, H. (2025). patter: Particle algorithms animal tracking R Julia. Methods Ecology Evolution, 00, 1–8. https://doi.org/10.1111/2041-210X.70029 Lavender, E., Scheidegger, ., Albert, C., Biber, S. W., Brodersen, J., Aleynik, D., Cole, G., Dodd, J., Wright, P. J., Illian, J., James, M., Smout, S., Thorburn, J., & Moor, H. (2025). Animal tracking particle algorithms conservation. bioRxiv. https://doi.org/10.1101/2025.02.13.638042 BibTex: patter evolved flapper R package. Please also consider citing publication: Lavender, E., Biber, S., Illian, J., James, M., Wright, P., Thorburn, J., & Smout, S. (2023). integrative modelling framework passive acoustic telemetry. Methods Ecology Evolution, 14, 2626–2638. https://doi.org/10.1111/2041-210X.14193 Thank citing package. citations help justify continued investments development. Please note patter released Contributor Code Conduct. contributing project, agree abide terms.","code":"@Article{Lavender2025a,   author  = {Lavender, Edward and Scheidegger, Andreas and Albert, Carlo and Biber, Stanisław W. and Illian, Janine and Thorburn, James and Smout, Sophie and Moor, Helen},   title   = {Particle algorithms for animal movement modelling in receiver arrays},   journal = {Methods in Ecology and Evolution},   year    = {2025},   volume  = {00},   pages   = {1--12},   doi     = {10.1111/2041-210X.70028} } @Article{Lavender2025b,   author  = {Lavender, Edward and Scheidegger, Andreas and Albert, Carlo and Biber, Stanisław W. and Illian, Janine and Thorburn, James and Smout, Sophie and Moor, Helen},   title   = {patter: Particle algorithms for animal tracking in R and Julia},   journal = {Methods in Ecology and Evolution},   year    = {2025},   volume  = {00},   pages   = {1--8},   doi     = {10.1111/2041-210X.70029} } @Article{Lavender2025c,   author  = {Lavender, Edward and Scheidegger, Andreas and Albert, Carlo and Biber, Stanisław W. and Brodersen, Jakob and Aleynik, Dmitry and Cole, Georgina and Dodd, Jane and Wright, Peter J. and Illian, Janine and James, Mark and Smout, Sophie and Thorburn, James and Moor, Helen},   title   = {Animal tracking with particle algorithms for conservation},   journal = {bioRxiv},   year    = {2025},   doi     = {10.1101/2025.02.13.638042} } @Article{Lavender2023,   author  = {Lavender, Edward and Biber, Stanisław W. and Illian, Janine and James, Mark and Wright, Peter J. and Thorburn, James and Smout, Sophie},   title   = {An integrative modelling framework for passive acoustic telemetry},   journal = {Methods in Ecology and Evolution},   year    = {2023},   volume  = {14},   pages   = {2626--2638},   doi     = {10.1111/2041-210X.14193}   } }"},{"path":"https://edwardlavender.github.io/patter/reference/ModelMove.html","id":null,"dir":"Reference","previous_headings":"","what":"Movement models — ModelMove","title":"Movement models — ModelMove","text":"ModelMove Abstract Type Patter.jl groups movement model sub-types, instances can created via R model_move_*() function.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/ModelMove.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Movement models — ModelMove","text":"","code":"model_move_xy(   .mobility = \"750.0\",   .dbn_length = \"truncated(Gamma(1, 250.0), upper = 750.0)\",   .dbn_heading = \"Uniform(-pi, pi)\" )  model_move_xyz(   .mobility = \"750.0\",   .dbn_length = \"truncated(Gamma(1, 250.0), upper = 750.0)\",   .dbn_heading = \"Uniform(-pi, pi)\",   .dbn_z = \"truncated(Normal(100.0, 250.0), lower = 0.0, upper = 350.0)\" )  model_move_cxy(   .mobility = \"750.0\",   .dbn_length = \"truncated(Gamma(1.0, 750.0), upper = 750.0)\",   .dbn_heading_delta = \"Normal(0, 0.5)\" )  model_move_cxyz(   .mobility = \"750.0\",   .dbn_length = \"truncated(Gamma(1.0, 750.0), upper = 750.0)\",   .dbn_heading_delta = \"Normal(0, 0.5)\",   .dbn_z_delta = \"Normal(0, 3.5)\" )"},{"path":"https://edwardlavender.github.io/patter/reference/ModelMove.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Movement models — ModelMove","text":".mobility, .dbn_length, .dbn_heading, .dbn_heading_delta, .dbn_z, .dbn_z_delta Character strings define movement model components: .mobility—maximum movement distance two time steps (m); .dbn_length—distribution step lengths (m); .dbn_heading—distribution headings (rad); .dbn_heading_delta—distribution changes heading, .e., turning angle (rad); .dbn_z—distribution depths; .dbn_z_delta—distribution changes depth;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/ModelMove.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Movement models — ModelMove","text":"model_move_*() functions return character string defines ModelMove instance evaluation Julia. class output character plus ModelMove ModelMoveXY, ModelMoveXYZ, ModelMoveCXY ModelMoveCXYZ (see plot.ModelMove). map (env) exist Julia, error thrown.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/ModelMove.html","id":"model-structures","dir":"Reference","previous_headings":"","what":"Model structures","title":"Movement models — ModelMove","text":"Movement model sub-types Julia structures hold components movement models. R-user perspective, can think ModelMove sub-type S4-class-like object, slots components movement model. movement model instance, can simulate movements evaluate density movements one state (location) another. following movement models built Patter.jl: Random walks (RWs): ModelMoveXY ModelMoveXYZ Correlated random walks (CRWs): ModelMoveCXY ModelMoveCXYZ See Patter.jl JuliaCall::julia_help(\"ModelMove\") fields built-sub-types. Briefly, sub-types include: map field, defines region(s) within movements permitted. R, convenient represent map terra::SpatRaster, NAs define inhospitable habitats (e.g., land). made available Julia ModelMove constructors env via set_map(); mobility parameter; Additional model-specific components (fields distribution step lengths headings case two-dimensional random walks); patter, movement models required: simulate movement paths, via sim_path_walk(); run particle filter, via pf_filter(); run particle smoother, via pf_smoother_two_filter(); R functions, movement-model instance specified via .model_move argument. argument expects character string defining ModelMove instance can evaluated Julia (, ModelMove constructor). model_move_*() functions convenience functions specification constructors built-sub-types. ModelMove instances contain map field defines region(s) within movements permitted. use model_move_*() function, map available Julia env (see set_map()). additional components movement model specified via model_move_*() function arguments character strings Julia code. Currently implemented model_move_*() functions : model_move_xy(), specifies RW X Y sub-type ModelMoveXY terms distributions step lengths headings; model_move_xyz(), specifies RW X, Y Z sub-type ModelMoveXY terms distributions step lengths, headings depths; model_move_cxy(), specifies CRW X Y sub-type ModelMoveXY terms distributions step lengths turning angles; model_move_cxyz(), specifies CRW X, Y Z sub-type ModelMoveCXYZ terms distributions step lengths, turning angles changes depth; See translations distributions R (e.g., *norm()) Julia (e.g., Normal()). plot dimensions movement model, see plot.ModelMove. visualise realisations model, see sim_path_walk(). Julia, ModelMove instances used simulate states via Patter.simulate_step(). particle smoother, density movement one state another evaluated Patter.logpdf_step(). generic functions. Different methods dispatched according input model. built-ModelMove sub-types, corresponding methods routines also built-. custom ModelMove sub-types, methods need provided. use custom ModelMove sub-types, see ?State.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/ModelMove.html","id":"model-development","dir":"Reference","previous_headings":"","what":"Model development","title":"Movement models — ModelMove","text":"inference, encourage users start simple movement models (random walks correlated random walks) add complexity iteratively, required. Movement models formulated, parameterised, using available datasets, domain knowledge literature. example: Lavender et al. (2025). study flapper skate (Dipturus intermedius) movements, formulated behavioural-switching correlated random walk movement model. gauged potential swimming speeds analyses movement rates receivers vertical activity (via get_mvt_mobility() flapper). Actual movement speeds can affected current speeds evaluated using ocean model (via fvcom.tbx). also reviewed information literature related species (accelerometery, satellite tracking, flow tank experiments trawl footage). studies helped bound expectations movement rates flapper skate, absence direct measurements. Given epistemic uncertainty, also conducted analyses 'restrictive' 'flexible' movement models analyse algorithm sensitivity. Lavender et al. (prep). study lake trout (Salvelinus namaycush), leveraging swim-speed information fine-scale positioning studies, accelerometer measurements swim-tunnel experiments (plus datasets underwater video) parameterise models. species, can visualise distributions speed turning angle measurements (histograms) develop data-driven models (e.g., using fitdistrplus::fitdist()). particle filter, movement models must defined resolution .timeline (see pf_filter()). example, .timeline two-minute time steps simple random walk, distribution step lengths (m) headings (rad) defined two-minute time step (see model_move_xy()). movements truncated .mobility parameter. maximum possible movement distance time two time steps. Set .mobility based considerations . necessary, also account discretisation errors timing observations (e.g., see assemble_acoustics()). Since .mobility affects tail distribution, exact value .mobility can relatively unimportant, providing large enough. recommend erring side flexibility cases uncertainty. Note model formulation parameterisation can iterative process: Develop initial model observation models, drawing available datasets, domain knowledge literature; Perform inference, using pf_filter(); Evaluate convergence; cases convergence failures, re-evaluate model(s) try ; necessary, run algorithms restrictive flexible models analyse sensitivity; advice study system, please raise issue GitHub.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/ModelMove.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Movement models — ModelMove","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/ModelMove.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Movement models — ModelMove","text":"","code":"if (patter_run(.julia = TRUE, .geospatial = TRUE)) {    library(data.table)   library(JuliaCall)    #### Connect to Julia   julia_connect()   set_seed()    #### Define the `map`   # `map` is the region within which movements are permitted   # In `R`, we represent this as a `SpatRaster`   # Here, we have a bathymetry `SpatRaster` for the west coast of Scotland:   # * NaNs define regions into which movement is not permitted   # * (i.e., on land, in the case of aquatic animals)   map <- dat_gebco()    # Using `set_map()` makes the map available as a object called 'env' in `Julia`   # > This is required as a component of all movement models   set_map(map)    #### Example (1a): Use `model_move_xy()` with default options   # `model_move_*()` functions simply return a character string of Julia code   # (Downstream functions can evaluate this code, as shown below)   model_move_xy()    #### Example (1b): Customise `model_move_xy()`   # Use a truncated normal distribution for step lengths:   model_move_xy(.mobility = \"750.0\",                 .dbn_length = \"truncated(Normal(250, 50), lower = 0.0, upper = 750.0)\")   # Use an exponential distribution for step lengths   model_move_xy(.mobility = \"750.0\",                 .dbn_length = \"truncated(Exponential(0.01), upper = 750.0)\")   # Use a biased random walk   model_move_xy(.dbn_heading = \"VonMises(0, 1)\")   # Get help on a distribution in Julia:   julia_help(\"Exponential\")    #### Example (2): Use `model_move_xyz()`   # Use default options   model_move_xyz()   # Customise model components   model_move_xyz(.mobility = \"750.0\",                  .dbn_length = \"truncated(Exponential(0.01), upper = 750.0)\",                  .dbn_z = \"truncated(Gamma(1.0, 250.0), lower = 0.0, upper = 350.0)\")    #### Example (3): Use `model_move_cxy()`   # Use default options   model_move_cxy()   # Customise model components   model_move_cxy(.mobility = \"750.0\",                  .dbn_length = \"truncated(Normal(250, 50), lower = 0.0, upper = 750.0)\",                  .dbn_heading_delta = \"Normal(0, 0.25)\")    #### Example (4): Use `model_move_cxyz()`   # Use default options   model_move_cxyz()   # Customise model components   model_move_cxyz(.mobility = \"750.0\",                   .dbn_length = \"truncated(Normal(250, 50), lower = 0.0, upper = 750.0)\",                   .dbn_heading_delta = \"Normal(0, 0.25)\",                   .dbn_z_delta = \"Normal(0, 2.5)\")    #### Example (4): Visualise movement model component distributions   # See `?plot.ModelMove`   plot(model_move_xy())    #### Example (5): Visualise movement model realisations (trajectories)   # See `?sim_path_walk`   # Define a timeline for the simulation   timeline <- seq(as.POSIXct(\"2016-01-01\", tz = \"UTC\"),                   length.out = 1000L, by = \"2 mins\")   # Define an initial location   x <- 708212.6   y <- 6251684   origin <- data.table(map_value = terra::extract(map, cbind(x, y))[1, 1],                        x = x, y = y)   # Collect essential arguments for `sim_path_walk()`   args <- list(.map = map,                .xinit = origin,                .timeline = timeline,                .state = \"StateXY\",                .n_path = 2L, .one_page = FALSE)   # Compare different movement models via `sim_path_walk()`   pp <- par(mfrow = c(2, 2))   args$.model_move <- model_move_xy()   do.call(sim_path_walk, args)   args$.model_move <- model_move_xy(.dbn_heading = \"VonMises(0.1, 0.1)\")   do.call(sim_path_walk, args)   par(pp)    #### Example (6): Use movement models in the particle filter   # See `?pf_filter()`    #### Example (7): Use custom movement model types   # Patter contains multiple built-in `State` and `ModelMove` sub-types that you can use   # ... (with custom parameters) simulate movements and for particle filtering.   # See the help file for `?State` to use a new sub-type.  } #> `patter::julia_connect()` called @ 2025-04-21 20:39:16...  #> ... Running `Julia` setup via `JuliaCall::julia_setup()`...  #> Julia version 1.11.5 at location /Users/lavended/.julia/juliaup/julia-1.11.5+0.aarch64.apple.darwin14/bin will be used. #> Loading setup script for JuliaCall... #> Finish loading setup script for JuliaCall. #> ... Validating Julia installation...  #> ... Setting up Julia project...  #> ... Handling dependencies...  #> ... `Julia` set up with 11 thread(s).  #> `patter::julia_connect()` call ended @ 2025-04-21 20:39:23 (duration: ~7 sec(s)).  #> ``` #> Exponential(θ) #> ``` #>  #> The *Exponential distribution* with scale parameter `θ` has probability density function #>  #> $$ #> f(x; \\theta) = \\frac{1}{\\theta} e^{-\\frac{x}{\\theta}}, \\quad x > 0 #> $$ #>  #> ```julia #> Exponential()      # Exponential distribution with unit scale, i.e. Exponential(1) #> Exponential(θ)     # Exponential distribution with scale θ #>  #> params(d)          # Get the parameters, i.e. (θ,) #> scale(d)           # Get the scale parameter, i.e. θ #> rate(d)            # Get the rate parameter, i.e. 1 / θ #> ``` #>  #> External links #>  #>   * [Exponential distribution on Wikipedia](http://en.wikipedia.org/wiki/Exponential_distribution)  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps. #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps."},{"path":"https://edwardlavender.github.io/patter/reference/ModelObs.html","id":null,"dir":"Reference","previous_headings":"","what":"Observation models — ModelObs","title":"Observation models — ModelObs","text":"ModelObs Abstract Type Patter.jl groups observation model sub-types. model_obs_*() R functions create data.table::data.tables observation model parameters can visualised R (via plot.ModelObs*() methods) instantiated ModelObs instances Julia.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/ModelObs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Observation models — ModelObs","text":"","code":"model_obs_acoustic_logis_trunc(.data, .strict = TRUE)  model_obs_depth_uniform_seabed(.data, .strict = TRUE)  model_obs_depth_normal_trunc_seabed(.data, .strict = TRUE)  model_obs_container(.data, .strict = TRUE)"},{"path":"https://edwardlavender.github.io/patter/reference/ModelObs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Observation models — ModelObs","text":".data data.table::data.table contains observation model parameters. ModelObsAcousticLogisTrunc, required columns : sensor_id receiver_x receiver_y receiver_alpha, receiver_beta receiver_gamma ModelObsDepthUniformSeabed, required columns : sensor_id depth_shallow_eps depth_deep_eps ModelObsDepthNormalTruncSeabed, required columns : sensor_id depth_sigma depth_deep_eps ModelObsContainer, required columns : sensor_id container_x container_y radius See Patter.jl JuliaCall::julia_help(\"ModelObs\") details. .strict logical variable defines whether retain columns .data defined corresponding ModelObs structure. Set .strict = TRUE (default) sim_observations(); Set .strict = FALSE pf_filter() include time stamps observations data.table::data.table;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/ModelObs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Observation models — ModelObs","text":"model_obs_*() R wrapper functions return named list, single element defines parameters observation models corresponding ModelObs structure.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/ModelObs.html","id":"model-structures","dir":"Reference","previous_headings":"","what":"Model structures","title":"Observation models — ModelObs","text":"Observation model sub-types Julia structures hold parameters observation models. R-user perspective, can think ModelObs sub-type S4-class-like object, slots parameters observation model. observation model structure, can simulate new observations evaluate log-probability existing observations. following observation models built Patter.jl: ModelObsAcousticLogisTrunc ModelObsDepthUniformSeabed ModelObsDepthNormalTruncSeabed ModelObsContainer patter, observation models required: simulate new observational datasets, via sim_observations(); run particle filter, via pf_filter(); Observation model sub-types parameters specified named list data.table::data.tables. assemble data.table::data.table parameters given ModelObs structure, see assemble functions. named list can created manually individual data.table::data.tables via model_obs_*() R functions. R functions simply check inputs wrap inputted data.table::data.tables ModelObs* parameters named list. S3-ModelObs* label added enables supporting methods (e.g., plot.ModelObs()) implemented observation models. Internally patter algorithms, observation model sub-types parameters instantiated used simulate observations particle filter. simulation observations implemented via Patter.simulate_obs(). particle filter, log-probabilities evaluated Patter.logpdf_obs(). generic functions. Different methods dispatched according input model. built-ModelObs sub-types, corresponding methods routines also built-. custom ModelObs sub-types, methods need provided. use custom ModelObs sub-types, see Examples.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/ModelObs.html","id":"model-development","dir":"Reference","previous_headings":"","what":"Model development","title":"Observation models — ModelObs","text":"Observation  models formulated, parameterised, using available datasets, domain knowledge literature. appropriate model formulation/parameterisation depends data type study system. noted , patter provides built-structures acoustic depth observations; user-defined structures custom data types also supported. parameterise acoustic observation models, consider -situ detection efficiency measurements (drift tests /sentinel tags), manufacture guidelines literature. Detection probability parameters can estimated -situ measurements using generalised linear models. estimate parameters default distance-decaying logistic detection probability model (ModelObsAcousticLogisTrunc): Assemble data.frame detections non-detections column distances receivers; Model glm(detection ~ distance, family = \"binomial\"); Take estimated intercept gradient initial values receiver_alpha receiver_beta, respectively; Set maximum detection range (receiver_gamma) based range tests, manufacturer specifications, domain knowledge literature (e.g., Klinard et al. (2019)). Note receiver_gamma defines distance beyond detections assumed impossible. Since parameter affects tail distribution, exact value can relatively unimportant, providing large enough. recommend erring side flexibility cases uncertainty. Note manufacturer guidelines may considerably underestimate maximum detection ranges (see Klinard et al. (2019) example). parameterise depth observation models, consider: Tag accuracy Bathymetric accuracy Tidal variation storm surges Species biology (e.g., benthic versus pelagic species) Note model formulation parameterisation can iterative process: Develop initial model observation models, drawing available datasets, domain knowledge literature; Perform inference, using pf_filter(); Evaluate convergence; cases convergence failures, re-evaluate model(s) try ; necessary, run algorithms restrictive flexible models analyse sensitivity; example case-study analysis, see Lavender et al. (2025). information, see GitHub issues 23, 31 33 raise new issue.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/ModelObs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Observation models — ModelObs","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/ModelObs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Observation models — ModelObs","text":"","code":"if (patter_run(.julia = TRUE, .geospatial = TRUE)) {    library(JuliaCall)   library(data.table)   library(dtplyr)   library(dplyr, warn.conflicts = FALSE)    #### Julia set up   # Connect to Julia   julia <- julia_connect()   # Set seed   set_seed()    #### Set map in Julia   map <- dat_gebco()   set_map(map)    #### Simulate path(s)   # > We simulate a path in four dimensions (see `?StateCXYZ`)   timeline <- seq(as.POSIXct(\"2016-01-01 00:00:00\", tz = \"UTC\"),                   as.POSIXct(\"2016-01-02 09:18:00\", tz = \"UTC\"),                   by = \"2 mins\")   paths <- sim_path_walk(.map        = map,                          .timeline   = timeline,                          .state      = \"StateCXYZ\",                          .xinit      = NULL,                          .n_path     = 1L,                          .model_move = model_move_cxyz())     #### --------------------------------------------------   #### In-built ModelObs types    #### Example (1): ModelObsAcousticLogisTrunc    # ModelObsAcousticLogisTrunc is an in-built ModelObs structure   # This holds the parameters of a   # ... truncated logistic acoustic observation model   # To evaluate the probability of an acoustic observation,   # ... under this model, we need to know receiver positions   # ... and the coefficients in the logistic equation.   # We can then simulate observations or run the particle filter.    # Simulate an acoustic array   array <- sim_array(.map = map,                      .timeline = timeline,                      .n_receiver = 100L,                      .arrangement = \"regular\",                      # Define logistic equation coefficients                      .receiver_alpha = 4,                      .receiver_beta = -0.01,                      .receiver_gamma = 750)    # This is a data.table of our acoustic observation model parameters   array    # The model_obs_*() function simply returns these in a list   # ... with a `ModelObsAcousticLogisTrunc` S3-class label   model_obs_acoustic_logis_trunc(array)    # We can plot observation model structures via corresponding `plot` methods   # See `?plot.ModelObs`   model_obs <- model_obs_acoustic_logis_trunc(array)   plot(model_obs)    # Simulate observations with a named list of observation model parameters   obs <- sim_observations(.timeline = timeline,                           .model_obs = model_obs)    # In long-form, the code above can be expressed as follows   sim_observations(     .timeline = timeline,     .model_obs =       list(         ModelObsAcousticLogisTrunc =           array |>           select(sensor_id = \"receiver_id\",                  \"receiver_x\", \"receiver_y\",                  \"receiver_alpha\", \"receiver_beta\", \"receiver_gamma\") |>           as.data.table()))    # In real-world scenarios, we must assemble a [`data.table::data.table`] of acoustic observations   # (For convenience, here we simply use our simulated observations)   acc <- assemble_acoustics(     .timeline   = timeline,     .detections = obs$ModelObsAcousticLogisTrunc[[1]][obs == 1L, ],     .moorings   = array     )    # The particle filter expects observations & parameters to be supplied as a named list   fwd <- pf_filter(.timeline   = timeline,                    .state      = \"StateCXYZ\",                    .model_move = model_move_cxyz(),                    .yobs       = model_obs_acoustic_logis_trunc(acc, .strict = FALSE),                    .n_particle = 1000L)    # This implementation is identical   fwd <- pf_filter(.timeline   = timeline,                    .state      = \"StateCXYZ\",                    .model_move = model_move_cxyz(),                    .yobs       = list(ModelObsAcousticLogisTrunc = acc),                    .n_particle = 1000L)    # But with the model_obs_*() implementation we benefit from in-built `plot()` methods   plot(model_obs_acoustic_logis_trunc(acc))    # See `?ModelObs` for other in-built `ModelObs` structures     #### --------------------------------------------------   #### Custom ModelObs types    # Patter contains multiple built-in `ModelObs` sub-types that you can use   # ... (with custom parameters) simulate observations and for particle filtering.   # To use a new sub-type, follow the workflow below. Some extra work is required   # ... because we have to register the sub-type in `Julia` and write the   # ... required methods to simulate observations and/or calculate log probabilities.     #### Simulate observations arising from the simulated path   # Register a custom `ModelObs` sub-type in Julia   # * We imagine a pelagic animal in which the depth at each time step   # * ... is normally distributed around the previous depth.   # * We write a `ModelObs` sub-type in `Julia` that contains the parameters   # * ... for this model (i.e., the sigma parameter of the normal distribution).   julia_command(     '     struct ModelObsDepthNormal <: Patter.ModelObs       sensor_id::Int64       depth_sigma::Float64     end   '   )   # Define a `Patter.simulate_obs()` method   # * We need to specify a function that simulates depths for `ModelObsDepthNormal`   # * We simulate depths around the previous depth (`state.z`), truncated between   # * ... the depth of the seabed (`state.map_value`) and the surface.   julia_command(     '   function Patter.simulate_obs(state::StateCXYZ, model::ModelObsDepthNormal, t::Int64)     dbn   = truncated(Normal(state.z, model.depth_sigma), 0, state.map_value)     rand(dbn)   end   '   )   # Simulate observations   model_obs <-     list(\"ModelObsDepthNormal\" = data.table(sensor_id = 1L, depth_sigma = 5))   obs  <- sim_observations(.timeline = timeline, .model_obs = model_obs)   obs  <- obs$ModelObsDepthNormal[[1]]   yobs <- list(ModelObsDepthNormal = obs)   # Plot simulated depth trajectory   # * Blue: simulated time series   # * Grey: seabed depth for simulated time series   ylim <- range(c(obs$obs, paths$map_value) * -1)   plot(obs$timestamp, obs$obs * -1, ylim = ylim, col = \"royalblue\", type = \"l\")   lines(paths$timestamp, paths$map_value * -1, col = \"grey\")    #### Run the forward filter   # (optional) Define initial states, by:   # A) Starting the filter in the correct location by masking `.map`   # B) Specifying a `map_init()` method based on the observation model   # C) Specifying a complete data.table of initial state(s)   origin       <- terra::setValues(map, NA)   cell         <- terra::cellFromXY(map, cbind(paths$x[1], paths$y[1]))   origin[cell] <- paths$map_value[1]   set_map(origin, .as_Raster = TRUE, .as_GeoArray = FALSE)   # Define a `Patter.logpdf_obs()` method   # * This is used to evaluate the log probability of a depth observation   julia_command(     '   function Patter.logpdf_obs(state::State, model::ModelObsDepthNormal, t::Int64, obs::Float64)     dbn   = truncated(Normal(state.map_value, model.depth_sigma),                       0.0, state.map_value)     logpdf(dbn, obs)   end   '   )   # Run the filter   fwd <- pf_filter(.timeline = timeline,                    .state = \"StateCXYZ\",                    .yobs = yobs,                    .model_move = model_move_cxyz(),                    .n_particle = 1000L)   # Visualise reconstructed time series   # * Black: particle depths   # * Blue: simulated time series   # * Grey: seabed depth for simulated time series   ylim <- range(c(fwd$states$z, obs$obs, paths$map_value) * -1)   plot(fwd$states$timestamp, fwd$states$z * -1, ylim = ylim, pch = \".\")   lines(obs$timestamp, obs$obs * -1 , col = \"royalblue\")   lines(paths$timestamp, paths$map_value * -1, col = \"grey\")  } #> `patter::julia_connect()` called @ 2025-04-21 20:39:30...  #> ... Running `Julia` setup via `JuliaCall::julia_setup()`...  #> ... Validating Julia installation...  #> ... Setting up Julia project...  #> ... Handling dependencies...  #> ... `Julia` set up with 11 thread(s).  #> `patter::julia_connect()` call ended @ 2025-04-21 20:39:31 (duration: ~1 sec(s)).     #> `patter::pf_filter()` called @ 2025-04-21 20:39:35...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:39:35...  #> ... 20:39:35: Setting initial states...  #> ... 20:39:39: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:39:39 (duration: ~4 sec(s)).  #> ... 20:39:39: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #> ... 20:39:41: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:39:41 (duration: ~6 sec(s)).  #> `patter::pf_filter()` called @ 2025-04-21 20:39:41...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:39:41...  #> ... 20:39:41: Setting initial states...  #> ... 20:39:41: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:39:41 (duration: ~0 sec(s)).  #> ... 20:39:41: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #>  #> Warning: Weights from filter (1 -> 1000) are zero at time 111: returning outputs from 1:111. Note that all (log) weights at 111 are -Inf. #>    #> Warning: The particle filter failed to converge. #> ... 20:39:41: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:39:41 (duration: ~0 sec(s)).   #> `patter::pf_filter()` called @ 2025-04-21 20:39:42...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:39:42...  #> ... 20:39:42: Setting initial states...  #> ... 20:39:42: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:39:42 (duration: ~0 sec(s)).  #> ... 20:39:42: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #> ... 20:39:43: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:39:43 (duration: ~1 sec(s))."},{"path":"https://edwardlavender.github.io/patter/reference/assemble.html","id":null,"dir":"Reference","previous_headings":"","what":"Assemble observations — assemble","title":"Assemble observations — assemble","text":"functions assemble timeline observations particle filter (pf_filter()).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/assemble.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assemble observations — assemble","text":"","code":"assemble_timeline(.datasets = list(), .step, .trim = FALSE)  assemble_acoustics(.timeline, .detections, .moorings, .services = NULL)  assemble_archival(.timeline, .archival)  assemble_custom(.timeline, .dataset)  assemble_xinit_containers(   .timeline,   .xinit = list(),   .radius,   .mobility,   .map = NULL,   .threshold = NULL )  assemble_acoustics_containers(   .timeline,   .acoustics,   .mobility,   .map = NULL,   .threshold = NULL )  assemble_containers(...)"},{"path":"https://edwardlavender.github.io/patter/reference/assemble.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assemble observations — assemble","text":".datasets, .step, .trim Arguments assemble_timeline(). .datasets—list data.table::data.tables, one data type, containing timestamp column; .step—character (\"2 mins\"), passed lubridate::round_date() seq.POSIXt(), defines resolution timeline; .trim—logical variable defines whether trim timeline overlapping period datasets; .timeline POSIXct vector regularly spaced time stamps defines timeline simulation (optionally assemble_timeline()). , timeline used : Define resolution observations; .detections, .moorings, .services data.table::data.tables assemble_acoustics() (see pat_setup_data()). .detections data.table::data.table acoustic detections single individual. must contain receiver_id timestamp columns. .moorings data.table::data.table acoustic receiver deployments. must contain receiver_id, receiver_start, receiver_end columns, plus  (optional) additional parameter columns. (optional) .services data.table::data.table servicing events. must contain receiver_id, service_start service_end columns. .archival assemble_archival(), .archival data.table::data.table depth observations single individual timestamp obs columns (see .dataset, ). .dataset assemble_custom(), .dataset data.table::data.table observations (depth measurements) single individual. must contain timestamp obs columns plus (optional) additional parameter columns. .xinit, .radius, Dataset arguments assemble_xinit_containers(). .xinit named list, elements \"forward\" \"backward\". Elements NULL data.table::data.table initial state(s) (.e., capture recapture locations) corresponding filter run. capture/recapture locations known exactly, use one-row data.table::data.table. starting/ending locations known exactly, multi-row data.table::data.tables (possible starting/ending locations) permitted. .radius double defines radius container around capture/recapture location particles must reach (assemble_acoustics_containers(), .radius = .acoustics$detection_gamma). .mobility, .map, .threshold Shared container threshold arguments (assemble_xinit_containers() assemble_acoustics_containers()). .mobility maximum movement distance (m) two time steps (sets rate container contraction). .map, .threshold distance threshold options. Specify .map .threshold: .map two-column matrix four coordinates study area terra::SpatRaster terra::SpatVector matrix can obtained. Linux, latter two options possible JUILA_SESSION = \"FALSE\". .threshold set automatically based distances container centroids boundaries study area. Otherwise, .threshold double defines distance threshold. .acoustics Dataset arguments assemble_acoustics_containers(). .acoustics data.table::data.table acoustic observations, assemble_acoustics(). ... assemble_containers(), ... represents container lists multiple data types, capture events (assemble_xinit_containers()) acoustic observations (assemble_acoustics_containers()).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/assemble.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assemble observations — assemble","text":"assemble_timeline() returns POSIXct vector; assemble_acoustics(), assemble_archival() assemble_custom() return data.table::data.table pf_filter(); assemble_xinit_containers(), assemble_acoustics_containers() assemble_containers() return named list, one element (data.table::data.table) () forward (b) backward runs pf_filter();","code":""},{"path":"https://edwardlavender.github.io/patter/reference/assemble.html","id":"assemble-timeline","dir":"Reference","previous_headings":"","what":"Assemble timeline","title":"Assemble observations — assemble","text":"assemble_timeline() simple function defines regular timeline, resolution .step, list input datasets. .trim = FALSE, defines sequence regular time stamps across full range time stamps input datasets. .trim = TRUE, timeline trimmed overlapping period datasets.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/assemble.html","id":"assemble-datasets","dir":"Reference","previous_headings":"","what":"Assemble datasets","title":"Assemble observations — assemble","text":"assemble_{dataset}() functions helper routines prepare timelines observations different data types required particle filter (pf_filter()). filter expects named list datasets (one data type). dataset must contain following columns: timestamp sensor_id obs Additional columns parameters observation model (see glossary). assemble_acoustics(), assemble_archival() assemble_custom() assemble 'standard' observational time series: assemble_acoustics() prepares timeline acoustic observations required filter single individual. function expects 'standard' detection dataset (, data.table::data.table like dat_detections single individual) defines detections receivers alongside moorings dataset (like dat_moorings) defines receiver deployment periods , optionally, data.table::data.table servicing events (receiver(s) non-operational). assemble_acoustics() uses datasets assemble complete time series acoustic observations; , data.table::data.table time stamps receivers defines, time step operational receiver whether (1L) (0L) detection recorded time step. Duplicate observations (, detections receiver time step) dropped. available .moorings, additional columns (receiver_alpha, receiver_beta receiver_gamma) included required default acoustic observation model (, ModelObsAcousticLogisTrunc). observation model parameters vary receiver time, simply amend columns required. assemble_archival() prepares timeline archival functions single individual. simply wraps assemble_custom() informally deprecated. assemble_custom() prepares timeline observations data types, required filter. function expects data.table::data.table includes, minimum, timestamp obs columns. latter defines observations. sensor_id column (unspecified) simply set 1L. function re-expresses time stamps resolution specified timeline. Duplicate observations (, multiple measurements time step) throw warning.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/assemble.html","id":"assemble-containers","dir":"Reference","previous_headings":"","what":"Assemble containers","title":"Assemble observations — assemble","text":"assemble_containers(), assemble_xinit_containers() assemble_acoustics_containers() assemble 'container' datasets. container circular region within individual must located, given: 'future' observation particular place, capture/recapture event acoustic detection; time observation; individual's maximum movement speed (.mobility); approach 'future' observation, container within individual must located, according observation, shrinks towards location observation recorded. Encoding knowledge particle filter (killing particles outside container incompatible future observation) facilitates convergence fewer particles, assuming regular resampling (see pf_filter()). (Otherwise, rely particles ending right region chance, can unlikely region particles must end small (e.g., receiver's detection container).) Consider acoustic containers example. Suppose individual can move .mobility = 500 m per time step, two time steps elapse first second detections, moment first detection individual must within 1000 m detection range (say, receiver_gamma = 750 m) second receiver; , moment first detection, maximum possible distance individual receiver recorded next detection 1750 m. time passes, container shrinks towards receiver(s) recorded next detection(s), line individual's .mobility. Pro-actively killing particles move outside containers (incompatible next detection) facilitates convergence. following functions assemble containers: assemble_xinit_containers() assembles containers initial capture recapture events. designed situations know starting /ending location individual. Suppose know starting location individual. can specify forward filter run via .xinit pf_filter(). backward filter run? particle smoothing (via pf_smoother_two_filter()), need forward backward filter run must align sufficiently. Containers provide mechanism encourages backward filter run end known starting location. Similarly, know recapture location, containers forward filter run provide mechanism encourages filter end location. assemble_xinit_containers(), .xinit defines initial locations forward/backward filter runs .radius defines radius starting/ending container. know capture/recapture locations exactly, strictly speaking .radius = 0. may help permit flexibility (e.g., .radius = .mobility) facilitate convergence (unlikely particles finish exactly right location). capture/recapture locations known exactly, centroid input coordinates taken container's centroid. container radius time capture/recapture event given maximum distance centroid coordinates plus .radius. time passes, containers shrink towards region line .mobility. assemble_acoustics_containers() prepares dataset acoustic containers, given acoustic time series assemble_acoustics(). Acoustic containers define region within individual must located given time step according receiver(s) next detected. radius depends time next detection, maximum movement speed detection range around receiver time detection. function requires tidyr::nest(), tidyr::unnest() zoo::na.locf() functions (suggested dependencies). assemble_containers() post-processing function. Use function collate container data.table::data.tables multiple datasets, .e., capture/recapture acoustic containers. assemble_*_containers() functions assemble list data.table::data.tables (one element forward filter run one element backward filter run). row defines maximum distance (radius) individual location future observation recorded. computational efficiency,  data.table::data.tables include containers radius < .threshold. .map supplied, .threshold set maximum distance location (e.g., receiver) furthest corner study area. Otherwise, set .threshold desired value. data.table::data.tables used instantiate Vector ModelObsContainer instances Julia. (one sub-type used container structures speed.) particle filter (pf_filter()), particle, compute log-probability particle distance particle relevant location (0.0 -Inf). re-sampling particles replacement, particles move way incompatible future data (e.g., detection) killed.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/assemble.html","id":"julia-implementation","dir":"Reference","previous_headings":"","what":"Julia implementation","title":"Assemble observations — assemble","text":"Julia, datasets translated hash-table (Dict) observations (via Patter.assemble_yobs()). time stamp observation, includes Vector Tuples, containing observation associated ModelObs instance defines parameters observation model. particle filter (Patter.particle_filter()) iterates time step timeline, uses movement model simulate animal movement , time stamps observations, evaluates likelihood observations simulated locations (particles). assemble_*() routines required real-world analyses.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/assemble.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Assemble observations — assemble","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/assemble.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assemble observations — assemble","text":"","code":"if (patter_run(.julia = FALSE, .geospatial = TRUE)) {    library(data.table)   library(dtplyr)   library(dplyr, warn.conflicts = FALSE)    #### Define example dataset(s) for a selected individual   # Study area map   map <- dat_gebco()   # Acoustic detection time series   # * Observation model parameters are defined in `.moorings`   det <-     dat_detections |>     filter(individual_id == 25L) |>     select(\"timestamp\", \"receiver_id\") |>     as.data.table()   # Archival time series   # * Observation model parameters must be included   # * Here, we define parameters for `?ModelObsDepthNormalTruncSeabed`   arc <-     dat_archival |>     filter(individual_id == 25L) |>     select(\"timestamp\", obs = \"depth\") |>     mutate(depth_sigma = 50, depth_deep_eps = 20) |>     as.data.table()    #### Example (1): Define a timeline   # Define a timeline manually   timeline <- seq(as.POSIXct(\"2016-03-01 00:00:00\", tz = \"UTC\"),                   as.POSIXct(\"2016-04-01 00:00:00\"),                   by = \"2 mins\")   # Use `assemble_timeline()` with `.trim = FALSE`   timeline <- assemble_timeline(list(det, arc), .step = \"2 mins\")   range(timeline)   # Use `assemble_timeline()` with `.trim = TRUE`   timeline <- assemble_timeline(list(det, arc), .step = \"2 mins\", .trim = TRUE)   timeline <- timeline[1:1440]   range(timeline)    #### Example (2): Assemble an acoustic timeline   # Assemble a timeline of acoustic observations (0, 1) and model parameters   # * The default acoustic observation model parameters are taken from `.moorings`   # * But can be modified or added afterwards for custom observation models   acoustics <- assemble_acoustics(.timeline = timeline,                                   .detections = det,                                   .moorings = dat_moorings)   head(acoustics)    #### Example (3): Assemble an archival timeline   # Assemble a timeline of archival observations and model parameters   archival <- assemble_archival(.timeline = timeline,                                 .archival = arc)   head(archival)    #### Example (4): Assemble custom datasets   temperature <-     data.table(timestamp = c(as.POSIXct(\"2016-03-17 01:50:30\", tz = \"UTC\"),                              as.POSIXct(\"2016-03-17 02:00:30 UTC\", tz = \"UTC\")),                obs = c(7.6, 7.7))   temperature <- assemble_custom(.timeline = timeline,                                  .dataset = temperature)   head(temperature)    #### Example (5): Assemble xinit (capture/recapture) containers   # (A) If we know the capture location, containers are defined for the backward filter run   capture_xy       <- data.table(x = 708913.6, y = 6256280)   xinit_containers <-     assemble_xinit_containers(.timeline = timeline,                               .xinit = list(forward = capture_xy,                                             backward = NULL),                               .radius = 750,                               .mobility = 750,                               .map = map)   # (B) If we know the recapture location, containers are defined for the forward run   recapture_xy     <- data.table(x = 707816.5, y = 6265746)   xinit_containers <-     assemble_xinit_containers(.timeline = timeline,                               .xinit = list(forward = NULL,                                             backward = recapture_xy),                               .radius = 750,                               .mobility = 750,                               .map = map)   # (C) If we know capture & recapture locations, containers are defined for both filter runs   xinit_containers <-     assemble_xinit_containers(.timeline = timeline,                               .xinit = list(forward = capture_xy,                                             backward = recapture_xy),                               .radius = 750,                               .mobility = 750,                               .map = map)   # (D) A set of possible capture/recapture locations is permitted:   # (i) Define possible starting locations   capture_xy <-     cbind(capture_xy$x, capture_xy$y) |>     terra::vect(crs = terra::crs(map)) |>     terra::buffer(width = 500) |>     terra::spatSample(size = 10L) |>     terra::crds(df = TRUE) |>     setDT()   # (ii) Define possible recapture locations   recapture_xy <-     cbind(recapture_xy$x, recapture_xy$y) |>     terra::vect(crs = terra::crs(map)) |>     terra::buffer(width = 500) |>     terra::spatSample(size = 10L) |>     terra::crds(df = TRUE) |>     setDT()   # (iii) Define containers   xinit_containers <-     assemble_xinit_containers(.timeline = timeline,                               .xinit = list(forward = capture_xy,                                             backward = recapture_xy),                               .radius = 750,                               .mobility = 750,                               .map = map)    #### Example (6): Assemble acoustic containers   # Assemble acoustic containers for the `acoustics` dataset above   acoustics_containers <- assemble_acoustics_containers(.timeline = timeline,                                               .acoustics = acoustics,                                               .mobility = 750,                                               .map = map)   # As for assemble_xinit_containers(), this function returns a list:   summary(acoustics_containers)   # Use the `forward` element for `pf_filter()` with `.direction = \"forward\"`   head(acoustics_containers$forward)   # Use the `backward` for `pf_filter()` with `.direction = \"backward\"`   head(acoustics_containers$backward)    #### Example (7): Collate containers for multiple datasets   containers <- assemble_containers(xinit_containers, acoustics_containers)    #### Example (8): Implement particle filter   # Use `pf_filter()` to implement the particle filter   # A list of assembled datasets is passed to the `yobs` argument   # The corresponding `ModelObs` sub-types must also be specified, e.g.:   # * `ModelObsAcousticLogisTrunc`   # * `ModelObsDepthUniformSeabed`   # * `ModelObsContainer`  }"},{"path":"https://edwardlavender.github.io/patter/reference/call_.html","id":null,"dir":"Reference","previous_headings":"","what":"Utilities: function call properties — call_","title":"Utilities: function call properties — call_","text":"functions collate information related function calls.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/call_.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utilities: function call properties — call_","text":"","code":"call_time(.time, .form = \"%Y-%m-%d %H:%M:%S\")  call_start(.fun = as.character(sys.call(-1L)), .start = Sys.time())  call_end(.fun = as.character(sys.call(-1L)), .start, .end = Sys.time())  call_duration(.start, .end, ...)  call_timings(.start, .end = Sys.time(), ...)"},{"path":"https://edwardlavender.github.io/patter/reference/call_.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Utilities: function call properties — call_","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/cat_.html","id":null,"dir":"Reference","previous_headings":"","what":"Utilities: cat_*() functions — cat_","title":"Utilities: cat_*() functions — cat_","text":"cat_*() functions control user output patter functions .verbose argument.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/cat_.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utilities: cat_*() functions — cat_","text":"","code":"cat_setup(.fun, .verbose)  cat_init(.verbose)  cat_log_file(.verbose)"},{"path":"https://edwardlavender.github.io/patter/reference/cat_.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utilities: cat_*() functions — cat_","text":".fun character string defines name parent function. .verbose logical variable string defines path text file. .verbose = FALSE suppresses user outputs; .verbose = TRUE sends user outputs console; .verbose = file.path(\"path\", \"\", \"text\", \"file.txt\") sends user outputs .txt file;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/cat_.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Utilities: cat_*() functions — cat_","text":"internal functions. cat_setup() sets messages within functions; cat_init() defines cat() wrapper based .verbose; cat_log_file() validates .verbose , necessary, creates .txt file;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/cat_.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Utilities: cat_*() functions — cat_","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/cat_.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Utilities: cat_*() functions — cat_","text":"","code":"if (FALSE) { # \\dontrun{  # Define example function wrap <- function(.verbose = getOption(\"Patter.verbose\")) {   # Set up messages and exit handler   cats <- cat_setup(.fun = \"wrap\", .verbose = .verbose)   on.exit(eval(cats$exit, envir = cats$envir), add = TRUE)   # Run function   cats$cat(\"Running function...\")   Sys.sleep(1) }  # `.verbose = TRUE` sends user output to the console wrap(.verbose = TRUE)  # `.verbose = {log}.txt` sends user output to file log.txt <- tempfile(fileext = \".txt\") wrap(.verbose = log.txt) readLines(log.txt) unlink(log.txt)  # `.verbose = TRUE` suppresses user output wrap(.verbose = FALSE) } # }"},{"path":"https://edwardlavender.github.io/patter/reference/check_dlist.html","id":null,"dir":"Reference","previous_headings":"","what":"Utilities: check data — check_dlist","title":"Utilities: check data — check_dlist","text":"functions validate user datasets. See Details patter requirements.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/check_dlist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utilities: check data — check_dlist","text":"","code":"check_map(.map)  check_detections(.detections, .moorings = NULL)  check_moorings(.moorings, .detections = NULL, .map)  check_services(.services, .moorings)  check_archival(.archival)"},{"path":"https://edwardlavender.github.io/patter/reference/check_dlist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utilities: check data — check_dlist","text":".map terra::SpatRaster defines study area simulation (see glossary). .detections, .moorings, .services, .archival Observation data.table::data.tables.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/check_dlist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utilities: check data — check_dlist","text":"function returns input dataset, described, formatted line patter's requirements.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/check_dlist.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Utilities: check data — check_dlist","text":"internal functions ensure input dataset(s) meet patter requirements. Users acoustic /archival data implement pat_setup_data() prepare datasets patter functions. Downstream functions (often) silently assume input datasets meet requirements, without subsequent checks. simplifies internal code documentation. check_map() checks .map terra::SpatRaster: Class: terra::SpatRaster; Name(s): \"map_value\"; Properties: square grid recommended; Absolute values (m) recommended; planar grid coordinates metres currently required; Source: data source may memory disk, former faster pure R functions; check_detections() checks detection time series: Class: data.table::data.table; Columns: timestamp—ordered, POSIXct vector time stamps defined tzone attribute; receiver_id—see .moorings$receiver_id; Properties: row defines detection event; Functions assume accurate clock alignment receivers; functions, single time series (one individual) required; check_services() checks acoustic servicing records: Class: data.table::data.table; Columns: receiver_id—see .moorings$receiver_id; receiver_start, receiver_end—POSIXct vectors service start end dates. /service events, receivers assumed deployed locations; receiver deployments different locations /servicing treated distinct deployments .moorings. Properties: Serviced receivers found .moorings dataset; check_moorings() checks receiver deployment records: Class: data.table::data.table; Columns: receiver_id—integer vector unique receiver deployments (1, ..., N); receiver_x receiver_y``---Receiver coordinates planar projection, matching .map`; Properties: receiver_start precede receiver_end; Receiver deployment periods (usually) least partially overlap time period acoustic detections; Receiver coordinates must valid .map (currently validated); check_archival() checks archival depth time series data: Class: data.table::data.table; Columns: timestamp—ordered, POSIXct vector time stamps defined tzone attribute; depth—numeric vector (absolute) depths (m); Properties: Functions assume accurate clock alignment acoustic archival tags (applicable); functions, single time series (one individual) required; datasets, NAs may cause unexpected errors produce message. NULL inputs permitted check_{data} functions, case NULL returned.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/check_dlist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Utilities: check data — check_dlist","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/check_utils.html","id":null,"dir":"Reference","previous_headings":"","what":"Utilities: check functions — check_utils","title":"Utilities: check functions — check_utils","text":"internal functions perform generic checks user inputs.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/check_utils.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utilities: check functions — check_utils","text":"","code":"check_dir_exists(input)  check_dir_empty(input, action = abort)  check_dir_contents_ext(input, ext, ...)  check_inherits(input, class)  check_names(   input,   req,   extract_names = names,   type = all,   action = abort,   arg = deparse(substitute(input)) )  check_named_list(input, ignore_empty = TRUE, arg = deparse(substitute(input)))  check_timeline(input, arg = deparse(substitute(input)))  check_POSIXct(.x)  check_tz(input, arg = deparse(substitute(input)))  check_new_colnames(.data, .new)  check_not_null(input, req)  check_dots_allowed(not_allowed, ...)  check_dots_for_missing_period(args, dots)"},{"path":"https://edwardlavender.github.io/patter/reference/check_utils.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Utilities: check functions — check_utils","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/cl.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelisation helpers (internal) — cl","title":"Parallelisation helpers (internal) — cl","text":"set internal wrappers parallel::parallel functions facilitate implementation parallel routines functions via pbapply::pblapply().","code":""},{"path":"https://edwardlavender.github.io/patter/reference/cl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelisation helpers (internal) — cl","text":"","code":"cl_lapply_chunk(.x, .fun, ..., .chunk_fun, .cl, .varlist, .envir)  cl_lapply_elm(.x, .fun, ..., .cl, .varlist, .envir)  cl_check(.cl = NULL, .varlist = NULL)  cl_check_chunk(.fun, .cl, .chunk, .chunk_fun)  cl_cores(.cl = NULL)  cl_chunks(.cl = NULL, .length, .nout = getOption(\"pboptions\")$nout)  cl_export(.cl = NULL, .varlist = NULL, .envir = .GlobalEnv)  cl_stop(.cl = NULL)"},{"path":"https://edwardlavender.github.io/patter/reference/cl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallelisation helpers (internal) — cl","text":"cl_lapply_chunk() returns list. cl_lapply_elm() returns list. cl_cores() returns integer. cl_chunks() returns list integers. cl_check(), cl_check_chunk(), cl_export() cl_stop() return invisible(NULL).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/cl.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parallelisation helpers (internal) — cl","text":"cl_lapply() main function. wrapper pbapply::pblapply() handles cluster checking, set , batch processing cluster closure, using following functions: cl_lapply_chunk() implements function chunks; cl_lapply_elm() implements function individual elements; cl_check() checks .cl .varlist arguments, inputted parent function. example, .cl = NULL, .varlist also NULL. cl_check_chunk() checks .chunk arguments. cl_cores() identifies number cores specified. cl_chunks() defines list, one element 'chunk' contains integer vector positions object iterate serially chunk. cl_export() implements parallel::clusterExport() .cl .varlist specified cl_stop() implements parallel::stopCluster() .cl cluster object parallel::makeCluster(). routines evolved flapper::cl_*() functions.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/cl.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parallelisation helpers (internal) — cl","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/cl_lapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelisation via lapply() — cl_lapply","title":"Parallelisation via lapply() — cl_lapply","text":"cl_lapply() wrapper pbapply::pblapply() handles cluster checking, set , batch processing cluster closure.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/cl_lapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelisation via lapply() — cl_lapply","text":"","code":"cl_lapply(   .x,   .fun,   ...,   .cl = NULL,   .varlist = NULL,   .envir = .GlobalEnv,   .chunk = FALSE,   .chunk_fun = NULL,   .use_names = TRUE,   .combine = NULL )  cl_chunk(.cl)"},{"path":"https://edwardlavender.github.io/patter/reference/cl_lapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelisation via lapply() — cl_lapply","text":".x list sequence objects iterate. .fun function applied elements .x. must accept: Elements .x first argument; .chunkargs argument .chunk_fun () supplied; ... Additional arguments passed .fun .chunk_fun (supplied). Since ... passed functions, .fun .check_fun must able handle unused arguments. .cl, .varlist, .envir (optional) Cluster arguments. .cl cluster argument passed pbapply::pblapply(), supplied : cluster object parallel::makeCluster() sister function; integer defines number child processes; .varlist character vector objects export (see parallel::clusterExport()). .envir environment export variables (see parallel::clusterExport()). .chunk, .chunk_fun (optional) Chunk arguments. chunk logical vector defines whether parallelise .x batches .x (chunks). .chunk = FALSE, function behaviour matches pbapply::pblapply(). .chunk = TRUE, .x split series chunks processed parallel; within chunk, .fun applied .x element. reduces parallelisation overhead. .chunk_fun function implemented chunk (unlike .fun implemented every element every chunk). must accept following argument(s): Elements .x specific chunk first argument; output .chunk_fun made available .fun via .chunkargs. .use_names logical variable defines whether use .x's names name output elements. silently ignored .combine specified. .combine (optional) function defines combine list elements. .combine = NULL, list returned. suitable options , example, purrr::list_flatten() data.table::rbindlist().","code":""},{"path":"https://edwardlavender.github.io/patter/reference/cl_lapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallelisation via lapply() — cl_lapply","text":"cl_lapply() invisibly returns list combined list (defined .combine). cl_chunk() returns logical variable.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/cl_lapply.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parallelisation via lapply() — cl_lapply","text":"cl_lapply() exported, found useful projects, primarily intended internal use. Use pbapply::pboptions() control progress bar, including number gradations (nout). nout also controls number chunks core. Fewer chunks reduce parallelisation overhead also number gradations progress bar. cl_chunk() sets default chunk behaviour cl_lapply() wrapper functions: single core specified, cl_chunk() returns FALSE. Otherwise, cl_chunk() returns TRUE. cl_lapply() associated (internal) functions evolved flapper::cl_*() functions.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/cl_lapply.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parallelisation via lapply() — cl_lapply","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/coa.html","id":null,"dir":"Reference","previous_headings":"","what":"COA: centres of activity — coa","title":"COA: centres of activity — coa","text":"function calculates centres activity (COAs) detections acoustic receivers.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/coa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"COA: centres of activity — coa","text":"","code":"coa(   .map,   .detections,   .moorings = NULL,   .delta_t,   .split = NULL,   .plot_weights = TRUE,   ...,   .one_page = TRUE )"},{"path":"https://edwardlavender.github.io/patter/reference/coa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"COA: centres of activity — coa","text":".map terra::SpatRaster defines study area (see glossary). , .map used : Extract map_value centres activity, consistency routines (pf_filter()); .detections, .moorings Acoustic detection data.table::data.table. .detections data.table::data.table acoustic detections, following columns: receiver_id (sensor_id), timestamp (optionally) receiver_x receiver_y columns; (optional) .moorings data.table::data.table receiver coordinates, provided unavailable .detections, receiver_id, receiver_x receiver_y columns; Receiver coordinates must planar. .delta_t time interval calculate COAs. can specified way understood lubridate::floor_date() (see unit argument). .split (optional) character defines name grouping factor .detections (e.g., individual_id dat_detections). .plot_weights, ..., .one_page Plot arguments. .plot_weights logical variable defines whether plot frequency distribution weights .split value (.e., frequency distribution number detections receiver time interval, excluding time intervals without detections). ... placeholder arguments passed graphics::hist(), excluding main. .one_page logical variable defines whether plot histograms one page.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/coa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"COA: centres of activity — coa","text":"function returns data.table::data.table following columns: {.split}—character vector distinguishes groups, applicable; timestep—integer vector time steps; timestamp—POSIXt vector time stamps; map_value, x, y—value .map COAs coordinates; Data arranged .split timestamp.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/coa.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"COA: centres of activity — coa","text":"COAs calculated weighted mean locations receivers individuals detected consecutive time intervals, weighted frequency detections receivers. COAs calculated via stats::weighted.mean(), assumes planar coordinates, consistency patter routines. handle longitude/latitude coordinates, use geosphere::geomean(). function replaces flapper::coa(). See  flapper::coa_setup_delta_t() evaluate alternative time internals. Linux, function used within Julia session.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/coa.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"COA: centres of activity — coa","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/coa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"COA: centres of activity — coa","text":"","code":"if (patter_run(.julia = FALSE, .geospatial = TRUE)) {    library(data.table)    #### Set up example   map        <- dat_gebco()   detections <- dat_detections   moorings   <- dat_moorings    #### Example (1): Calculate COAs for an example individual   id     <- dat_detections$individual_id[1]   det    <- dat_detections[individual_id == id, ]   coa(.map = map, .detections = det, .moorings = moorings,       .delta_t = \"2 hours\")    #### Example (2): Customise the time interval via `.delta_t`   coa(.map = map, .detections = det, .moorings = moorings,       .delta_t = \"4 hours\")    #### Example (3): Calculate COAs for multiple individuals via `.split`   # Calculate COAs   coa(.map = map, .detections = det, .moorings = moorings,       .delta_t = \"6 hours\", .split = \"individual_id\")   # Use one page for plots via `.one_page = TRUE`   coa(.map = map, .detections = det, .moorings = moorings,       .delta_t = \"6 hours\", .split = \"individual_id\",       .one_page = FALSE)   # Suppress plots via `.plot = FALSE`   coa(.map = map, .detections = det, .moorings = moorings,       .delta_t = \"6 hours\", .split = \"individual_id\",       .one_page = TRUE)    #### Example (4): Specify `.detections` only   # `.moorings` is not required if `.detections` contains receiver coordinates   coa(.map = map,       .detections =         detections |>         merge(moorings, by = \"receiver_id\"),       .delta_t = \"6 hours\", .split = \"individual_id\")  }       #>       individual_id timestep           timestamp map_value        x       y #>               <int>    <int>              <POSc>     <num>    <num>   <num> #>    1:            25        1 2016-03-17 00:00:00  59.76520 709120.1 6253030 #>    2:            25        2 2016-03-17 06:00:00  49.72233 709398.4 6253169 #>    3:            25        3 2016-03-21 18:00:00  58.17422 709242.1 6253107 #>    4:            25        4 2016-03-22 00:00:00  58.17422 709242.1 6253107 #>    5:            25        5 2016-03-22 06:00:00  58.17422 709242.1 6253107 #>   ---                                                                       #> 1204:            35      402 2017-04-10 18:00:00  99.90396 709048.8 6253427 #> 1205:            35      403 2017-04-11 18:00:00  49.51562 706342.1 6254307 #> 1206:            35      404 2017-04-12 00:00:00 117.36553 707042.1 6253840 #> 1207:            35      405 2017-04-12 18:00:00 113.60658 708771.2 6253210 #> 1208:            35      406 2017-04-19 18:00:00 129.77667 707242.1 6253707"},{"path":"https://edwardlavender.github.io/patter/reference/datasets-algorithms.html","id":null,"dir":"Reference","previous_headings":"","what":"Datasets: example algorithm outputs — datasets-algorithms","title":"Datasets: example algorithm outputs — datasets-algorithms","text":"functions load example outputs key patter functions. included package streamline function examples tests.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/datasets-algorithms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Datasets: example algorithm outputs — datasets-algorithms","text":"","code":"dat_path()  dat_coa()  dat_pff()  dat_pfb()  dat_tff()"},{"path":"https://edwardlavender.github.io/patter/reference/datasets-algorithms.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Datasets: example algorithm outputs — datasets-algorithms","text":"full details algorithm parameters used generate datasets, see https://github.com/edwardlavender/patter/blob/main/data-raw/003-add-data-algorithms.R.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/datasets-algorithms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Datasets: example algorithm outputs — datasets-algorithms","text":"functions return dataset character string defines path dataset. See corresponding function documentation full details.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/datasets-algorithms.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Datasets: example algorithm outputs — datasets-algorithms","text":"dat_path() reads example output sim_path_walk(); dat_coa() reads example output coa(); dat_pff() reads example output forward run pf_filter(); dat_pfb() reads example output backward run pf_filter(); dat_tff() reads example output pf_smoother_two_filter();","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/datasets-algorithms.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Datasets: example algorithm outputs — datasets-algorithms","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/datasets-algorithms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Datasets: example algorithm outputs — datasets-algorithms","text":"","code":"# Load inbuilt datasets dat_path() |> summary() #>     path_id     timestep        timestamp                     map_value       #>  Min.   :1   Min.   :  1.00   Min.   :2016-01-01 00:00:00   Min.   :  5.661   #>  1st Qu.:1   1st Qu.: 90.75   1st Qu.:2016-01-01 02:59:30   1st Qu.: 27.332   #>  Median :1   Median :180.50   Median :2016-01-01 05:59:00   Median : 47.209   #>  Mean   :1   Mean   :180.50   Mean   :2016-01-01 05:59:00   Mean   : 73.360   #>  3rd Qu.:1   3rd Qu.:270.25   3rd Qu.:2016-01-01 08:58:30   3rd Qu.:116.657   #>  Max.   :1   Max.   :360.00   Max.   :2016-01-01 11:58:00   Max.   :196.003   #>        x                y           #>  Min.   :706015   Min.   :6259156   #>  1st Qu.:707440   1st Qu.:6261930   #>  Median :710191   Median :6263235   #>  Mean   :709700   Mean   :6263451   #>  3rd Qu.:711246   3rd Qu.:6265161   #>  Max.   :711852   Max.   :6267903   dat_coa() |> summary() #>     timestep      timestamp                     map_value            x          #>  Min.   :1.00   Min.   :2016-01-01 00:00:00   Min.   : 24.39   Min.   :706900   #>  1st Qu.:2.25   1st Qu.:2016-01-01 02:30:00   1st Qu.: 31.60   1st Qu.:708216   #>  Median :3.50   Median :2016-01-01 05:00:00   Median : 52.49   Median :710228   #>  Mean   :3.50   Mean   :2016-01-01 05:00:00   Mean   : 83.81   Mean   :709568   #>  3rd Qu.:4.75   3rd Qu.:2016-01-01 07:30:00   3rd Qu.:134.28   3rd Qu.:711013   #>  Max.   :6.00   Max.   :2016-01-01 10:00:00   Max.   :187.29   Max.   :711229   #>        y           #>  Min.   :6259666   #>  1st Qu.:6262546   #>  Median :6263398   #>  Mean   :6263395   #>  3rd Qu.:6264844   #>  Max.   :6266321   dat_pff() |> summary() #>             Length Class      Mode #> states      6      data.table list #> diagnostics 4      data.table list #> callstats   7      data.table list dat_pfb() |> summary() #>             Length Class      Mode #> states      6      data.table list #> diagnostics 4      data.table list #> callstats   7      data.table list dat_tff() |> summary() #>             Length Class      Mode #> states      6      data.table list #> diagnostics 4      data.table list #> callstats   7      data.table list"},{"path":"https://edwardlavender.github.io/patter/reference/datasets-mefs.html","id":null,"dir":"Reference","previous_headings":"","what":"Datasets: the MEFS project — datasets-mefs","title":"Datasets: the MEFS project — datasets-mefs","text":"sample datasets collated Movement Ecology Flapper Skate (MEFS) project (Lavender, 2022). flapper skate (Dipturus intermedius) Critically Endangered benthic elasmobranch. part MEFS project, flapper skate tagged acoustic transmitters archival (data storage) tags west coast Scotland 2016–17. Acoustic transmissions recorded array passive acoustic telemetry receivers. Concurrent depth time series recorded archival tags recovered recaptured individuals. full details, see references . datasets defined within patter illustrate package functions using real-world datasets.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/datasets-mefs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Datasets: the MEFS project — datasets-mefs","text":"","code":"dat_moorings  dat_detections  dat_archival  dat_gebco(.return = c(\"SpatRaster\", \"character\"))  dat_coast(.return = c(\"SpatVector\", \"character\"))  dat_mpa(.return = c(\"SpatVector\", \"character\"))"},{"path":"https://edwardlavender.github.io/patter/reference/datasets-mefs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Datasets: the MEFS project — datasets-mefs","text":"object class data.table (inherits data.frame) 40 rows 8 columns. object class data.table (inherits data.frame) 39242 rows 3 columns. object class data.table (inherits data.frame) 75000 rows 3 columns.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/datasets-mefs.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Datasets: the MEFS project — datasets-mefs","text":"Biologging biotelemetry data collected , belong , Marine Scotland Science NatureScot. Data processed Lavender (2022). wish use data, please contact Marine Scotland Science NatureScot information. Bathymetry data sourced GEBCO Compilation Group (2019) GEBCO 2019 Grid. https://www.doi.org/10.5285/836f016a-33be-6ddc-e053-6c86abc0788e Coastline data sourced flapper::dat_coast. MPA boundary data assembled E. Lavender.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/datasets-mefs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Datasets: the MEFS project — datasets-mefs","text":".return character defines object returned dat_gebco(), dat_coast() dat_mpa(): SpatRaster returns terra::SpatRaster; SpatVector returns terra::SpatVector; character returns file path raster. supported option Linux JULIA_SESSION = \"TRUE\";","code":""},{"path":"https://edwardlavender.github.io/patter/reference/datasets-mefs.html","id":"moorings","dir":"Reference","previous_headings":"","what":"Moorings","title":"Datasets: the MEFS project — datasets-mefs","text":"dat_moorings defines passive acoustic telemetry receiver locations associated information. includes following columns: receiver_id—integer vector defines unique receiver deployments; receiver_start, receiver_end—Date vectors define receiver deployment start end dates; receiver_x, receiver_y—numeric vectors define receiver coordinates (UTM 29N); receiver_alpha, receiver_beta, receiver_gamma—numeric vectors define detection probability parameters; Data arranged receiver_id.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/datasets-mefs.html","id":"detections","dir":"Reference","previous_headings":"","what":"Detections","title":"Datasets: the MEFS project — datasets-mefs","text":"dat_detections contains sample detection time series. includes following columns: individual_id—integer vector identifies individuals; timestamp—POSIXct vector defines time observation; receiver_id—receiver ID (see dat_moorings); Data arranged individual_id, timestamp receiver_id.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/datasets-mefs.html","id":"archival","dir":"Reference","previous_headings":"","what":"Archival","title":"Datasets: the MEFS project — datasets-mefs","text":"dat_archival contains sample depth time series. Observations sampled every 2 minutes. data includes following columns: individual_id—integer vector identifies individuals (dat_detections); timestamp—POSIXct vector defines time observation; depth—numeric vector defines depth (m) individual time step; Data arranged individual_id timestamp.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/datasets-mefs.html","id":"bathymetry","dir":"Reference","previous_headings":"","what":"Bathymetry","title":"Datasets: the MEFS project — datasets-mefs","text":"dat_gebco() returns bathymetry (m) dataset west coast Scotland MEFS data collected. dataset terra::SpatRaster following properties: dimensions—264, 190, 1 (nrow, ncol, nlyr); resolution—100, 100  (x, y); extent—695492.1, 714492.1, 6246657, 6273057  (xmin, xmax, ymin, ymax); coord. ref.—WGS 84 / UTM zone 29N (EPSG:32629);","code":""},{"path":"https://edwardlavender.github.io/patter/reference/datasets-mefs.html","id":"coastline","dir":"Reference","previous_headings":"","what":"Coastline","title":"Datasets: the MEFS project — datasets-mefs","text":"dat_coast() returns terra::SpatVector coastline region.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/datasets-mefs.html","id":"marine-protected-area","dir":"Reference","previous_headings":"","what":"Marine Protected Area","title":"Datasets: the MEFS project — datasets-mefs","text":"dat_mpa() returns terra::SpatVector boundaries Loch Sunart Sound Jura Marine Protected Area (MPA) following columns: id—character label polygon; open—character defines whether id open closed fishing; col—character defines colour (visualising);","code":""},{"path":"https://edwardlavender.github.io/patter/reference/datasets-mefs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Datasets: the MEFS project — datasets-mefs","text":"Data collection processing described Lavender (2022). Modelling movements flapper skate (Dipturus intermedius) relation Scottish Marine Protected Area. University St Andrews. https://www.doi.org/10.17630/sta/201 information MEFS project, see: Lavender, E. et al. (2021). Movement patterns Critically Endangered elasmobranch (Dipturus intermedius) Marine Protected Area. Aquat. Conserv. 32: 348–65. https://www.doi.org/10.1002/aqc.3753 Lavender, E. et al. (2021). Individual variation environmental cycles vertical movements benthic elasmobranch. Mar. Biol. 168: 164. https://www.doi.org/10.1007/s00227-021-03973-1 Lavender, E. et al. (2022). Behavioural responses large, benthic elasmobranch catch--release angling. Front. Mar. Sci. 9: 864344. https://www.doi.org/10.3389/fmars.2022.864344 Thorburn, J. et al. (2021). Seasonal ontogenetic variation depth use Critically Endangered benthic elasmobranch implications spatial management. Front. Mar. Sci. 8: 829.https://www.doi.org/10.3389/fmars.2021.656368 Lavender, E. et al. (2022). Benthic animal-borne sensors citizen science combine validate ocean modelling. Sci. Rep. 12: 16613. https://www.doi.org/1038/s41598-022-20254-z Lavender, E. et al. (2023). integrative modelling framework passive acoustic telemetry. Meth. Ecol. Evol: 14, 2626–2638. https://doi.org/10.1111/2041-210X.14193","code":""},{"path":"https://edwardlavender.github.io/patter/reference/dot-map_mark.html","id":null,"dir":"Reference","previous_headings":"","what":"Map: location marks (weights) — .map_mark","title":"Map: location marks (weights) — .map_mark","text":"function calculates coordinate weights dataset time series.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/dot-map_mark.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map: location marks (weights) — .map_mark","text":"","code":".map_mark(.coord)"},{"path":"https://edwardlavender.github.io/patter/reference/dot-map_mark.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map: location marks (weights) — .map_mark","text":".coord data.table::data.table defines coordinates, following columns: (required) id—vector distinguishes coordinate IDs (grid cells unique coordinate pairs); (optional) timestep—vector distinguishes time steps, coordinates sampled time; (optional) mark—numeric vector coordinate weights;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/dot-map_mark.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map: location marks (weights) — .map_mark","text":"function returns data.table::data.table. Columns match .coord, excluding timestep specified (since weights summarised within across time steps). one row unique coordinate ID mark column defines associated weights.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/dot-map_mark.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map: location marks (weights) — .map_mark","text":"Equal weights assumed unless specified mark column. Default supplied weights normalised sum one time step (necessary). total weight coordinate ID within time steps calculated weights aggregated coordinate ID across whole time series (applicable) renormalised sum one.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/dot-map_mark.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Map: location marks (weights) — .map_mark","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/example_setup.html","id":null,"dir":"Reference","previous_headings":"","what":"Examples: streamline set up — example_setup","title":"Examples: streamline set up — example_setup","text":"functions used streamline package examples. Windows MacOS compatible.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/example_setup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Examples: streamline set up — example_setup","text":"","code":"example_setup(.fun, .connect)  # Default S3 method example_setup(.fun, .connect)  # S3 method for class 'pf_smoother_two_filter' example_setup(.fun, .connect = TRUE)"},{"path":"https://edwardlavender.github.io/patter/reference/example_setup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Examples: streamline set up — example_setup","text":".fun character defines name patter function corresponding example_setup() method. .connect logical variable defines whether run julia_connect(). Set FALSE testing.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/example_setup.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Examples: streamline set up — example_setup","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/file_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Utilities: file helpers — file_path","title":"Utilities: file helpers — file_path","text":"simple file system utilities.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/file_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utilities: file helpers — file_path","text":"","code":"file_path(...)  file_list(.sink, .folder = NULL, ...)  file_size(.sink, .folder = NULL, ..., .unit = c(\"MB\", \"GB\", \"TB\"))  file_cleanup(.sink)"},{"path":"https://edwardlavender.github.io/patter/reference/file_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utilities: file helpers — file_path","text":"... file_path(), ... passed file.path(). Otherwise, ... placeholder additional arguments passed list.files(), pattern, excluding full.names. .sink character string defines directory files located. .folder (optional) character string defines name sub-folder list files (via file_list()) summarise file sizes (via file_size()). .unit file_size(), .unit character string defines units output (MB, GB, TB).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/file_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utilities: file helpers — file_path","text":"file_path() returns character string defines file path. file_list() returns ordered vector file paths. file_size() returns number. file_cleanup() returns invisible(NULL).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/file_path.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Utilities: file helpers — file_path","text":"file_path() simple wrapper file.path() constructs file path verifies exists. file_list() creates ordered list numbered files. function expects files named 1.{.ext}, 2.{.ext}, ..., N.{.ext}. listed files must share file extension. file_size() calculates total size files directory. file_cleanup() deletes temporary files directories recursively;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/file_path.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Utilities: file helpers — file_path","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/file_path.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Utilities: file helpers — file_path","text":"","code":"# Set up example temp <- tempdir() sink <- file.path(temp, \"patter\") dir.create(sink, recursive = TRUE) write.table(\"\", file = file.path(sink, \"1.csv\")) write.table(\"\", file = file.path(sink, \"2.csv\"))  # Use `file_path()` to construct & validate file paths file_path(temp, \"patter\") #> [1] \"/var/folders/nl/ygb3g6tj24z06jddbqqhj6hw0000gn/T//Rtmp7UjMjz/patter\"  # Use `file_list()` to list files file_list(temp, \"patter\", pattern = \"*.csv$\") #> [1] \"/var/folders/nl/ygb3g6tj24z06jddbqqhj6hw0000gn/T//Rtmp7UjMjz/patter/1.csv\" #> [2] \"/var/folders/nl/ygb3g6tj24z06jddbqqhj6hw0000gn/T//Rtmp7UjMjz/patter/2.csv\"  # Use `file_size()` to summarise file sizes file_size(temp, \"patter\") #> [1] 2.2e-05 file_size(temp, \"patter\", .unit = \"GB\") #> [1] 2.2e-08 file_size(temp, \"patter\", .unit = \"TB\") #> [1] 2.2e-11  file_cleanup(sink)"},{"path":"https://edwardlavender.github.io/patter/reference/glossary.html","id":null,"dir":"Reference","previous_headings":"","what":"Glossary — glossary","title":"Glossary — glossary","text":"glossary key arguments patter.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/glossary.html","id":"-map","dir":"Reference","previous_headings":"","what":".map","title":"Glossary — glossary","text":".map terra::SpatRaster (supported Windows MacOS) character defines path raster (supported Windows, MacOS Linux) defines area interest. NAs define inhospitable regions (land). planar (e.g., Universal Transverse Mercator) projection coordinates metres currently required.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/glossary.html","id":"-model-obs","dir":"Reference","previous_headings":"","what":".model_obs","title":"Glossary — glossary","text":".model_obs named list ModelObs sub-types (named) associated parameters (data.table::data.table elements).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/glossary.html","id":"-model-move","dir":"Reference","previous_headings":"","what":".model_move","title":"Glossary — glossary","text":".model_move character string defines ModelMove instance.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/glossary.html","id":"-state","dir":"Reference","previous_headings":"","what":".state","title":"Glossary — glossary","text":".state character defines State sub-type.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/glossary.html","id":"-yobs","dir":"Reference","previous_headings":"","what":".yobs","title":"Glossary — glossary","text":".yobs named list observational datasets, one data type. Element names must correspond ModelObs sub-types defined Julia. element must data.table::data.table following columns: timestamp—POSIXct vector time stamps; sensor_id—integer vector sensor IDs, receivers; obs—vector observations; Additional columns define parameters observation model, defined ModelObs structure; columns included. real-world analyses, see assemble_*() functions format datasets required. types datasets require manual preparation.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/glossary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Glossary — glossary","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/julia_connect.html","id":null,"dir":"Reference","previous_headings":"","what":"Julia: connect R to Julia — julia_connect","title":"Julia: connect R to Julia — julia_connect","text":"function connects R Julia.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/julia_connect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Julia: connect R to Julia — julia_connect","text":"","code":"julia_connect(   JULIA_HOME,   JULIA_PROJ,   JULIA_NUM_THREADS,   JULIA_PATTER_SOURCE,   .pkg_config = NULL,   .pkg_install = NULL,   .pkg_update = NULL,   .pkg_load = NULL,   .socket = !interactive(),   .verbose = getOption(\"patter.verbose\"),   ... )"},{"path":"https://edwardlavender.github.io/patter/reference/julia_connect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Julia: connect R to Julia — julia_connect","text":"JULIA_HOME, JULIA_PROJ, JULIA_NUM_THREADS, JULIA_PATTER_SOURCE (optional) Julia options, provided function arguments, global options environment variables. JULIA_HOME—character string defines location Julia installation (see JuliaCall::julia_setup()). Usually, required. JULIA_PROJ—character string defines directory Julia Project. unspecified, default environment (e.g., ~/.julia/environments/v1.10/Project.toml) used message instead local Julia project. JULIA_NUM_THREADS—MacOS Linux, JULIA_NUM_THREADS character (\"auto\") integer defines number threads used multi-threaded operations Julia. defaults \"auto\" (1). can set per R session. Windows, JULIA_NUM_THREADS must set system-wide use argument produces warning. See GitHub Issue instructions. JULIA_PATTER_SOURCE—advanced use : character string defines source Patter.jl. may : absolute file path local copy package, case added development dependency; Git branch name (e.g., \"main\", \"dev\") commit SHA (e.g., \"b7c2fda733f80fcfd8770058cded7e0946b3abc0\"); valid installation URL (e.g., \"https://github.com/edwardlavender/Patter.jl.git\"); missing, JULIA_PATTER_SOURCE defaults \"https://github.com/edwardlavender/Patter.jl.git\". JULIA_PATTER_SOURCE changes, force update .pkg_update. .pkg_config, .pkg_install, .pkg_update, .pkg_load (optional) Julia package options. .pkg_config character string Julia code, evaluated julia_code(), configures Julia prior dependency management. .pkg_install—character vector accessory Julia packages install. .pkg_update—Package update control: NULL FALSE suppresses package updates; TRUE updates installed packages; character vector updates named packages; .pkg_load—Package loading (using) control: NULL FALSE loads required packages ; TRUE loads installed packages character vector loads required additionally named packages; Note Patter.jl, .pkg_update respect current branch installation always defaults \"https://github.com/edwardlavender/Patter.jl.git\". Specify JULIA_PATTER_SOURCE update different branch. .socket logical variable defines whether reconnect Julia. Use FALSE (default) skip re-running function (.e., JULIA_SESSION = \"TRUE\"); Use TRUE force reconnect. required nodes socket cluster, inherit JULIA_SESSION = \"TRUE\" connected Julia; .verbose User output control (see patter-progress supported options). ... Additional arguments passed JuliaCall::julia_setup() (excluding verbose).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/julia_connect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Julia: connect R to Julia — julia_connect","text":"function returns Julia interface invisibly (see JuliaCall::julia_setup()). JULIA_SESSION already \"TRUE\" .socket = FALSE, invisible(NULL) returned.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/julia_connect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Julia: connect R to Julia — julia_connect","text":"patter R front-end Patter.jl package. requires local installation Julia. function connects R local Julia installation, sets JuliaCall, provides integration R Julia, Patter.jl. Internally, steps follows: JuliaCall set via JuliaCall::julia_setup(). environment variable JULIA_SESSION set \"TRUE\". number threads set, possible, via JULIA_NUM_THREADS. Julia installation validated. local Julia Project generated JULIA_PROJ (specified required) activated. recommend using patter within RStudio Project, Julia directory top-level contains Julia project. specified, .pkg_config run via julia_code(). Patter.jl supporting dependencies added updated (required) loaded (optionally local Julia Project). set JULIA_* options (e.g., JULIA_HOME, JULIA_PROJ, JULIA_NUM_THREADS), recommended use .Rprofile .Renviron. set options .Rprofile, follow instructions:   run julia_connect() per R session (additionally every socket socket cluster, necessary). update number threads, restart R re-run function updated JULIA_NUM_THREADS argument.","code":"# (1) Open .Rprofile usethis::edit_r_profile()  # (2) Add the following to .Rprofile  # Use a local `Julia` project: if (!requireNamespace(\"here\", quietly = TRUE)) {   install.packages(\"here\") } julia_proj <- here::here(\"Julia\") if (!dir.exists(julia_proj)) {   dir.create(julia_proj) } Sys.setenv(JULIA_PROJ = here::here(\"Julia\"))  # Set `JULIA_NUM_THREADS` (on MacOS/Linux): # - In general, more threads faster, up to a point; # - On Windows, follow the alternative instructions linked above; # - (You may also set [`data.table::data.table`] threads here via `OMP_NUM_THREADS`) Sys.setenv(JULIA_NUM_THREADS = parallel::detectCores() - 1L)  # (3) Save .Rprofile and restart R:  # (4) Run `julia_connect()` in the `R` console as usual: # There is no need to specify `JULIA_*` arguments e.g., JULIA_PROJ # There are inherited from .Rprofile julia_connect()"},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/julia_connect.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Julia: connect R to Julia — julia_connect","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/julia_connect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Julia: connect R to Julia — julia_connect","text":"","code":"if (patter_run(.geospatial = FALSE)) {    #### Set JULIA OPTIONS   # Recommended: set JULIA options in .Rprofile or .Renviron (see Details)   # Otherwise: include JULIA options as function arguments below    #### Example (1): First time use   # Use `...` to customise `JuliaCall::julia_setup()`   # Try `installJulia` if you require a Julia installation   # The first call to `julia_connect()` may take several minutes   julia_connect(installJulia = TRUE)    #### Example (2): Connect to `Julia` using default settings   julia_connect()    #### Example (3): Force an update of installed packages   # This example is potentially slow   if (FALSE) {     # Update a specific package     julia_connect(.pkg_update = \"GeoArrays\")     # Update all packages     julia_connect(.pkg_update = TRUE)   }    #### Example (4): Customise user output   julia_connect(.verbose = FALSE)  } #> `patter::julia_connect()` called @ 2025-04-21 20:39:58...  #> ... Running `Julia` setup via `JuliaCall::julia_setup()`...  #> ... Validating Julia installation...  #> ... Setting up Julia project...  #> ... Handling dependencies...  #> ... `Julia` set up with 11 thread(s).  #> `patter::julia_connect()` call ended @ 2025-04-21 20:39:58 (duration: ~0 sec(s)).  #> `patter::julia_connect()` called @ 2025-04-21 20:39:58...  #> ... Running `Julia` setup via `JuliaCall::julia_setup()`...  #> ... Validating Julia installation...  #> ... Setting up Julia project...  #> ... Handling dependencies...  #> ... `Julia` set up with 11 thread(s).  #> `patter::julia_connect()` call ended @ 2025-04-21 20:39:58 (duration: ~0 sec(s))."},{"path":"https://edwardlavender.github.io/patter/reference/julia_helper.html","id":null,"dir":"Reference","previous_headings":"","what":"Julia: helpers — julia_helper","title":"Julia: helpers — julia_helper","text":"set Julia helper functions.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/julia_helper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Julia: helpers — julia_helper","text":"","code":"julia_session()  julia_works(.action = abort)  julia_option(VALUE)  julia_proj_path(JULIA_PROJ)  julia_proj_generate(JULIA_PROJ)  julia_proj_activate(JULIA_PROJ)  julia_proj_temp()  julia_pkg_list_full(.pkg_install)  julia_pkg_list_req()  julia_pkg_list_installed()  julia_pkg_list_update(.pkg_update)  julia_pkg_list_load(.pkg_load)  julia_pkg_patter_source(JULIA_PATTER_SOURCE)  julia_pkg_install_Patter(JULIA_PATTER_SOURCE, .pkg_update)  julia_pkg_install_deps(.pkg_install, .pkg_update)  julia_pkg_library(.pkg_load)  julia_pkg_version_Patter.jl()  julia_pkg_compat()  julia_pkg_setup(JULIA_PATTER_SOURCE, .pkg_install, .pkg_update, .pkg_load)  julia_threads(JULIA_NUM_THREADS)  julia_glimpse(.x)  julia_print(.x)  julia_summary(.x)  julia_save(.x, .file = .x)  julia_load(.file, .x = basename(tools::file_path_sans_ext(.file)))  julia_timeline(.x)  julia_check_exists(...)  julia_code(.x)  julia_n_particle(.n_particle)"},{"path":"https://edwardlavender.github.io/patter/reference/julia_helper.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Julia: helpers — julia_helper","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/julia_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Julia: set objects in Julia — julia_set","title":"Julia: set objects in Julia — julia_set","text":"internal functions assign objects variable names Julia.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/julia_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Julia: set objects in Julia — julia_set","text":"","code":"set_JULIA_NUM_THREADS(JULIA_NUM_THREADS)  set_timeline(.timeline)  set_state_type(.state)  set_xinit(.xinit)  set_model_move(.model_move)  set_path()  set_model_obs_types(.datasets)  set_model_obs(.model_obs)  set_yobs_vect(.timeline, .yobs)  set_yobs_dict(.yobs)  set_yobs_dict_via_sim()  set_n_particle(.n_particle)  set_direction(.direction = c(\"forward\", \"backward\"))  set_states_init(   .timeline,   .state,   .xinit,   .model_move,   .yobs,   .n_particle,   .direction,   .collect )  set_t_resample(.t_resample)  set_batch(.batch, .type = c(\"fwd\", \"bwd\", \"smo\"))  set_progress(.progress)  set_verbose(.verbose)  set_pf_filter(   .n_move,   .n_resample,   .t_resample,   .n_record,   .n_iter,   .direction,   .batch,   .progress,   .verbose )  set_cache(.cache)  set_smoother_two_filter(   .n_particle,   .n_sim,   .cache,   .batch,   .progress,   .verbose )"},{"path":"https://edwardlavender.github.io/patter/reference/julia_set.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Julia: set objects in Julia — julia_set","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/julia_validate.html","id":null,"dir":"Reference","previous_headings":"","what":"Julia: validate the R—Julia interface — julia_validate","title":"Julia: validate the R—Julia interface — julia_validate","text":"Load attach patter, connect Julia via julia_connect() run julia_validate() validate R—Julia interface works.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/julia_validate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Julia: validate the R—Julia interface — julia_validate","text":"","code":"julia_validate()"},{"path":"https://edwardlavender.github.io/patter/reference/julia_validate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Julia: validate the R—Julia interface — julia_validate","text":"function returns invisible(NULL), unless error experienced.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/julia_validate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Julia: validate the R—Julia interface — julia_validate","text":"function validates R—Julia interface example terra::SpatRaster exported Julia modified R. function returns nothing, good go. systems, observed segmentation faults crash R map exported Julia /modified R. Please report issues.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/julia_validate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Julia: validate the R—Julia interface — julia_validate","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/julia_validate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Julia: validate the R—Julia interface — julia_validate","text":"","code":"if (patter_run(.geospatial = FALSE)) {    library(testthat)    # Connect `R` to `Julia`   julia_connect()    # Validate the connection   # * If the function returns NULL, we are good to go.   # * Otherwise, an error will be raised (or `R` will crash).   expect_null(julia_validate())  } #> `patter::julia_connect()` called @ 2025-04-21 20:39:59...  #> ... Running `Julia` setup via `JuliaCall::julia_setup()`...  #> ... Validating Julia installation...  #> ... Setting up Julia project...  #> ... Handling dependencies...  #> ... `Julia` set up with 11 thread(s).  #> `patter::julia_connect()` call ended @ 2025-04-21 20:39:59 (duration: ~0 sec(s))."},{"path":"https://edwardlavender.github.io/patter/reference/map_coord.html","id":null,"dir":"Reference","previous_headings":"","what":"Map: location coordinates (id, x, y, mark) — map_coord","title":"Map: location coordinates (id, x, y, mark) — map_coord","text":".map_coord() defines coordinates weights (marks) utilisation distribution (UD) estimation.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_coord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map: location coordinates (id, x, y, mark) — map_coord","text":"","code":".map_coord(.map, .coord, .discretise)  .map_coord.SpatRaster(.map)  .map_coord.dt(.map, .coord, .discretise)"},{"path":"https://edwardlavender.github.io/patter/reference/map_coord.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map: location coordinates (id, x, y, mark) — map_coord","text":".map terra::SpatRaster used represent UD. can NULL .coord provided .discretise = FALSE. .coord matrix, data.frame data.table::data.table x y coordinates, columns named x y cell_x cell_y (see Details). (.coord coerced data.table::data.table.) Additional columns (timestep mark), supported .map_mark() permitted. columns ignored. .discretise logical variable defines whether discretise coordinates (.e., redefine coordinates .map). necessarily TRUE wrapper function map_pou() optional map_dens().","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_coord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map: location coordinates (id, x, y, mark) — map_coord","text":"function returns data.table::data.table four columns: id—vector coordinate IDs (.discretise = TRUE, id represents grid cells .map); x,y—numeric vectors define coordinates (.discretise = TRUE, x y represent cell coordinates .map); mark—numeric vector weights, normalised sum one;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_coord.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map: location coordinates (id, x, y, mark) — map_coord","text":".map_coord() function defines data.table::data.table includes coordinate IDs (id), coordinates (x y) associated weights (mark) UD estimation. function wraps .map_coord.SpatRaster() .map_coord.dt(). .coord NULL, .map_coord.SpatRaster() used. function extracts data.table::data.table coordinates .map (non NA regions) via terra::.data.frame(..., na.rm = TRUE). values .map taken weights must sum one. .coord supplied, .map_coord.dt() used. x y /cell_x cell_y columns expected. .discretise = TRUE, cell_x cell_y used preferentially. Irrespective whether x y cell_x cell_y specified, coordinates redefined .map coordinate IDs defined grid cell IDs .map. .discretise = FALSE, x y coordinates used preferentially. Coordinates remain unchanged IDs defined set unique coordinate pairs. ID, weights calculated .map_mark().","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/map_coord.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Map: location coordinates (id, x, y, mark) — map_coord","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_dens.html","id":null,"dir":"Reference","previous_headings":"","what":"Map: point density — as.im.SpatRaster","title":"Map: point density — as.im.SpatRaster","text":"map_dens() creates smoothed utilisation distribution (UD).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_dens.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map: point density — as.im.SpatRaster","text":"","code":"as.im.SpatRaster(.map)  as.owin.SpatRaster(.map, .im = NULL)  as.owin.sf(.poly, .bbox = sf::st_bbox(.poly), .invert = TRUE)  bw.h(X)  map_dens(   .map,   .owin = as.owin.SpatRaster(.map),   .coord = NULL,   .discretise = FALSE,   .shortcut = list(),   .sigma = bw.h,   ...,   .fterra = FALSE,   .plot = TRUE,   .tryCatch = TRUE,   .verbose = getOption(\"patter.verbose\") )"},{"path":"https://edwardlavender.github.io/patter/reference/map_dens.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map: point density — as.im.SpatRaster","text":".map terra::SpatRaster defines grid UD represented. .coord = NULL, .map also defines points (associated weights) smoothed (see .map_coord()). coordinate reference system .map must planar specified. .im, .owin pixel image representation .map (see .im.SpatRaster() spatstat.geom::im()) observation window (see .owin.SpatRaster(), .owin.sf() spatstat.geom::owin()). un-supplied, .owin defined automatically .map via .owin.SpatRaster(), uses .im.SpatRaster() internally (see Details). faster results, use rectangular polygon observation window (see .owin.sf()). .poly, .bbox, .invert .owin.sf() construct observation windows sf objects. .poly sf polygon object; .bbox bounding simple feature (see sf::st_bbox()); .invert logical variable defines whether invert .poly (e.g., turn terrestrial polygon aquatic polygon); .coord (optional) Coordinates density estimation, provided format accepted .map_coord(). Coordinates must planar. .discretise .coord provided, .discretise logical variable defines whether discretise coordinates .map (see .map_coord()). .shortcut (optional) named list previous call map_dens(). supplied, function short-cuts straight smoothing (.owin, .coord .discretise silently unused). .sigma, X .sigma numeric value function specifies smoothing bandwidth (passed spatstat.explore::density.ppp()'s sigma argument). default option bw.h(), sets bandwidth based combined variance summarised coordinates, formatted point pattern X (see spatstat.geom::ppp), using ad-hoc method (Worton, 1989). See spatstat functions (e.g., spatstat.explore::bw.diggle()) sophisticated methods. ... Arguments density estimation, passed spatstat.explore::density.ppp(), sigma (.e., bandwidth). se permitted. .fterra logical variable defines whether parallelise terra::resample(). .plot logical variable defines whether plot output. .tryCatch logical variable controls error handling: .tryCatch = FALSE, density estimation fails error, function fails error. .tryCatch = TRUE, density estimation fails error, function produces warning error message returns NULL. .verbose User output control (see patter-progress supported options).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_dens.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map: point density — as.im.SpatRaster","text":"function returns named list, following elements: x: spatstat.geom::ppp object defines points density estimation; D: spatstat.geom::im object estimated intensities, spatstat.explore::density.ppp(); ud: normalised terra::SpatRaster; D ud NULL spatstat.explore::density.ppp() fails .tryCatch = TRUE.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_dens.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map: point density — as.im.SpatRaster","text":"map_dens() smooths () terra::SpatRaster (b) set inputted coordinates. .map_coord() (.map_mark()) used define coordinates weights: .coords NULL, .map cell coordinates used density estimation cell values used weights. coordinates supplied, coordinates optionally re-expressed .map used density estimation. option generally faster. Coordinate weights defined .map_mark(). Cell coordinates associated weights converted spatstat.geom::ppp() object, passed, alongside observation window (.owin), spatstat.explore::density.ppp() estimation. Weights must sum one. .im.SpatRaster(), .owin.SpatRaster() .owin.sf() helper functions convert terra::SpatRaster pixel image observation window (see spatstat.geom::owin()). .im.SpatRaster() based maptools::.im.RasterLayer(). .owin.SpatRaster() either defines rectangular window, NAs .map, converts .map directly owin object. Gridded observation windows, especially high resolution, considerably slow density estimation may exhaust vector memory. Use rectangular windows, convert sf objects polygon windows (via .owin.sf()) possible. .shortcut supplied, preceding steps can skipped function short-cuts straight smoothing. Use option preceding steps slow want trial different smoothing options (sigma functions). Coordinates associated weights smoothed via spatstat.explore::density.ppp() image. Pixel resolution smoothing parameters bandwidth can controlled via ... arguments passed directly function. default bandwidth set via bw.h() (see .sigma). output translated gridded probability density surface (geometry defined .map). process may use terra::resample(), can parallelised via .fterra (controls threads argument function). function replaces flapper::kud*() flapper::pf_kud*() routines based adehabitatHR (see ). Linux, functions used within Julia session.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_dens.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Map: point density — as.im.SpatRaster","text":"Worton, B. J. (1989). Kernel Methods Estimating Utilization Distribution Home-Range Studies. Ecology 70, 164–168. doi: 10.2307/1938423","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/map_dens.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map: point density — as.im.SpatRaster","text":"","code":"if (patter_run(.julia = FALSE, .geospatial = TRUE)) {    library(data.table)   library(dtplyr)   library(dplyr, warn.conflicts = FALSE)   library(spatstat.explore)    #### Define map   map <- dat_gebco()    #### Example (1): Use sample coordinates   # Sample example coordinates   coord <-     map |>     terra::spatSample(size = 100L, xy = TRUE, cell = TRUE, na.rm = TRUE) |>     select(\"x\", \"y\") |>     as.data.table()   # Use x, y coordinates   map_dens(map, .coord = coord)   # Other formats are acceptable   map_dens(map, .coord = as.matrix(coord))   map_dens(map, .coord = as.data.frame(coord))   # `cell_x` and `cell_y` coordinates are acceptable   map_dens(map, .coord = coord[, .(cell_x = x, cell_y = y)])   # A SpatRaster is also acceptable   pou <- map_pou(map, .coord = coord, .plot = FALSE)$ud   map_dens(pou)    #### Example (2): Use coordinates from `sim_path_walk()`   coord <- dat_path()   map_dens(map, .coord = coord)   points(coord$x, coord$y, cex = 0.5)    #### Example (3): Use coordinates from `coa()`   # Use example dataset   coord <- dat_coa()   map_dens(map, .coord = coord)   points(coord$x, coord$y, cex = 0.5)    #### Example (4): Use a time series of coordinates from `pf_*()`   # Use example dataset   # * We use particles from the forward filter (`?pf_filter()`);   # * Particles are equally weighted b/c re-sampling is implemented every time step;   # * It is better to use outputs from the particle smoother;   coord <- dat_pff()$states   map_dens(map, .coord = coord)   # points(coord$x, coord$y, cex = 0.5)    #### Example (5): Control smoothing via `spatstat.explore::density.ppp()`   # E.g. use fixed bandwidth:   map_dens(map, .coord = coord, .sigma = 5)   map_dens(map, .coord = coord, .sigma = 100)   # E.g., perform automatic bandwidth selection using cross validation:   if (FALSE) {     # These examples are slow     map_dens(map, .coord = coord, .sigma = bw.diggle) # 2 s     map_dens(map, .coord = coord, .sigma = bw.scott)  # 1 s     map_dens(map, .coord = coord, .sigma = bw.ppl)    # 65 s     map_dens(map, .coord = coord, .sigma = bw.CvL)    # 25 s   } } #> Loading required package: spatstat.data #> Loading required package: spatstat.univar #> spatstat.univar 3.1-2 #> Loading required package: spatstat.geom #> spatstat.geom 3.3-6 #>  #> Attaching package: ‘spatstat.geom’ #> The following object is masked from ‘package:data.table’: #>  #>     shift #> Loading required package: spatstat.random #> spatstat.random 3.3-3 #> Loading required package: nlme #>  #> Attaching package: ‘nlme’ #> The following object is masked from ‘package:dplyr’: #>  #>     collapse #> spatstat.explore 3.4-2 #> `patter::map_dens()` called @ 2025-04-21 20:40:00...  #> ... 20:40:00: Processing `.map`...  #> ... 20:40:00: Building XYM...  #> ... 20:40:00: Defining `ppp` object...  #> Observation window is gridded. #> ... 20:40:00: Estimating density surface...  #> ... 20:40:00: Scaling density surface...   #> `patter::map_dens()` call ended @ 2025-04-21 20:40:00 (duration: ~0 sec(s)).  #> `patter::map_dens()` called @ 2025-04-21 20:40:00...  #> ... 20:40:00: Processing `.map`...  #> ... 20:40:00: Building XYM...  #> ... 20:40:00: Defining `ppp` object...  #> Observation window is gridded. #> ... 20:40:00: Estimating density surface...  #> ... 20:40:00: Scaling density surface...  #> `patter::map_dens()` call ended @ 2025-04-21 20:40:00 (duration: ~0 sec(s)).  #> `patter::map_dens()` called @ 2025-04-21 20:40:00...  #> ... 20:40:00: Processing `.map`...  #> ... 20:40:00: Building XYM...  #> ... 20:40:00: Defining `ppp` object...  #> Observation window is gridded. #> ... 20:40:00: Estimating density surface...  #> ... 20:40:00: Scaling density surface...  #> `patter::map_dens()` call ended @ 2025-04-21 20:40:00 (duration: ~0 sec(s)).  #> `patter::map_dens()` called @ 2025-04-21 20:40:00...  #> ... 20:40:00: Processing `.map`...  #> ... 20:40:00: Building XYM...  #> ... 20:40:00: Defining `ppp` object...  #> Observation window is gridded. #> ... 20:40:00: Estimating density surface...  #> ... 20:40:00: Scaling density surface...  #> `patter::map_dens()` call ended @ 2025-04-21 20:40:00 (duration: ~0 sec(s)).  #> `patter::map_pou()` called @ 2025-04-21 20:40:00...  #> ... Building XYM...  #> ... Building SpatRaster...  #> `patter::map_pou()` call ended @ 2025-04-21 20:40:00 (duration: ~0 sec(s)).  #> `patter::map_dens()` called @ 2025-04-21 20:40:00...  #> ... 20:40:00: Processing `.map`...  #> ... 20:40:00: Building XYM...  #> ... 20:40:00: Defining `ppp` object...  #> Observation window is gridded. #> ... 20:40:00: Estimating density surface...  #> ... 20:40:00: Scaling density surface...  #> `patter::map_dens()` call ended @ 2025-04-21 20:40:01 (duration: ~1 sec(s)).  #> `patter::map_dens()` called @ 2025-04-21 20:40:01...  #> ... 20:40:01: Processing `.map`...  #> ... 20:40:01: Building XYM...  #> ... 20:40:01: Defining `ppp` object...  #> Observation window is gridded. #> ... 20:40:01: Estimating density surface...  #> ... 20:40:01: Scaling density surface...   #> `patter::map_dens()` call ended @ 2025-04-21 20:40:01 (duration: ~0 sec(s)).  #> `patter::map_dens()` called @ 2025-04-21 20:40:01...  #> ... 20:40:01: Processing `.map`...  #> ... 20:40:01: Building XYM...  #> ... 20:40:01: Defining `ppp` object...  #> Observation window is gridded. #> ... 20:40:01: Estimating density surface...  #> ... 20:40:01: Scaling density surface...   #> `patter::map_dens()` call ended @ 2025-04-21 20:40:01 (duration: ~0 sec(s)).  #> `patter::map_dens()` called @ 2025-04-21 20:40:01...  #> ... 20:40:01: Processing `.map`...  #> ... 20:40:01: Building XYM...  #> ... 20:40:01: Defining `ppp` object...  #> Observation window is gridded. #> ... 20:40:01: Estimating density surface...  #> ... 20:40:01: Scaling density surface...   #> `patter::map_dens()` call ended @ 2025-04-21 20:40:01 (duration: ~0 sec(s)).  #> `patter::map_dens()` called @ 2025-04-21 20:40:01...  #> ... 20:40:01: Processing `.map`...  #> ... 20:40:01: Building XYM...  #> ... 20:40:01: Defining `ppp` object...  #> Observation window is gridded. #> ... 20:40:01: Estimating density surface...  #> ... 20:40:02: Scaling density surface...   #> `patter::map_dens()` call ended @ 2025-04-21 20:40:02 (duration: ~1 sec(s)).  #> `patter::map_dens()` called @ 2025-04-21 20:40:02...  #> ... 20:40:02: Processing `.map`...  #> ... 20:40:02: Building XYM...  #> ... 20:40:02: Defining `ppp` object...  #> Observation window is gridded. #> ... 20:40:02: Estimating density surface...  #> ... 20:40:02: Scaling density surface...   #> `patter::map_dens()` call ended @ 2025-04-21 20:40:02 (duration: ~0 sec(s))."},{"path":"https://edwardlavender.github.io/patter/reference/map_hr.html","id":null,"dir":"Reference","previous_headings":"","what":"Map: animal home ranges — map_hr","title":"Map: animal home ranges — map_hr","text":"functions extract 'home range' estimates terra::SpatRaster describes intensity movements within area.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_hr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map: animal home ranges — map_hr","text":"","code":"map_hr_prop(.map, .prop = 0.5, .add = FALSE, ...)  map_hr_core(.map, .add = FALSE, ...)  map_hr_home(.map, .add = FALSE, ...)  map_hr_full(.map, .add = FALSE, ...)"},{"path":"https://edwardlavender.github.io/patter/reference/map_hr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map: animal home ranges — map_hr","text":".map terra::SpatRaster (utilisation distribution). .prop map_hr_prop(), .prop number defines range proportion. .add logical variable defines whether add polygon range existing map. ... .add = TRUE, ... place holder additional arguments passed terra::plot().","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_hr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map: animal home ranges — map_hr","text":"functions return terra::SpatRaster. Cells value one inside specified range boundaries; cells value zero beyond range boundaries. .add TRUE, boundaries added existing plot.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_hr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map: animal home ranges — map_hr","text":"functions modelled flapper::map_hr_*() functions, full details provided. Linux, functions used within Julia session.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/map_hr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Map: animal home ranges — map_hr","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_hr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map: animal home ranges — map_hr","text":"","code":"if (patter_run(.julia = FALSE, .geospatial = TRUE)) {    #### Set up example   # Define hypothetical input SpatRaster (probability distribution)   r    <- terra::setValues(dat_gebco(), NA)   i    <- 24073   r[i] <- 1   r    <- terra::distance(r)   r    <- terra::mask(r, dat_gebco())   r    <- r / terra::global(r, \"sum\", na.rm = TRUE)[1, 1]   terra::plot(r)    # #### Examples   map <- map_hr_full(r, .add = TRUE, lwd = 5)   map <- map_hr_home(r, .add = TRUE, border = \"blue\")   map <- map_hr_core(r, .add = TRUE, border = \"orange\")   map <- map_hr_prop(r, .prop = 0.2, .add = TRUE, border = \"red\")  }"},{"path":"https://edwardlavender.github.io/patter/reference/map_pou.html","id":null,"dir":"Reference","previous_headings":"","what":"Map: probability-of-use — map_pou","title":"Map: probability-of-use — map_pou","text":"function builds 'probability--use' utilisation distribution.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_pou.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map: probability-of-use — map_pou","text":"","code":"map_pou(   .map,   .coord,   .plot = TRUE,   ...,   .verbose = getOption(\"patter.verbose\") )"},{"path":"https://edwardlavender.github.io/patter/reference/map_pou.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map: probability-of-use — map_pou","text":".map terra::SpatRaster defines grid probability--use estimation. .coord Coordinates, provided format accepted .map_coord() .plot, ... logical input defines whether plot terra::SpatRaster additional arguments passed terra::plot(). .verbose User output control (see patter-progress supported options).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_pou.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map: probability-of-use — map_pou","text":"function returns named list following elements: ud: normalised terra::SpatRaster;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_pou.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map: probability-of-use — map_pou","text":"Probability--use calculated via .map_coord() (.map_mark()). single dataset unweighted coordinates provided, probability--use simply proportion records grid cell. time series unweighted coordinates provided, probability--use effectively average proportion records grid cell. becomes weighted average coordinates weighted. Weights normalised sum one result can interpreted utilisation distribution cell values define probability--use. Maps sensitive grid resolution. function replaces flapper::pf_plot_map(). Linux, function used within Julia session.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/map_pou.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Map: probability-of-use — map_pou","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/map_pou.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map: probability-of-use — map_pou","text":"","code":"if (patter_run(.julia = FALSE, .geospatial = TRUE)) {    library(data.table)   library(dtplyr)   library(dplyr, warn.conflicts = FALSE)    #### Define map   map <- dat_gebco()    #### Example (1): Use sample coordinates   # Sample example coordinates   coord <-     map |>     terra::spatSample(size = 5000L, xy = TRUE, cell = TRUE, na.rm = TRUE) |>     select(\"x\", \"y\") |>     as.data.table()   # Use x, y coordinates   map_pou(map, .coord = coord)   # Other formats are acceptable   map_pou(map, .coord = as.matrix(coord))   map_pou(map, .coord = as.data.frame(coord))   # `cell_x` and `cell_y` coordinates are acceptable   map_pou(map, .coord = coord[, .(cell_x = x, cell_y = y)])    #### Example (2): Use coordinates from `coa()`   # Use example dataset   coord <- dat_coa()   map_pou(map, .coord = coord)   points(coord$x, coord$y, cex = 0.5)    #### Example (3): Use a time series of coordinates from `pf_*()`   # Use example dataset   # * We use particles from the forward filter (`?pf_filter()`);   # * Particles are equally weighted b/c re-sampling is implemented every time step;   # * It is better to use outputs from the particle smoother;   coord <- dat_pff()$states   map_pou(map, .coord = coord)   # points(coord$x, coord$y, cex = 0.5)  } #> `patter::map_pou()` called @ 2025-04-21 20:40:04...  #> ... Building XYM...  #> ... Building SpatRaster...   #> `patter::map_pou()` call ended @ 2025-04-21 20:40:04 (duration: ~0 sec(s)).  #> `patter::map_pou()` called @ 2025-04-21 20:40:04...  #> ... Building XYM...  #> ... Building SpatRaster...  #> `patter::map_pou()` call ended @ 2025-04-21 20:40:04 (duration: ~0 sec(s)).  #> `patter::map_pou()` called @ 2025-04-21 20:40:04...  #> ... Building XYM...  #> ... Building SpatRaster...  #> `patter::map_pou()` call ended @ 2025-04-21 20:40:04 (duration: ~0 sec(s)).  #> `patter::map_pou()` called @ 2025-04-21 20:40:04...  #> ... Building XYM...  #> ... Building SpatRaster...  #> `patter::map_pou()` call ended @ 2025-04-21 20:40:04 (duration: ~0 sec(s)).  #> `patter::map_pou()` called @ 2025-04-21 20:40:04...  #> ... Building XYM...  #> ... Building SpatRaster...   #> `patter::map_pou()` call ended @ 2025-04-21 20:40:04 (duration: ~0 sec(s)).  #> `patter::map_pou()` called @ 2025-04-21 20:40:04...  #> ... Building XYM...  #> ... Building SpatRaster...   #> `patter::map_pou()` call ended @ 2025-04-21 20:40:04 (duration: ~0 sec(s)).  #> $ud #> class       : SpatRaster  #> dimensions  : 264, 190, 1  (nrow, ncol, nlyr) #> resolution  : 100, 100  (x, y) #> extent      : 695492.1, 714492.1, 6246657, 6273057  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 29N (EPSG:32629)  #> source(s)   : memory #> varname     : dat_gebco  #> name        :   map_value  #> min value   : 0.000000000  #> max value   : 0.003333333  #>"},{"path":"https://edwardlavender.github.io/patter/reference/name_particles.html","id":null,"dir":"Reference","previous_headings":"","what":"Julia: naming functions — name_particles","title":"Julia: naming functions — name_particles","text":"set internal naming functions.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/name_particles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Julia: naming functions — name_particles","text":"","code":"name_particles(   .fun = c(\"pf_filter\", \"pf_smoother_two_filter\"),   .direction = c(\"forward\", \"backward\") )"},{"path":"https://edwardlavender.github.io/patter/reference/name_particles.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Julia: naming functions — name_particles","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pat_setup_data.html","id":null,"dir":"Reference","previous_headings":"","what":"patter set up: datasets — pat_setup_data","title":"patter set up: datasets — pat_setup_data","text":"function used set validate telemetry data patter functions. Use acoustic /archival data.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pat_setup_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"patter set up: datasets — pat_setup_data","text":"","code":"pat_setup_data(   .map = NULL,   .detections = NULL,   .moorings = NULL,   .services = NULL,   .archival = NULL )"},{"path":"https://edwardlavender.github.io/patter/reference/pat_setup_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"patter set up: datasets — pat_setup_data","text":".map (optional) terra::SpatRaster defines study area (see glossary). .detections, .services, .archival, .moorings (optional) data.table::data.tables observations associated parameters. .detections contains detection time series (see dat_detections example); .moorings contains receiver deployments (see dat_moorings) example); .services contains receiver servicing information (times deployment period receiver active due servicing); .archival contains archival (depth) time series (see dat_archival example);","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pat_setup_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"patter set up: datasets — pat_setup_data","text":"function returns named list one element input argument.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pat_setup_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"patter set up: datasets — pat_setup_data","text":"preparation datasets patter one-inconvenience. able analyse kind electronic tagging tracking data using main patter functions (pf_filter()). passive acoustic telemetry data archival (depth) data, patter provides additional helper routines functionality (data assembly routines particle filter). acoustic /archival data, use pat_setup_data() verify datasets meet patter requirements exploit additional functionality. See check_dlist documentation required properties input dataset. requirements kept minimum straightforward address. minimise inconvenience, inputs optional pat_setup_data(). data types, see documentation assemble_*() functions incorporate particle filtering algorithms. Downstream functions may assume input data correctly formatted, streamlines API, documentation internal code. Linux, function used within Julia session.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pat_setup_data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"patter set up: datasets — pat_setup_data","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pat_setup_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"patter set up: datasets — pat_setup_data","text":"","code":"if (patter_run(.julia = FALSE, .geospatial = TRUE)) {    # Setup acoustic and archival data for use with `patter` functions   dlist <- pat_setup_data(.map = dat_gebco(),                           .detections = dat_detections,                           .moorings = dat_moorings,                           .services = NULL,                           .archival = dat_archival)    # `pat_setup_data()` returns a `list` with the updated datasets   summary(dlist)    # Extract updated datasets for use in downstream functions   map <- dlist$map   detections <- dlist$detections   moorings   <- dlist$archival   services   <- dlist$services   archival   <- dlist$archival  } #> `.map`: this is a reminder that a planar coordinate reference system (coordinate units: metres) is (currently) required. You can safely ignore this message if this is the case! #> `.map`: there is a speed penalty for grids that do not exist in memory in some functions. #> `.detections`: multiple individuals detected in dataset. #> `.detections`: time stamps should be ordered chronologically. #> `.archival`: multiple individuals detected in dataset. #> `.archival`: time stamps should be ordered chronologically."},{"path":"https://edwardlavender.github.io/patter/reference/patter-deprecated.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated functions — patter-deprecated","title":"Deprecated functions — patter-deprecated","text":"functions deprecated patter.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter-deprecated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated functions — patter-deprecated","text":"","code":"pf_plot_xy(...)"},{"path":"https://edwardlavender.github.io/patter/reference/patter-deprecated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deprecated functions — patter-deprecated","text":"... Function arguments.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter-deprecated.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deprecated functions — patter-deprecated","text":"pf_plot_xy() renamed plot_xyt();","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter-progress.html","id":null,"dir":"Reference","previous_headings":"","what":"patter options: progress — patter-progress","title":"patter options: progress — patter-progress","text":"patter functions enable progress monitoring via function arguments global options. time writing, three main tools monitor enhance function progress: User output messages (via patter.verbose option .verbose argument); Progress bars (via pbapply::pboptions() R, ProgressMeter.Progress Julia, julia_progress(), patter.progress option .progress argument); Parallelisation (via .cl_ .fterra arguments R JULIA_NUM_THREADS Julia); selected patter functions support options may expand future, depending user feedback.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter-progress.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"patter options: progress — patter-progress","text":"","code":"julia_progress(   enabled = getOption(\"patter.progress\"),   dt = 0.1,   showspeed = FALSE )"},{"path":"https://edwardlavender.github.io/patter/reference/patter-progress.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"patter options: progress — patter-progress","text":"enabled, dt, showspeed Arguments julia_progress(), passed ProgressMeter.Progress Julia: enabled logical variable defines whether display progress bar. default, enabled set patter.progress option. dt double defines duration (s) progress bar updates (updates generated intervals least dt seconds apart). showspeed logical variable defines whether append per-iteration average duration, (e.g., 12.34 ms/) progress bar.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter-progress.html","id":"user-outputs","dir":"Reference","previous_headings":"","what":"User outputs","title":"patter options: progress — patter-progress","text":"User output messages controlled via .verbose argument. global option patter.verbose can set suppress user output messages. See internal cat_ documentation permitted inputs .verbose.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter-progress.html","id":"progress-bars","dir":"Reference","previous_headings":"","what":"Progress bars","title":"patter options: progress — patter-progress","text":"pure R functions, progress bars implemented via pbapply package controlled globally via pbapply::pboptions(). See internal pb_ function documentation examples. R functions Julia backend, progress bars implemented via Julia. Set progress options via julia_progress. global option function inherits (patter.progress) can used suppress progress bars. set TRUE package .onLoad unless pbapply::pboptions()$type == \"none\". Note Julia progress bars limited Windows MacOS/Linux. may also speed penalty Windows. Please report experience.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter-progress.html","id":"parallelisation","dir":"Reference","previous_headings":"","what":"Parallelisation","title":"patter options: progress — patter-progress","text":"pure R functions, parallelisation implemented via .cl_ arguments passed cl_lapply(), wraps pbapply::pblapply(). See cl_lapply() function documentation full details. R functions use terra::terra-package, 'fast-terra' .fterra = TRUE argument instructs terra::terra-package use parallelisation. R functions Julia backend, parallelisation implemented via JULIA_NUM_THREADS argument julia_connect(). can set per R session.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter-progress.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"patter options: progress — patter-progress","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter.html","id":null,"dir":"Reference","previous_headings":"","what":"patter: particle algorithms for animal movement — patter","title":"patter: particle algorithms for animal movement — patter","text":"patter provides particle filtering, smoothing sampling algorithms animal movement modelling, focus passive acoustic telemetry systems. wraps enhances fast Julia backend (Patter.jl). methodology enables reconstruction movement paths patterns space use. patter unifies suite methods formerly known flapper algorithms  supersedes experimental flapper package (Lavender et al., 2023).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter.html","id":"vignettes","dir":"Reference","previous_headings":"","what":"Vignettes","title":"patter: particle algorithms for animal movement — patter","text":"introduction patter, use: vignette(\"-methodology\", package = \"patter\") conceptual introduction methodology; vignette(\"b-workflow-outline\", package = \"patter\") overview workflow; full list functions, see help(package = 'patter'). glossary key arguments, see glossary.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter.html","id":"datasets","dir":"Reference","previous_headings":"","what":"Datasets","title":"patter: particle algorithms for animal movement — patter","text":"example datasets Movement Ecology Flapper Skate project (datasets-mefs), inspired patter, see: dat_moorings acoustic receiver deployments; dat_detections acoustic detection time series; dat_archival archival (depth) time series; dat_gebco() bathymetry grid; dat_coast() coastline vector; dat_mpa() Marine Protected Area boundary validate new datasets use patter, see pat_setup_data() /assemble_*() function documentation. example algorithm outputs (datasets-algorithms), see: dat_path() example output sim_path_walk(); dat_coa() example output coa(); dat_pff() dat_pfb() example output pf_filter(); dat_tff() example output pf_smoother_two_filter();","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter.html","id":"set-up-julia","dir":"Reference","previous_headings":"","what":"Set up Julia","title":"patter: particle algorithms for animal movement — patter","text":"link patter Patter.jl Julia backend, use: julia_connect() connect R Julia; julia_validate() validate R—Julia connection; set_seed() set seed R Julia; set_map() make terra::SpatRaster study area available Julia; functions run start every R session.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter.html","id":"abstract-types","dir":"Reference","previous_headings":"","what":"Abstract Types","title":"patter: particle algorithms for animal movement — patter","text":"patter based three Abstract Types, defined Julia: State structures hold state (location) animal given time step; ModelMove structures hold movement model, used simulate new states; ModelObs structures hold observation model parameters, used evaluate correspondence simulated states observations;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter.html","id":"simulation","dir":"Reference","previous_headings":"","what":"Simulation","title":"patter: particle algorithms for animal movement — patter","text":"simulate animal movement time series, see: sim_path_walk() simulate movement path walk model (via ModelMove); sim_array() simulate acoustic array; sim_observations() simulate observational time series (via ModelObs); evaluate model skill reconstructing simulated patterns, see skill_*() functions: skill_mb() calculate mean bias; skill_me() calculate mean error; skill_rmse() calculate root mean squared error; skill_R() calculate Spearman's rank correlation coefficient; skill_d() calculate index agreement;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter.html","id":"data-exploration","dir":"Reference","previous_headings":"","what":"Data exploration","title":"patter: particle algorithms for animal movement — patter","text":"help data acquisition, processing, checking preliminary analyses, see flapper package. facilitates: Data preparation; Spatial operations; Distance calculations; Movement analyses; Please submit feature request like functions flapper patter.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter.html","id":"algorithms","dir":"Reference","previous_headings":"","what":"Algorithms","title":"patter: particle algorithms for animal movement — patter","text":"main thrust patter provision fast, integrated modelling workflow based particle filtering reconstructing animal movement paths emergent patterns space use observational time series (focus passive acoustic telemetry systems). assemble datasets particle filtering, use assemble_*() functions: assemble_timeline() assembles timeline; assemble_acoustics() assembles acoustic time series; assemble_acoustics_containers() assembles corresponding time series acoustic containers; assemble_archival() assembles archival time series; assemble_custom() assembles custom time series; Ancillary time series structured way inclusion particle filter. implement particle filtering (PF) routines, use: pf_filter() implement particle filter; pf_smoother_two_filter() implement two-filter smoother; functions return pf_particles objects. convenience plotting functions, see: plot_xyt() plot particle locations; mapping utilisation distributions, use: map_pou() map probability--use; map_dens() create smooth maps using spatstat, plus supporting functions: .im.SpatRaster(), convert SpatRasters pixel images; .owin.SpatRaster(), convert  SpatRasters observation windows; .owin.sf(), convert sf objects observation windows; map_hr_*() map home ranges, specifically: map_hr_prop() custom range; map_hr_core() 'core' range; map_hr_home() 'home' range; map_hr_full() full range;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter.html","id":"options","dir":"Reference","previous_headings":"","what":"Options","title":"patter: particle algorithms for animal movement — patter","text":"additional options patter, see: patter-progress monitor function progress;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter.html","id":"miscellaneous","dir":"Reference","previous_headings":"","what":"Miscellaneous","title":"patter: particle algorithms for animal movement — patter","text":"See cl_lapply() R parallelisation; See example_setup() functions used streamline examples; See file_*() functions (e.g., file_list()) system file helpers;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"patter: particle algorithms for animal movement — patter","text":"Lavender, E. et al. (2023). integrative modelling framework passive acoustic telemetry. Methods Ecology Evolution. https://doi.org/10.1111/2041-210X.14193.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/patter.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"patter: particle algorithms for animal movement — patter","text":"Edward Lavender (ORCID)","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter_run.html","id":null,"dir":"Reference","previous_headings":"","what":"Examples: run code — patter_run","title":"Examples: run code — patter_run","text":"functions switch code blocks /.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter_run.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Examples: run code — patter_run","text":"","code":"patter_run(.julia = TRUE, .geospatial = TRUE)  patter_run_expensive()"},{"path":"https://edwardlavender.github.io/patter/reference/patter_run.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Examples: run code — patter_run","text":".julia logical variable defines whether code requires connection Julia session. .geospatial logical variable defines whether R's geospatial packages (e.g., terra) required.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter_run.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Examples: run code — patter_run","text":"functions return logical value.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter_run.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Examples: run code — patter_run","text":"patter_run() main switch: .julia = TRUE, 'switch' : AUTO_JULIA_INSTALL != \"true\"; Linux platform geospatial packages currently use; Linux platform .geospatial = TRUE; Otherwise, switch : Linux platform, JULIA_SESSION = \"TRUE\" .geospatial = TRUE; (Linux, geospatial libraries used simultaneously R Julia.) patter_run_expensive() subsidiary switch particularly expensive routines: PATTER_RUN_EXPENSIVE = \"TRUE\", returns TRUE; Otherwise, FALSE returned;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter_run.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Examples: run code — patter_run","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/patter_run.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Examples: run code — patter_run","text":"","code":"if (patter_run(.julia = TRUE, .geospatial = TRUE)) {   # Connect to `Julia` session   julia_connect()   # Use a geospatial library in `R`   map <- dat_gebco()   terra::plot(map)   # Set the map in `Julia`   set_map(map) } #> `patter::julia_connect()` called @ 2025-04-21 20:40:05...  #> ... Running `Julia` setup via `JuliaCall::julia_setup()`...  #> ... Validating Julia installation...  #> ... Setting up Julia project...  #> ... Handling dependencies...  #> ... `Julia` set up with 11 thread(s).  #> `patter::julia_connect()` call ended @ 2025-04-21 20:40:05 (duration: ~0 sec(s))."},{"path":"https://edwardlavender.github.io/patter/reference/pb_.html","id":null,"dir":"Reference","previous_headings":"","what":"Progress bar wrappers — pb_","title":"Progress bar wrappers — pb_","text":"Progress bars patter implemented via pbapply package. can customised suppressed implementation patter functions use progress bars via pbapply::pboptions(). simple wrappers facilitate internal implementation progress bars via pbapply functions.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pb_.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Progress bar wrappers — pb_","text":"","code":"pb_init(.min, .max)  pb_tick(.pb, .t)  pb_close(.pb)"},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/pb_.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Progress bar wrappers — pb_","text":"","code":"if (FALSE) { # \\dontrun{ # Define loop loop <- function() {   n <- 10L   pb <- pb_init(.min = 0L, .max = n)   for (i in seq_len(n)) {     Sys.sleep(0.1)     pb_tick(pb, .t = i)   }   pb_close(pb) }  # Show default progress bar loop()  # Customise default progress bar pbo <- pbapply::pboptions(type = \"txt\") loop()  # Suppress progress bar pbo <- pbapply::pboptions(type = \"none\") loop()  # Reset options pbapply::pboptions(pbo) } # }"},{"path":"https://edwardlavender.github.io/patter/reference/pf_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"PF: particle filter — pf_filter","title":"PF: particle filter — pf_filter","text":"function runs particle filter. filter samples possible states (typically locations, termed particles) animal time point given data (including) time point movement model.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PF: particle filter — pf_filter","text":"","code":"pf_filter(   .timeline,   .state = \"StateXY\",   .xinit = NULL,   .model_move = model_move_xy(),   .yobs,   .n_move = 100000L,   .n_particle = 1000L,   .n_resample = as.numeric(.n_particle),   .t_resample = NULL,   .n_record = 1000L,   .n_iter = 1L,   .direction = c(\"forward\", \"backward\"),   .batch = NULL,   .collect = TRUE,   .progress = julia_progress(),   .verbose = getOption(\"patter.verbose\") )"},{"path":"https://edwardlavender.github.io/patter/reference/pf_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PF: particle filter — pf_filter","text":".timeline POSIXct vector regularly spaced time stamps defines timeline simulation. , .timeline used : Define time steps simulation; .state, .xinit Arguments used simulate initial states. .state—character defines State sub-type; .xinit—NULL data.table::data.table defines initial states simulation; .model_move, .n_move movement model. .model_move—character string defines movement model (see ModelMove); .n_move—integer defines number attempts find legal move; .yobs observations. Acceptable inputs : named list formatted datasets, one data type (see glossary); empty list, run filter without observations; missing, datasets already available Julia session (previous run pf_filter()) want re-run filter without penalty re-exporting observations; .n_particle integer defines number particles. .n_resample, .t_resample Resampling options. .n_resample double defines effective sample size (ESS) re-sample particles; .t_resample NULL integer/integer vector defines time steps resample particles, regardless ESS; Guidance: resample every time step, set .n_resample = .numeric(.n_particle) (default) .t_resample = 1:length(.timeline); resample selected time steps, set .t_resample required set .n_resample > .numeric(.n_particle); resample based ESS, set .t_resample = NULL .n_resample required; .n_record integer defines number recorded particles time step. .n_iter integer defines number iterations filter. .direction character string defines direction filter: \"forward\" runs filter .timeline[1]:.timeline[length(.timeline)]; \"backward\" runs filter .timeline[length(.timeline)]:.timeline[1]; .batch (optional) Batching controls: Use NULL retain particles whole .timeline (.n_record particles time step) memory; Use character vector .jld2 file paths write particles sequential batches file (Julia Matrix{<:State} objects); example: ./fwd-1.jld2, ./fwd-2.jld2, ... .direction = \"forward\"; ./bwd-1.jld2, ./bwd-2.jld2, ... .direction = \"backward; specified, .batch sorted alphanumerically (Julia) 'lower' batches (e.g., ./fwd-1.jld2, ./bwd-1.jld2) align start .timeline 'higher' batches (e.g., ./fwd-3.jld2, ./bwd-3.jld2) align end .timeline (irrespective .direction). smoothing, number batches must used filter runs (see pf_smoother_two_filter()). option designed reduce memory demand (especially clusters). Larger numbers batches reduce memory demand, incur speed penalty writing particles disk. handful batches, negligible. examples argument action, see pf_smoother_two_filter(). .collect logical variable defines whether collect outputs Julia session R. .progress Progress controls (see patter-progress supported options). enabled, one progress bar shown .batch. .verbose User output control (see patter-progress supported options).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PF: particle filter — pf_filter","text":"Patter.particle_filter() creates NamedTuple Julia session (named  pfwd pbwd depending .direction). .batch = NULL, NamedTuple contains particles (states) ; otherwise, states element nothing states written .jld2 files (variables named xfwd xbwd). .collect = TRUE, pf_filter() collects outputs R pf_particles object (states element NULL .batch used). Otherwise, invisible(NULL) returned.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_filter.html","id":"overview","dir":"Reference","previous_headings":"","what":"Overview","title":"PF: particle filter — pf_filter","text":"particle filter iterates time steps, simulating states (termed 'particles') consistent preceding data movement model time step. raster map study area must exported Julia function (see set_map()). initial states algorithm defined .xinit simulated via Patter.simulate_states_init(). word 'state' typically means location may include additional parameters. initial state animal known, supplied via .xinit. Otherwise, Patter.simulate_states_init() samples .n_particle initial coordinates .map (via Patter.coords_init()), translated DataFrame states (, .xinit, via Patter.states_init()). regions map initial coordinates sampled can restricted observations (.yobs) parameters. automated handling custom states observation models stage, custom Patter.map_init Patter.states_init methods required (see Details Patter.simulate_states_init()). filter comprises three stages: movement step, simulate possible states (particles) individual (time steps 2, ..., T). weights step, calculate particle weights log-likelihood data particle. re-sampling step, optionally re-sample valid states using weights. time complexity algorithm \\(O(TN)\\). filter implemented Julia function Patter.particle_filter(). multi-thread movement likelihood evaluations, set number threads via julia_connect(). filter record .n_record particles memory time step. batch provided, .timeline split length(.batch) batches. filter still moves along whole .timeline, records particles current batch memory. end batch, particles batch written file. reduces total memory demand. See Patter.particle_filter() JuliaCall::julia_help(\"particle_filter\") information.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_filter.html","id":"algorithms","dir":"Reference","previous_headings":"","what":"Algorithms","title":"PF: particle filter — pf_filter","text":"highly flexible routine reconstruction possible locations individual time, given data time point. modifying observation models, straightforward implement ACPF, DCPF ACDCPF algorithms introduced Lavender et al. (2023) reconstructing animal movements passive acoustic telemetry systems using () acoustic time series, (b) archival time series (c) acoustic archival time series. pf_filter() thus replaces (enhances) flapper::ac(), flapper::dc(), flapper::acdc() flapper::pf() functions.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/pf_filter.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"PF: particle filter — pf_filter","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PF: particle filter — pf_filter","text":"","code":"if (patter_run(.julia = TRUE, .geospatial = TRUE)) {    library(data.table)   library(dtplyr)   library(dplyr, warn.conflicts = FALSE)   library(glue)    #### Julia set up   julia_connect()   set_seed()    #### Define study period   # The resolution of the timeline defines the resolution of the simulation   timeline <- seq(as.POSIXct(\"2016-01-01\", tz = \"UTC\"),                   as.POSIXct(\"2016-01-01 03:18:00\", tz = \"UTC\"),                   by = \"2 mins\")    #### Define study area   # `map` is a SpatRaster that defines the region within which movements are permitted   # Here, we consider the movements of an aquatic animal in Scotland   # ... `map` represents the bathymetry in the relevant region   # Use `set_map()` to export the map to `Julia`   map <- dat_gebco()   terra::plot(map)   set_map(map)     #### --------------------------------------------------   #### Simulation-based workflow    #### Scenario   # We have studied the movements of flapper skate off the west coast of Scotland.   # We have collected acoustic detections at receivers and depth time series.   # Here, we simulate movements and acoustic/archival observations arising from movements.   # We then apply particle filtering to the 'observations' to reconstruct   # ... simulated movements.    #### Simulate an acoustic array   moorings <- sim_array(.map = map,                         .timeline = timeline,                         .n_receiver = 100L)    # `moorings` includes the following default observation model parameters   # * These describe how detection probability declines with distance from a receiver   # * These are the parameters of the `ModelObsAcousticLogisTrunc` observation model   a <- moorings$receiver_alpha[1]   b <- moorings$receiver_beta[1]   g <- moorings$receiver_gamma[1]   d <- seq(1, 1000, by = 1)   plot(d, ifelse(d <= g, plogis(a * b * d), 0),        ylab = \"Detection probability\",        xlab = \"Distance (m)\",        type = \"l\")    #### Simulate a movement path   # Define `State` sub-type   # > We will consider the animal's movement in two-dimensions (x, y)   state    <- \"StateXY\"   # Define the maximum moveable distance (m) between two time steps   mobility <- 750   # Define the movement model   # > We consider a two-dimensional random walk   model_move <-     model_move_xy(.mobility   = \"750.0\",             .dbn_length = \"truncated(Gamma(1, 250.0), upper = 750.0)\",             .dbn_heading  = \"Uniform(-pi, pi)\")   # Simulate a path   paths <- sim_path_walk(.map = map,                          .timeline = timeline,                          .state = state,                          .model_move = model_move)    #### Simulate observations   # Define observation model(s)   # * We simulate acoustic observations and depth time series   # * Acoustic observations are simulated according to `ModelObsAcousticLogisTrunc`   # * Depth observations are simulated according to `ModelObsDepthUniformSeabed`   # Define a `list` of parameters for the observation models   # (See `?ModelObs` for details)   pars_1 <-     moorings |>     select(sensor_id = \"receiver_id\", \"receiver_x\", \"receiver_y\",            \"receiver_alpha\", \"receiver_beta\", \"receiver_gamma\") |>     as.data.table()   pars_2 <- data.table(sensor_id = 1L,                        depth_shallow_eps = 10,                        depth_deep_eps = 10)   model_obs <- list(ModelObsAcousticLogisTrunc = pars_1,                     ModelObsDepthUniformSeabed = pars_2)   # Simulate observational datasets   obs <- sim_observations(.timeline = timeline,                           .model_obs = model_obs)   summary(obs)   head(obs$ModelObsAcousticLogisTrunc[[1]])   head(obs$ModelObsDepthUniformSeabed[[1]])   # Identify detections   detections <-     obs$ModelObsAcousticLogisTrunc[[1]] |>     filter(obs == 1L) |>     as.data.table()   # Collate datasets for filter   # > This requires a list of datasets, one for each data type   # > We could also include acoustic containers here for efficiency (see below)   yobs <- list(ModelObsAcousticLogisTrunc = obs$ModelObsAcousticLogisTrunc[[1]],                ModelObsDepthUniformSeabed = obs$ModelObsDepthUniformSeabed[[1]])    #### Example (1): Run the filter using the default options   fwd <- pf_filter(.timeline = timeline,                    .state = state,                    .xinit = NULL,                    .model_move = model_move,                    .yobs = yobs,                    .n_particle = 1e4L,                    .direction = \"forward\")    ## Output object structure:   # The function returns a `pf_particles` list:   class(fwd)   summary(fwd)   # `states` is a [`data.table::data.table`] of particles:   fwd$states   # `diagnostics` is a [`data.table::data.table`] of filter diagnostics   fwd$diagnostics   # fwd$callstats is a [`data.table::data.table`] of call statistics   fwd$callstats    ## Map output states:   # Map particle coordinates   plot_xyt(.map = map, .coord = fwd$states, .steps = 1L)   # Map a utilisation distribution   # * Use `.sigma = spatstat.explore::bw.diggle()` for CV bandwidth estimate   map_dens(.map = map,            .coord = fwd$states)    ## Analyse filter diagnostics   # `maxlp` is the maximum log-posterior at each time step   # > exp(fwd$diagnostics$maxlp) = the highest likelihood score at each time step (0-1)   # > This should not be too low!   plot(fwd$diagnostics$timestamp, fwd$diagnostics$maxlp, type = \"l\")   # `ess` is the effective sample size   # > For a 2D distribution,  >= 500 particles at each time step should be sufficient   # > But we often have a low ESS at the moment of a detection   # > If this is too low, we can trying boosting `.n_particle`   plot(fwd$diagnostics$timestamp, fwd$diagnostics$ess, type = \"l\")   points(detections$timestamp, rep(0, nrow(detections)),          pch = 21, col = \"red\", bg = \"red\", cex = 0.5)   abline(h = 500, col = \"royalblue\", lty = 3)    #### Example (2): Customise initial states for the filter   # Option (A): Mark the known starting location on `.map`   # > Initial states are automatically sampled from `.map`   # > We have to reset the initial map in Julia   # > Use set_map with .as_Raster = TRUE and .as_GeoArray = FALSE   # > (After the example, we reset the map for later examples)   origin       <- terra::setValues(map, NA)   cell         <- terra::cellFromXY(map, cbind(paths$x[1], paths$y[1]))   origin[cell] <- paths$map_value[1]   set_map(.x = origin, .as_Raster = TRUE, .as_GeoArray = FALSE)   fwd <- pf_filter(.timeline = timeline,                    .state = state,                    .xinit = NULL,                    .yobs = yobs,                    .model_move = model_move,                    .n_particle = 1e4L)   set_map(map, .as_Raster = TRUE, .as_GeoArray = FALSE)   # Option (B): Specify `.xinit` manually   # > `.xinit` is resampled, as required, to generate `.n_particle` initial states   xinit <- data.table(map_value = paths$map_value[1], x = paths$x[1], y = paths$y[1])   fwd   <- pf_filter(.timeline = timeline,                      .state = state,                      .xinit = xinit,                      .yobs = yobs,                      .model_move = model_move,                      .n_particle = 1e4L)    #### Example (3): Customise selected settings   # Boost the number of particles   fwd   <- pf_filter(.timeline = timeline,                      .state = state,                      .xinit = xinit,                      .yobs = yobs,                      .model_move = model_move,                      .n_particle = 1.5e4L)   # Change the threshold ESS for resampling   fwd   <- pf_filter(.timeline = timeline,                      .state = state,                      .xinit = xinit,                      .yobs = yobs,                      .model_move = model_move,                      .n_particle = 1.5e4L,                      .n_resample = 1000L)   # Force resampling at selected time steps   # * Other time steps are resampled if ESS < .n_resample   fwd   <- pf_filter(.timeline = timeline,                      .state = state,                      .xinit = xinit,                      .yobs = yobs,                      .model_move = model_move,                      .t_resample = which(timeline %in% detections$timestamp),                      .n_particle = 1.5e4L,                      .n_resample = 1000L)   # Change the number of particles retained in memory   fwd   <- pf_filter(.timeline = timeline,                      .state = state,                      .xinit = xinit,                      .yobs = yobs,                      .model_move = model_move,                      .n_particle = 1.5e4L,                      .n_record = 2000L)    #### Example (2): Run the filter backwards   # (A forward and backward run is required for the two-filter smoother)   fwd <- pf_filter(.timeline = timeline,                    .state = state,                    .xinit = NULL,                    .yobs = yobs,                    .model_move = model_move,                    .n_particle = 1e4L,                    .direction = \"backward\")     #### --------------------------------------------------   #### Real-world examples    #### Assemble datasets    # Define datasets for a selected animal   # > Here, we consider detections and depth time series from an example flapper skate   individual_id <- NULL   det <- dat_detections[individual_id == 25L, ][, individual_id := NULL]   arc <- dat_archival[individual_id == 25L, ][, individual_id := NULL]    # Define a timeline   # * We can do this manually or use the observations to define a timeline:   timeline <- assemble_timeline(list(det, arc), .step = \"2 mins\", .trim = TRUE)   timeline <- timeline[1:1440]   range(timeline)    # Assemble a timeline of acoustic observations (0, 1) and model parameters   # * The default acoustic observation model parameters are taken from `.moorings`   acoustics <- assemble_acoustics(.timeline = timeline,                                   .detections = det,                                   .moorings = dat_moorings)    # Assemble corresponding acoustic containers   # * This is recommended with acoustic observations   # * Note this dataset is direction specific (see below)   containers <- assemble_acoustics_containers(.timeline = timeline,                                               .acoustics = acoustics,                                               .mobility = mobility)    # Assemble a timeline of archival observations and model parameters   # * Here, we include model parameters for `ModelObsDepthNormalTruncSeabed`   archival <- assemble_archival(.timeline = timeline,                                 .archival =                                   arc |>                                   rename(obs = depth) |>                                   mutate(depth_sigma = 50,                                          depth_deep_eps = 20))    # Define the .yobs list for each run of the particle filter   yobs_fwd <- list(ModelObsAcousticLogisTrunc     = acoustics,                    ModelObsContainer              = containers$forward,                    ModelObsDepthNormalTruncSeabed = archival)   yobs_bwd <- list(ModelObsAcousticLogisTrunc     = acoustics,                    ModelObsContainer              = containers$backward,                    ModelObsDepthNormalTruncSeabed = archival)    #### Visualise realisations of the movement model (the prior)   # We will use the same movement model as in previous examples   sim_path_walk(.map = map,                 .timeline = timeline,                 .state = state,                 .model_move = model_move,                 .n_path = 10L, .one_page = TRUE)    #### Example (1): Run filter forwards   fwd <- pf_filter(.timeline = timeline,                    .state = state,                    .yobs = yobs_fwd,                    .model_move = model_move)    #### Example (2): Run the filter backwards   bwd <- pf_filter(.timeline = timeline,                    .state = state,                    .yobs = yobs_bwd,                    .model_move = model_move,                    .direction = \"backward\")     #### --------------------------------------------------   #### Joint inference of states and static parameters    if (patter_run_expensive()) {      # This example shows how we can infer both states and static parameters:     # * States are our latent locations;     # * Static parameters are the parameters in the movement and observation models;      # For illustration, we'll use simulated data:     # * We consider a passive acoustic telemetry system;     # * The movement model is a Gaussian random walk;     # * The standard deviation of the Gaussian distribution is the 'diffusivity';     # * The observation model is a Bernoulli model for acoustic detections/non-detections;      # Using simulated data, we'll pretend we don't know the movement 'diffusivity':     # * For simplicity, we'll assume we know the other parameters;     # * We'll attempt to estimate the true diffusivity from multiple runs;      # We show how to use the filter log-likelihood score to estimate parameters via:     # * grid-search;     # * maximum likelihood optimisation;     # * Bayesian inference;      # We recommend a simulation analysis like this before real-world analyses:     # * Follow the example below;     # * For your study system and species, simulate observations;     # * Examine whether you have sufficient information to estimate parameters;      # Beware that the log-likelihood value from the filter is 'noisy':     # * This can create all kinds of issues with optimisation & sampling;     # * You should check the sensitivity of the results with regard to the noise;     # * I.e., Re-run the routines a few times to check result consistency;      # Note also that parameter estimation can be computationally expensive:     # * We should select an appropriate inference procedure depending on filter cost;     # * Compromises may be required;     # * We may assume some static parameters are known;     # * We may estimate other parameters for one or two individuals with good data;     # * We may use best-guess parameters + sensitivity analysis;     # * This example just provides a minimal workflow;      #### Define study system     # Define study timeline     timeline <- seq(as.POSIXct(\"2016-01-01\", tz = \"UTC\"),                     as.POSIXct(\"2016-01-01 03:18:00\", tz = \"UTC\"),                     by = \"2 mins\")     # Define study area     map      <- dat_gebco()     set_map(map)      #### Simulate a movement path     # Define movement model     # * `theta` is the movement 'diffusivity'     # * We will attempt to estimate this parameter     state    <- \"StateXY\"     theta    <- 250.0     mobility <- 750     model_move <-       model_move_xy(.mobility    = mobility,                     .dbn_length  = glue(\"truncated(Normal(0, {theta}),                                          lower = 0.0, upper = {mobility})\"),                     .dbn_heading  = \"Uniform(-pi, pi)\")     # Simulate a path     path <- sim_path_walk(.map        = map,                           .timeline   = timeline,                           .state      = state,                           .model_move = model_move)      #### Simulate observations     # Simulate array (using default parameters)     # * Note we simulate a dense, regular array here     # * With real-world array designs, there may be less information available     moorings <- sim_array(.map         = map,                           .timeline    = timeline,                           .arrangement = \"regular\",                           .n_receiver  = 100L)     # Collate observation model parameters     model_obs <- model_obs_acoustic_logis_trunc(moorings)     # Simulate observations arising from path     obs <- sim_observations(.timeline  = timeline,                             .model_obs = model_obs)     acoustics <- obs$ModelObsAcousticLogisTrunc[[1]]     # (optional) Compute containers     containers <- assemble_acoustics_containers(.timeline  = timeline,                                                 .acoustics = acoustics,                                                 .mobility  = mobility,                                                 .map       = map)     # Collate observations for forward filter     yobs_fwd <-       list(ModelObsAcousticLogisTrunc = obs$ModelObsAcousticLogisTrunc[[1]],            ModelObsContainer = containers$forward)      #### Prepare to estimate the diffusivity using the observations      # i) Visualise movement models with different standard deviations     # > This gives us a feel for how we should constrain the estimation process     # > (if we didn't know the true parameter values)     pp  <- par(mfrow = c(3, 3))     thetas <- seq(100, 500, by = 50)     cl_lapply(thetas, function(theta) {       plot(model_move_xy(.mobility   = mobility,                          .dbn_length  = glue::glue(\"truncated(Normal(0, {theta}),                                                   lower = 0.0, upper = {mobility})\"),                          .dbn_heading = \"Uniform(-pi, pi)\"),            .panel_length = list(main = theta, font = 2),            .panel_heading = NULL,            .par = NULL)     })     par(pp)      # ii) Define a function that computes the log-likelihood given input parameters     # * `theta` denotes a parameter/parameter vector     # * (In this case, it is standard deviation in the movement model)     pf_filter_loglik <- function(theta) {        # (safety check) The movement standard deviation cannot be negative       if (theta < 0) {         return(-Inf)       }        # Instantiate movement model       model_move <-         model_move_xy(.mobility   = mobility,                       .dbn_length = glue::glue(\"truncated(Normal(0, {theta}),                                                 lower = 0.0, upper = {mobility})\"),                       .dbn_heading  = \"Uniform(-pi, pi)\")        # Run filter       # * Large .n_particle reduces noise in the likelihood (& filter speed)       fwd <- pf_filter(.timeline   = timeline,                        .state      = state,                        .xinit      = NULL,                        .model_move = model_move,                        .yobs       = yobs_fwd,                        .n_particle = 1e4L,                        .direction  = \"forward\",                        .progress   = julia_progress(enabled = TRUE),                        .verbose    = FALSE)        # Return log-lik       # (-Inf is returned for convergence failures)       fwd$callstats$loglik      }      #### (A) Use grid-search optimisation (~3 s)     # This is a good option for an initial parameter search     # (especially when there is only one parameter to optimise)     # i) Run a coarse grid search     theta_grid_loglik <- cl_lapply(thetas, pf_filter_loglik) |> unlist()     # ii) Check the noise around the optimum (~20 s)     noise <- lapply(1:5, function(i) {       loglik <- cl_lapply(thetas, pf_filter_loglik) |> unlist()       data.frame(iter = i, theta = thetas, loglik = loglik)     }) |> rbindlist()     # iii) Visualise log-likelihood profile     ylim <- range(c(theta_grid_loglik, noise$loglik))     plot(thetas, theta_grid_loglik, type = \"b\")     points(noise$theta, noise$loglik)      #### (B) Use optimisation routine e.g., optim or ADMB (~10 s)     # This may be a good option with multiple parameters     # We need to run the optimisation a few times to check result consistency     # Here, we only need 1-dimensional optimisation     # (So we use method = \"Brent\" & set the bounds on the optimisation)     theta_optim <- optim(par = 200, fn = pf_filter_loglik,                          method = \"Brent\", lower = 100, upper = 500,                          control = list(fnscale = -1))     theta_optim      #### (C) Use MCMC e.g., via adaptMCMC (~30 s)     # This is a good option for incorporating prior knowledge     # & characterising the uncertainty in theta      # i) Define log-posterior of parameters     pf_filter_posterior <- function(theta) {       # Log prior       # (For multiple thetas, simply take the product)       lp <- dunif(theta, 100, 500, log = TRUE)       if (!is.finite(lp)) {         return(-Inf)       } else {         # Posterior = prior * likelihood         lp <- lp + pf_filter_loglik(theta)       }       lp     }      # ii) Select variance of jump distribution     sd_of_jump <- 10     curve(dnorm(x, 0, sd_of_jump), -20, 20)      # iii) Run MCMC     # * For a real analysis, many more samples are recommended     theta_mcmc <- adaptMCMC::MCMC(pf_filter_posterior,                                   n = 100L,                                   init = 200, scale = sd_of_jump^2,                                   adapt = TRUE, acc.rate = 0.4)      # iv) Visualise samples (log-likelihoods, histogram, MCMC chain)     # > Note the noise in the log-likelihoods due to the stochastic nature of the filter     pp <- par(mfrow = c(1, 3))     o <- order(theta_mcmc$samples)     plot(theta_mcmc$samples[o], theta_mcmc$log.p[o], type = \"b\")     hist(theta_mcmc$samples)     plot(theta_mcmc$samples, type = \"l\")     par(pp)    }  } #> `patter::julia_connect()` called @ 2025-04-21 20:40:05...  #> ... Running `Julia` setup via `JuliaCall::julia_setup()`...  #> ... Validating Julia installation...  #> ... Setting up Julia project...  #> ... Handling dependencies...  #> ... `Julia` set up with 11 thread(s).  #> `patter::julia_connect()` call ended @ 2025-04-21 20:40:05 (duration: ~0 sec(s)).      #> `patter::pf_filter()` called @ 2025-04-21 20:40:06...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:40:06...  #> ... 20:40:06: Setting initial states...  #> ... 20:40:07: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:40:07 (duration: ~1 sec(s)).  #> ... 20:40:07: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #> ... 20:40:07: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:40:07 (duration: ~1 sec(s)).   #> `patter::map_dens()` called @ 2025-04-21 20:40:07...  #> ... 20:40:07: Processing `.map`...  #> ... 20:40:07: Building XYM...  #> ... 20:40:08: Defining `ppp` object...  #> Observation window is gridded. #> ... 20:40:08: Estimating density surface...  #> ... 20:40:08: Scaling density surface...   #> `patter::map_dens()` call ended @ 2025-04-21 20:40:08 (duration: ~1 sec(s)).    #> `patter::pf_filter()` called @ 2025-04-21 20:40:08...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:40:08...  #> ... 20:40:08: Setting initial states...  #> ... 20:40:08: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:40:08 (duration: ~0 sec(s)).  #> ... 20:40:08: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #> ... 20:40:08: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:40:08 (duration: ~0 sec(s)).  #> `patter::pf_filter()` called @ 2025-04-21 20:40:08...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:40:08...  #> ... 20:40:08: Setting initial states...  #> ... 20:40:08: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:40:08 (duration: ~0 sec(s)).  #> ... 20:40:08: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #> ... 20:40:09: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:40:09 (duration: ~1 sec(s)).  #> `patter::pf_filter()` called @ 2025-04-21 20:40:09...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:40:09...  #> ... 20:40:09: Setting initial states...  #> ... 20:40:09: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:40:09 (duration: ~0 sec(s)).  #> ... 20:40:09: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #> ... 20:40:09: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:40:09 (duration: ~0 sec(s)).  #> `patter::pf_filter()` called @ 2025-04-21 20:40:09...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:40:09...  #> ... 20:40:09: Setting initial states...  #> ... 20:40:09: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:40:09 (duration: ~0 sec(s)).  #> ... 20:40:09: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #> ... 20:40:09: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:40:09 (duration: ~0 sec(s)).  #> `patter::pf_filter()` called @ 2025-04-21 20:40:09...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:40:09...  #> ... 20:40:09: Setting initial states...  #> ... 20:40:09: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:40:09 (duration: ~0 sec(s)).  #> ... 20:40:09: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #> ... 20:40:10: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:40:10 (duration: ~1 sec(s)).  #> `patter::pf_filter()` called @ 2025-04-21 20:40:10...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:40:10...  #> ... 20:40:10: Setting initial states...  #> ... 20:40:10: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:40:10 (duration: ~0 sec(s)).  #> ... 20:40:10: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #> ... 20:40:10: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:40:11 (duration: ~1 sec(s)).  #> `patter::pf_filter()` called @ 2025-04-21 20:40:11...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:40:11...  #> ... 20:40:11: Setting initial states...  #> ... 20:40:11: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:40:11 (duration: ~0 sec(s)).  #> ... 20:40:11: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #> ... 20:40:11: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:40:11 (duration: ~0 sec(s)).   #> `patter::pf_filter()` called @ 2025-04-21 20:40:11...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:40:11...  #> ... 20:40:11: Setting initial states...  #> ... 20:40:12: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:40:12 (duration: ~1 sec(s)).  #> ... 20:40:12: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #> ... 20:40:12: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:40:13 (duration: ~2 sec(s)).  #> `patter::pf_filter()` called @ 2025-04-21 20:40:13...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:40:13...  #> ... 20:40:13: Setting initial states...  #> ... 20:40:13: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:40:13 (duration: ~0 sec(s)).  #> ... 20:40:13: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #> ... 20:40:13: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:40:13 (duration: ~0 sec(s)).       #>   generate 100 samples"},{"path":"https://edwardlavender.github.io/patter/reference/pf_filter_init.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialise the particle filter — pf_filter_init","title":"Initialise the particle filter — pf_filter_init","text":"internal function initialises particle filter: Initial states set via set_states_init(); Observations set via set_yobs_dict();","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_filter_init.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialise the particle filter — pf_filter_init","text":"","code":"pf_filter_init(   .timeline,   .state = \"StateXY\",   .xinit = NULL,   .model_move,   .yobs,   .n_particle,   .direction,   .collect = TRUE,   .verbose = getOption(\"patter.verbose\") )"},{"path":"https://edwardlavender.github.io/patter/reference/pf_filter_init.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Initialise the particle filter — pf_filter_init","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_particles-class.html","id":null,"dir":"Reference","previous_headings":"","what":"PF: pf_particles objects — pf_particles-class","title":"PF: pf_particles objects — pf_particles-class","text":"S3-class defines named list returned pf_filter() pf_smoother_two_filter().","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_particles-class.html","id":"structure","dir":"Reference","previous_headings":"","what":"Structure","title":"PF: pf_particles objects — pf_particles-class","text":"pf_particles label used denote outputs selected functions patter. structure class strictly defined primarily exists streamline documentation. time writing, pf_particles objects may comprise following elements: states—NULL data.table::data.table simulated states; diagnostics—data.table::data.table diagnostic statistics; callstats—data.table::data.table call statistics;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_particles-class.html","id":"states","dir":"Reference","previous_headings":"","what":"states","title":"PF: pf_particles objects — pf_particles-class","text":"Unless, .batch specified pf_filter() pf_smoother_two_filter(), states data.table::data.table defines simulated particle states, following columns: path_id—integer vector defines particle index; timestep—integer vector defines time step; timestamp—POSIXct vector time stamps; Additional columns values state dimension (e.g., map_value, x, y); Particles equally weighted, .n_record particles recorded time step selected resampling (see pf_filter()). .batch specified, states NULL.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_particles-class.html","id":"diagnostics","dir":"Reference","previous_headings":"","what":"diagnostics","title":"PF: pf_particles objects — pf_particles-class","text":"diagnostics data.table::data.table stores diagnostic statistics time step. includes timestep, timestamp following columns: ess—numeric vector defines effective sample size; maxlp—numeric vector defines maximum log posterior;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_particles-class.html","id":"callstats","dir":"Reference","previous_headings":"","what":"callstats","title":"PF: pf_particles objects — pf_particles-class","text":"callstats one-row data.table::data.table stores call statistics function call. includes following columns: timestamp—POSIXct value defines start time function call; routine—character vector defines routine: \"filter: forward\"; \"filter: backward\"; \"smoother: two-filter\"; n_particle—integer defines number particles; n_iter—integer defines number iterations (trials); error—character vector error message(s); loglik—double defines log likelihood observations given parameters: pf_filter(), loglik computed (convergence = FALSE, loglik = -Inf); pf_smoother_two_filter(), loglik NA_real_; convergence—logical variable defines whether algorithm converged pf_filter(), convergence TRUE filter reaches end time series; pf_smoother_two_filter(), convergence set TRUE proper smoothing possible least 95 % time steps; .e., 95 % diagnostics$ess values NaN (see Patter.particle_smoother_two_filter()); time—numeric value defines duration (s) function call;","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/pf_particles-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"PF: pf_particles objects — pf_particles-class","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_smoother_two_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"PF: two-filter smoother — pf_smoother_two_filter","title":"PF: two-filter smoother — pf_smoother_two_filter","text":"pf_smoother_two_filter() function implements two-filter particle smoother (Fearnhead et al., 2010).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_smoother_two_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PF: two-filter smoother — pf_smoother_two_filter","text":"","code":"set_vmap(.map = NULL, .mobility = NULL, .vmap = NULL, .plot = FALSE, ...)  pf_smoother_two_filter(   .n_particle = NULL,   .n_sim = 100L,   .cache = TRUE,   .batch = NULL,   .collect = TRUE,   .progress = julia_progress(),   .verbose = getOption(\"patter.verbose\") )"},{"path":"https://edwardlavender.github.io/patter/reference/pf_smoother_two_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PF: two-filter smoother — pf_smoother_two_filter","text":".map, .mobility, .vmap, .plot, ... (optional) 'Validity map' arguments set_map(), used two-dimensional states. .map terra::SpatRaster defines study area simulation (see pf_filter()). Linux, argument can used safely JULIA_SESSION = \"FALSE\". .mobility numeric value defines maximum moveable distance two time steps (e.g., .timeline[1] .timeline[2] pf_filter()). .vmap terra::SpatRaster (supported Windows MacOS), file path raster (supported MacOS, Windows Linux), defines validity map (see set_map()). can supplied, previous implementation set_vmap() internal function spatVmap(), instead .map .mobility avoid re-computation. .plot logical variable defines whether plot map. ... placeholder additional arguments, passed terra::plot(), .plot = TRUE. validity map set Julia JULIA_SESSION = \"TRUE\". Linux, validity map created set R session. Running function .map .mobility create, set, map. Write map file rerun function .vmap specified set map safely Julia. .n_particle (optional) integer defines number particles smooth. specified, sub-sample .n_particles used. Otherwise, .n_particle = NULL uses particles filter. .n_sim integer defines number Monte Carlo simulations. .cache logical variable defines whether pre-compute cache movement-density normalisation constants unique particle. .batch (optional) Batching controls: pf_filter() implemented .batch = NULL, leave .batch = NULL . Otherwise, .batch must specified. Pass character vector .jld2 file paths write particles sequential batches file (Julia Matrix{<:State} objects) .batch; example: ./smo-1.jld2, ./smo-2.jld2, .... must use number batches pf_filter(). .batch implemented function. .collect logical variable defines whether collect outputs Julia session R. .progress Progress controls (see patter-progress supported options). enabled, one progress bar shown .batch. .verbose User output control (see patter-progress supported options).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_smoother_two_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PF: two-filter smoother — pf_smoother_two_filter","text":"set_vmap(): set_vmap() returns validity map (terra::SpatRaster), invisibly; pf_smoother_two_filter(): Patter.particle_smoother_two_filter() creates NamedTuple Julia session (named ptf). .batch = NULL, NamedTuple contains particles (states) ; otherwise, states element nothing states written .jld2 files ( variable named xsmo). .collect = TRUE, pf_smoother_two_filter() collects outputs R pf_particles object (states element NULL .batch used). Otherwise, invisible(NULL) returned.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_smoother_two_filter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"PF: two-filter smoother — pf_smoother_two_filter","text":"two-filter smoother smooths particle samples particle filter (pf_filter()). Particles forward backward filter run required Julia workspace (defined pf_filter()). backend function Patter.particle_smoother_two_filter() work. Essentially, function runs simulation backwards time re-samples particles line probability density movements combination states backward filter time t states forward filter time t - 1. time complexity algorithm thus \\(O(TN^2)\\). probability density movements evaluated Patter.logpdf_step() Patter.logpdf_move(). individual states two-dimensional (see StateXY), validity map can pre-defined Julia via set_vmap() speed probability calculations. validity map defined set valid (non-NA bordering) locations .map, shrunk .mobility. Within region, probability density movement two states can calculated directly. Otherwise, Monte Carlo simulation, .n_sim iterations, required compute normalisation constant (accounting movements inhospitable areas, beyond boundaries study area). movement models density depends particle states, set .cache = TRUE pre-compute cache normalisation constants improved speed.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_smoother_two_filter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"PF: two-filter smoother — pf_smoother_two_filter","text":"Fearnhead, P. et al. (2010). sequential smoothing algorithm linear computational cost. Biometrika 97, 447–464. https://doi.org/10.1093/biomet/asq013.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/pf_smoother_two_filter.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"PF: two-filter smoother — pf_smoother_two_filter","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/pf_smoother_two_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PF: two-filter smoother — pf_smoother_two_filter","text":"","code":"if (patter_run()) {    library(JuliaCall)    #### Set up example   # Set up the particle filter with an example dataset   # (See `?pf_filter()` for the full workflow)   setup <- example_setup(\"pf_smoother_two_filter\")   map   <- setup$map   args  <- setup$pf_filter_args   # Run the particle filter forwards   args$.direction <- \"forward\"   fwd <- do.call(pf_filter, args)   # Run the particle filter backwards   args$.direction <- \"backward\"   bwd <- do.call(pf_filter, args)    #### Example (1): Implement the smoother with default options   # Run the smoother   # * This uses objects defined by `pf_filter()` in `Julia`   # (set_vmap() is explained below)   smo <- pf_smoother_two_filter()   # The filter returns a `pf_particles`-class object   # (See `?pf_filter()` for examples)   class(smo)   summary(smo)    #### Example (2): Implement the smoother using a validity map   # We can use a validity map b/c `.state` = \"StateXY\"   args$.state   # To define the validity map, define:   # * `.map`   # * `.mobility`, which we can see here is 750 m:   args$.model_move   # Run the smoother   set_vmap(.map = map, .mobility = 750.0, .plot = TRUE)   smo <- pf_smoother_two_filter()   # Reset `vmap` in `Julia` to run the smoother for other state types   # ... in the same R session:   set_vmap()    #### Example (3): Implement the smoother with a sub-sample of particles   # This is useful for quick tests   set_vmap(.map = map, .mobility = 750.0)   smo <- pf_smoother_two_filter(.n_particle = 50L)    #### Example (4): Adjust the number of MC simulations   # set_vmap(.map = map, .mobility = 750.0)   smo <- pf_smoother_two_filter(.n_sim = 1000L)    #### Example (5): Batching workflow for filtering and smoothing   # (Use `.batch` to reduce memory demand)    folder <- file.path(tempdir(), \"batch-outputs\")   dir.create(folder)    ## Run forward filter with batching   batch_fwd       <- file.path(folder, c(\"fwd-1.jld2\", \"fwd-2.jld2\", \"fwd-3.jld2\"))   args$.direction <- \"forward\"   args$.batch     <- batch_fwd   args$.collect   <- TRUE   fwd <- do.call(pf_filter, args)   # In the output, the 'states' element is null   fwd$states   # Other elements are as expected   fwd$callstats   head(fwd$diagnostics)   # Confirm that batch files exist   stopifnot(all(file.exists(batch_fwd)))    ## Run backward filter with batching:   batch_bwd       <- file.path(folder, c(\"bwd-1.jld2\", \"bwd-2.jld2\", \"bwd-3.jld2\"))   args$.direction <- \"backward\"   args$.batch     <- batch_bwd   bwd <- do.call(pf_filter, args)   summary(bwd)   stopifnot(all(file.exists(batch_bwd)))    ## Run smoothing with batching   # set_vmap(.map = map, .mobility = 750.0)   batch_smo <- file.path(folder, c(\"smo-1.jld2\", \"smo-2.jld2\", \"smo-3.jld2\"))   smo       <- pf_smoother_two_filter(.batch = batch_smo)   summary(smo)   stopifnot(all(file.exists(batch_smo)))    ## Collate outputs in R   julia_command('     smo_states = hcat([f[\"xsmo\"] for f in map(jldopen, batch_smo)]...);')   smo$states <- julia_eval('     Patter.r_get_states(smo_states, collect(1:length(timeline)), timeline);     ')   head(smo$states)    #### Example (6): Analyse smoothed particles   # * See `map_*()` functions (e.g., `?map_dens()`) to map utilisation distributions     # Cleanup   file_cleanup(folder)   set_vmap() } #> `patter::julia_connect()` called @ 2025-04-21 20:40:46...  #> ... Running `Julia` setup via `JuliaCall::julia_setup()`...  #> ... Validating Julia installation...  #> ... Setting up Julia project...  #> ... Handling dependencies...  #> ... `Julia` set up with 11 thread(s).  #> `patter::julia_connect()` call ended @ 2025-04-21 20:40:46 (duration: ~0 sec(s)).    #> `patter::pf_filter()` called @ 2025-04-21 20:40:46...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:40:46...  #> ... 20:40:46: Setting initial states...  #> ... 20:40:46: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:40:46 (duration: ~0 sec(s)).  #> ... 20:40:46: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #> ... 20:40:46: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:40:46 (duration: ~0 sec(s)).  #> `patter::pf_filter()` called @ 2025-04-21 20:40:46...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:40:46...  #> ... 20:40:46: Setting initial states...  #> ... 20:40:46: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:40:46 (duration: ~0 sec(s)).  #> ... 20:40:46: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 1 ... #>    #> ... 20:40:47: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:40:47 (duration: ~1 sec(s)).  #> `patter::pf_smoother_two_filter()` called @ 2025-04-21 20:40:47...  #> ... 20:40:47: Running smoother...  #> Message: Running smoother for batch 1 / 1 ... #>    #> Message: Precomputing normalisation constants for batch ... #>    #> Message: Smoothing ... #>    #> ... 20:40:47: Collating outputs...  #> `patter::pf_smoother_two_filter()` call ended @ 2025-04-21 20:40:47 (duration: ~0 sec(s)).   #> `patter::pf_smoother_two_filter()` called @ 2025-04-21 20:40:47...  #> ... 20:40:48: Running smoother...  #> Message: Running smoother for batch 1 / 1 ... #>    #> Message: Precomputing normalisation constants for batch ... #>    #> Message: Smoothing ... #>    #> ... 20:40:48: Collating outputs...  #> `patter::pf_smoother_two_filter()` call ended @ 2025-04-21 20:40:48 (duration: ~1 sec(s)).  #> `patter::pf_smoother_two_filter()` called @ 2025-04-21 20:40:48...  #> ... 20:40:48: Running smoother...  #> Message: Running smoother for batch 1 / 1 ... #>    #> Message: Precomputing normalisation constants for batch ... #>    #> Message: Smoothing ... #>    #> ... 20:40:48: Collating outputs...  #> `patter::pf_smoother_two_filter()` call ended @ 2025-04-21 20:40:48 (duration: ~0 sec(s)).  #> `patter::pf_smoother_two_filter()` called @ 2025-04-21 20:40:48...  #> ... 20:40:48: Running smoother...  #> Message: Running smoother for batch 1 / 1 ... #>    #> Message: Precomputing normalisation constants for batch ... #>    #> Message: Smoothing ... #>    #> ... 20:40:48: Collating outputs...  #> `patter::pf_smoother_two_filter()` call ended @ 2025-04-21 20:40:48 (duration: ~0 sec(s)).  #> `patter::pf_filter()` called @ 2025-04-21 20:40:48...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:40:48...  #> ... 20:40:48: Setting initial states...  #> ... 20:40:48: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:40:48 (duration: ~0 sec(s)).  #> ... 20:40:48: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 3 ... #>    #> Message: Writing particles to disk ... #>    #> Message: Running filter for batch 2 / 3 ... #>    #> Message: Writing particles to disk ... #>    #> Message: Running filter for batch 3 / 3 ... #>    #> Message: Writing particles to disk ... #>    #> ... 20:40:50: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:40:50 (duration: ~2 sec(s)).  #> `patter::pf_filter()` called @ 2025-04-21 20:40:50...  #> `patter::pf_filter_init()` called @ 2025-04-21 20:40:50...  #> ... 20:40:50: Setting initial states...  #> ... 20:40:50: Setting observations dictionary...  #> `patter::pf_filter_init()` call ended @ 2025-04-21 20:40:50 (duration: ~0 sec(s)).  #> ... 20:40:50: Running filter...  #> Message: On iteration 1 ... #>    #> Message: Running filter for batch 1 / 3 ... #>    #> Message: Writing particles to disk ... #>    #> Message: Running filter for batch 2 / 3 ... #>    #> Message: Writing particles to disk ... #>    #> Message: Running filter for batch 3 / 3 ... #>    #> Message: Writing particles to disk ... #>    #> ... 20:40:51: Collating outputs...  #> `patter::pf_filter()` call ended @ 2025-04-21 20:40:51 (duration: ~1 sec(s)).  #> `patter::pf_smoother_two_filter()` called @ 2025-04-21 20:40:51...  #> ... 20:40:51: Running smoother...  #> Message: Running smoother for batch 1 / 3 ... #>    #> Message: Reading particles from disk ... #>    #> Message: Precomputing normalisation constants for batch ... #>    #> Message: Smoothing ... #>    #> Message: Writing smoothed particles to disk ... #>    #> Message: Running smoother for batch 2 / 3 ... #>    #> Message: Reading particles from disk ... #>    #> Message: Precomputing normalisation constants for batch ... #>    #> Message: Smoothing ... #>    #> Message: Writing smoothed particles to disk ... #>    #> Message: Running smoother for batch 3 / 3 ... #>    #> Message: Reading particles from disk ... #>    #> Message: Precomputing normalisation constants for batch ... #>    #> Message: Smoothing ... #>    #> Message: Writing smoothed particles to disk ... #>    #> ... 20:40:51: Collating outputs...  #> `patter::pf_smoother_two_filter()` call ended @ 2025-04-21 20:40:51 (duration: ~0 sec(s))."},{"path":"https://edwardlavender.github.io/patter/reference/plot.ModelMove.html","id":null,"dir":"Reference","previous_headings":"","what":"Movement model plots — plot.ModelMove","title":"Movement model plots — plot.ModelMove","text":"plot() methods movement models (see ModelMove).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/plot.ModelMove.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Movement model plots — plot.ModelMove","text":"","code":"# S3 method for class 'ModelMoveXY' plot(x, .panel_length = list(), .panel_heading = list(), .par = list(), ...)  # S3 method for class 'ModelMoveXYZ' plot(   x,   .panel_length = list(),   .panel_heading = list(),   .panel_z = list(),   .par = list(),   ... )  # S3 method for class 'ModelMoveCXY' plot(   x,   .panel_length = list(),   .panel_heading_delta = list(),   .par = list(),   ... )  # S3 method for class 'ModelMoveCXYZ' plot(   x,   .panel_length = list(),   .panel_heading_delta = list(),   .panel_z_delta = list(),   .par = list(),   ... )"},{"path":"https://edwardlavender.github.io/patter/reference/plot.ModelMove.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Movement model plots — plot.ModelMove","text":"x ModelMove-class object model_move_*() function (e.g., model_move_xy(). .panel_length, .panel_heading, .panel_heading_delta, .panel_z, .panel_z_delta Panel properties: NULL suppresses panel; list() uses default graphical arguments; named list arguments, passed plot(), customises panel; .par Graphical parameters: NULL uses current graphical parameters; list() uses default graphical parameters; named list arguments, passed par(), customises parameters; ... Additional arguments, passed plot(), affect panels;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/plot.ModelMove.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Movement model plots — plot.ModelMove","text":"functions produce plot. invisible(NULL) returned.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/plot.ModelMove.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Movement model plots — plot.ModelMove","text":"-built ModelMove-class (e.g., ModelMoveXY), corresponding plot() method provided plots component probability-density distributions (e.g., distribution step lengths turning angles) model instance. default options, multi-panelled plot produced, one panel model dimension (e.g., step length heading). Use .panel_* arguments customise individual panels, .par set graphical parameters ... customise panels. Set .panel_* xlim specify x-axis range distributions shown. unspecified, probability density plotted along predefined range 0.0001 0.9999 quantiles distribution.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/plot.ModelMove.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Movement model plots — plot.ModelMove","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/plot.ModelMove.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Movement model plots — plot.ModelMove","text":"","code":"if (patter_run(.julia = TRUE, .geospatial = FALSE)) {    julia <- julia_connect()   map <- dat_gebco(.return = \"character\")   set_map(map)    #### Example (1): Plot movement models   # Plot default models   plot(model_move_xy())   plot(model_move_xyz())   plot(model_move_cxy())   plot(model_move_cxyz())   # Plot customised model   plot(model_move_cxyz(.dbn_length = \"truncated(Normal(0.0, 100.0),                                         lower = 0.0, upper = 1000.0)\"))    #### Example (2): Use `...` to pass graphical arguments to all panels   plot(model_move_xy(), col = \"red\")    #### Example (3): Use `.panel_* = NULL` to suppress selected panels   plot(model_move_xy(),        .panel_heading = NULL)    #### Example (4): Customise individual panels via `.panel_*` lists   plot(model_move_xy(),        .panel_length = list(main = \"A\"),        .panel_heading = list(main = \"B\"))    #### Example (5): Control graphical parameters via the `.par` list   # Use default options   plot(model_move_xy(), .par = list())   # Specify par options   plot(model_move_xy(), .par = list(oma = c(3, 3, 3, 3)))   # Set `.par = NULL` to leave `par` unchanged   pp <- par(mfrow = c(2, 1))   plot(model_move_xy(), .par = NULL)   par(pp)    #### Example (6): Simulate reasliations of the movement model   # See `?sim_path_walk()`   # Set `.map` argument to visualise trajectories   # (On Linux, this is only possible if JULIA_SESSION = \"FALSE\")   sim_path_walk(.timeline = seq(as.POSIXct(\"2016-01-01\", tz = \"UTC\"),                                 as.POSIXct(\"2016-01-01 12:00:00\", tz = \"UTC\"),                                 by = \"2 mins\"),                 .state = \"StateXY\",                 .model_move = model_move_xy())  } #> `patter::julia_connect()` called @ 2025-04-21 20:40:52...  #> ... Running `Julia` setup via `JuliaCall::julia_setup()`...  #> ... Validating Julia installation...  #> ... Setting up Julia project...  #> ... Handling dependencies...  #> ... `Julia` set up with 11 thread(s).  #> `patter::julia_connect()` call ended @ 2025-04-21 20:40:52 (duration: ~0 sec(s)).             #>      path_id timestep           timestamp map_value        x       y #>        <int>    <int>              <POSc>     <num>    <num>   <num> #>   1:       1        1 2016-01-01 00:00:00  89.09113 705642.1 6264507 #>   2:       1        2 2016-01-01 00:02:00 105.07728 705973.6 6264847 #>   3:       1        3 2016-01-01 00:04:00 105.07728 705977.2 6264825 #>   4:       1        4 2016-01-01 00:06:00 150.48004 706228.4 6265426 #>   5:       1        5 2016-01-01 00:08:00 132.10489 706243.0 6265074 #>  ---                                                                 #> 357:       1      357 2016-01-01 11:52:00  86.40712 710335.2 6266947 #> 358:       1      358 2016-01-01 11:54:00  97.41836 710385.0 6266960 #> 359:       1      359 2016-01-01 11:56:00 135.54185 710210.1 6267495 #> 360:       1      360 2016-01-01 11:58:00 117.44244 710399.4 6267577 #> 361:       1      361 2016-01-01 12:00:00 144.81311 710093.4 6267510"},{"path":"https://edwardlavender.github.io/patter/reference/plot.ModelObs.html","id":null,"dir":"Reference","previous_headings":"","what":"Observation model plots — plot.ModelObs","title":"Observation model plots — plot.ModelObs","text":"plot() methods observation models (see ModelObs).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/plot.ModelObs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Observation model plots — plot.ModelObs","text":"","code":"# S3 method for class 'ModelObsAcousticLogisTrunc' plot(x, .sensor_id, .par = list(), ...)  # S3 method for class 'ModelObsDepthUniformSeabed' plot(x, .seabed = 100, .par = list(), ...)  # S3 method for class 'ModelObsDepthNormalTruncSeabed' plot(x, .seabed = 100, .par = list(), ...)  # S3 method for class 'ModelObsContainer' plot(x, .radius, .par = list(), ...)"},{"path":"https://edwardlavender.github.io/patter/reference/plot.ModelObs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Observation model plots — plot.ModelObs","text":"x named list observation model parameters, including ModelObs S3 label (model_obs_*() function). .sensor_id, .radius, .seabed Model-specific parameters: .sensor_id: plot.ModelObsAcousticLogisTrunc(), .sensor_id controls sensors (receivers) detection probability curves shown: missing (default) plots unique curves; integer vector sensor IDs plots curves selected sensors; NULL plots curves sensors; .radius: plot.ModelObsContainer(), .radius controls radii distributions shown: missing (default) plots distributions first three unique radii; vector radii plots curves selected radii; NULL plots distributions radii; .seabed: plot.ModelObsDepth*Seabed(), .seabed seabed depth distributions plotted. .par Graphical parameters: NULL uses current graphical parameters; list() uses default graphical parameters; named list arguments, passed par(), customises parameters; ... Additional arguments, passed plot().","code":""},{"path":"https://edwardlavender.github.io/patter/reference/plot.ModelObs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Observation model plots — plot.ModelObs","text":"functions produce plot. invisible(NULL) returned.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/plot.ModelObs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Observation model plots — plot.ModelObs","text":"Observation model (ModelObs) structures objects define parameters observation model. model specifies probability observation (e.g., particular depth record) given data (e.g., depth measurement). plot.ModelObsAcousticLogisTrunc() plots detection probability function distance receiver; plot.ModelObsDepthUniformSeabed() plots uniform distribution probability depth observation around particular .seabed depth; plot.ModelObsDepthNormalTruncSeabed() plot truncated normal distribution probability depth observation around particularly .seabed depth; plot.ModelObsContainer() plots uniform distribution probability future observation (e.g., detection) given maximum possible distance (container radius) container centroid (e.g., receiver), maximum movement speed, current time;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/plot.ModelObs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Observation model plots — plot.ModelObs","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/plot.ModelObs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Observation model plots — plot.ModelObs","text":"","code":"if (patter_run(.julia = TRUE, .geospatial = FALSE)) {    library(data.table)    julia_connect()    #### Example (1): ModelObsAcousticLogisTrunc   # Plot unique detection-probability function(s)   dat_moorings |>     model_obs_acoustic_logis_trunc() |>     plot()   # Plot functions for selected sensors   dat_moorings |>     model_obs_acoustic_logis_trunc() |>     plot(.sensor_id = unique(dat_moorings$receiver_id)[1:10])    #### Example (2): ModelObsDepthUniformSeabed   data.table(sensor_id = 1L, depth_shallow_eps = 10, depth_deep_eps = 10) |>     model_obs_depth_uniform_seabed() |>     plot()   data.table(sensor_id = 1L, depth_shallow_eps = 10, depth_deep_eps = 10) |>     model_obs_depth_uniform_seabed() |>     plot(.seabed = 50)    #### Example (3): ModelObsDepthSeabedNormalTrunc   data.table(sensor_id = 1L, depth_sigma = 10, depth_deep_eps = 10) |>     model_obs_depth_normal_trunc_seabed() |>     plot()   data.table(sensor_id = 1L, depth_sigma = 100, depth_deep_eps = 50) |>     model_obs_depth_normal_trunc_seabed() |>     plot(.seabed = 150)    #### Example (4): ModelObsContainer   # Define detections (1)   detections <- dat_detections[individual_id == individual_id[1], ]   # Assemble acoustic observations (0, 1) for a given timeline   timeline   <- assemble_timeline(list(detections), .step = \"2 mins\")[1:100]   acoustics  <- assemble_acoustics(.timeline   = timeline,                                    .detections = detections,                                    .moorings   = dat_moorings)   # Assemble acoustic containers   containers <- assemble_acoustics_containers(.timeline = timeline,                                               .acoustics = acoustics,                                               .mobility = 750)   # Plot a few example distributions   containers$forward |>     model_obs_container() |>     plot()    #### Example (5): Customise plot layout via `.par`   dat_moorings |>     model_obs_acoustic_logis_trunc() |>     plot(.sensor_id = unique(dat_moorings$receiver_id)[1:4],          .par = list(mfrow = c(2, 2)))    #### Example (6): Customise plot properties via `...`   dat_moorings |>     model_obs_acoustic_logis_trunc() |>     plot(.sensor_id = unique(dat_moorings$receiver_id)[1:4],          .par = list(mfrow = c(2, 2),                      oma = c(3, 3, 3, 3),                      mar = c(1.5, 1.5, 1.5, 1.5)),          xlab = \"\", ylab = \"\", col = \"red\")   mtext(side = 1, \"Distance (m)\", line = -1, outer = TRUE)   mtext(side = 2, \"Probability\", line = -1, outer = TRUE)  } #> `patter::julia_connect()` called @ 2025-04-21 20:40:53...  #> ... Running `Julia` setup via `JuliaCall::julia_setup()`...  #> ... Validating Julia installation...  #> ... Setting up Julia project...  #> ... Handling dependencies...  #> ... `Julia` set up with 11 thread(s).  #> `patter::julia_connect()` call ended @ 2025-04-21 20:40:53 (duration: ~0 sec(s))."},{"path":"https://edwardlavender.github.io/patter/reference/plot_xyt.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots: plot coordinates (x, y, t) — plot_xyt","title":"Plots: plot coordinates (x, y, t) — plot_xyt","text":"function maps xyt data (.e. coordinate (x, y) locations selected time steps (t) entire time series) can used create animations.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/plot_xyt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots: plot coordinates (x, y, t) — plot_xyt","text":"","code":"plot_xyt(   .map,   .coord,   .steps = NULL,   .png = NULL,   .add_surface = list(),   .add_points = list(),   .add_layer = NULL,   .prompt = FALSE,   ... )"},{"path":"https://edwardlavender.github.io/patter/reference/plot_xyt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots: plot coordinates (x, y, t) — plot_xyt","text":".map terra::SpatRaster defines study area (see glossary). .coord data.table::data.table coordinates, including x, y timestep columns. Point graphical parameters (pch, col, bg, cex, lwd, lty, lwd) can included columns customise point appearance. (Graphical parameters provided silently overwrite elements name .add_points.) .steps NULL integer vector time steps map coordinates (e.g., .steps = 1:5L). NULL specifies time steps. .png (optional) named list, passed grDevices::png(), save plots file. filename directory write files. Files named {.steps[1]}.png, {.steps[2]}.png, ..., {.steps[N]}.png. .png supplied .cl supplied via .... .add_surface, .add_points Named lists plot customisation. .add_surface passed terra::plot(), excluding x main. .add_points passed graphics::points(), excluding x y. .add_layer (optional) function used add additional layer(s) plot. function must single (unnamed) integer value time step (even ignored). example function function(...) points(x, y) x y (example) receiver coordinates. .prompt logical variable defines whether prompt user input plots. used interactive mode .png = NULL (multiple time steps). ... Additional argument(s) passed cl_lapply(), .cl.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/plot_xyt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots: plot coordinates (x, y, t) — plot_xyt","text":"function called side effects. returns invisible(TRUE).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/plot_xyt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plots: plot coordinates (x, y, t) — plot_xyt","text":".step, terra::plot() used plot .map.  Coordinates .coord added onto grid via graphics::points(). (Note coordinates derived particle algorithms equally weighted thanks resampling.) function replaces flapper::pf_plot_history(). Linux, function used within Julia session.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/plot_xyt.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plots: plot coordinates (x, y, t) — plot_xyt","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/plot_xyt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots: plot coordinates (x, y, t) — plot_xyt","text":"","code":"if (patter_run(.julia = FALSE, .geospatial = TRUE)) {    #### Set up   # Define map   map <- dat_gebco()   # Define particle samples   fwd <- dat_pff()$states   bwd <- dat_pfb()$states   smo <- dat_tff()$states   # Define directories   con    <- file.path(tempdir(), \"patter\")   frames <- file.path(con, \"frame\")   mp4s   <- file.path(con, \"mp4\")   dir.create(frames, recursive = TRUE)   dir.create(mp4s, recursive = TRUE)   # Cluster options   pbo <- pbapply::pboptions(nout = 4L)    #### Example (1): Plot selected samples   # Plot particles from the forward filter   plot_xyt(.map = map,              .coord = fwd,              .steps = 1L)   # Plot particles from the backward filter   plot_xyt(.map = map,              .coord = bwd,              .steps = 1L)   # Plot smoothed particles   plot_xyt(.map = map,              .coord = smo,              .steps = 1L)    #### Example (2): Plot multiple time steps   # Specify selected steps   plot_xyt(.map = map,              .coord = smo,              .steps = 1:4L)   # Plot all steps (default: .step = NULL)   plot_xyt(.map = map,              .coord = fwd)   # Use `.prompt = TRUE`   plot_xyt(.map = map,              .coord = smo,              .steps = 1:4L,              .prompt = TRUE)    #### Example (3): Customise the background map via `.add_surface`   plot_xyt(.map = map,              .coord = smo,              .steps = 1L,              .add_surface = list(col = rev(terrain.colors(256L))))    #### Example (4): Customise the points   # Use `.add_points`   plot_xyt(.map = map,              .coord = smo,              .steps = 1L,              .add_points = list(pch = \".\", col = \"red\"))   # Include `points()` arguments as columns in `.coord`   # * Here, we colour branches from the filter pruned by the smoother in red   fwd[, cell_id := terra::extract(map, cbind(x, y))]   bwd[, cell_id := terra::extract(map, cbind(x, y))]   smo[, cell_id := terra::extract(map, cbind(x, y))]   fwd[, col := ifelse(cell_id %in% smo$cell_id, \"black\", \"red\")]   bwd[, col := ifelse(cell_id %in% smo$cell_id, \"black\", \"red\")]   plot_xyt(.map = map,              .coord = rbind(fwd, bwd),              .steps = 1L,              .add_points = list(pch = \".\"))    #### Example (5): Add additional map layers   plot_xyt(.map = map,              .coord = smo,              .steps = 1L,              .add_layer = function(t) mtext(side = 4, \"Depth (m)\", line = -4))    #### Example (6): Write images to file   # Write images in serial   plot_xyt(.map = map,              .coord = smo,              .steps = 1:4L,              .png = list(filename = frames))   # Use a fork cluster   if (.Platform$OS.type == \"unix\") {     plot_xyt(.map = map,                .coord = smo,                .steps = 1:4L,                .png = list(filename = frames),                .cl = 2L,                .chunk = TRUE)   }    #### Example (7): Make animations   if (rlang::is_installed(\"av\")) {      # There are lots of tools to create animations:     # * `av::av_encode_video()`       # uses ffmpeg     # * `animation::saveVideo()`      # uses ffmpeg     # * `magick::image_write_video()` # wraps av()     # * `glatos::make_video()`        # wraps av()      # Helper function to open (mp4) files     Sys.open <- function(.file) {       if (.Platform$OS.type == \"Windows\") {         cmd <- paste(\"start\", shQuote(.file))       } else {         cmd <- paste(\"open\", shQuote(.file))       }       system(cmd)     }      # Use av::av_encode_video()     # * This is one of the faster options     input   <- file_list(frames)     output  <- file.path(mp4s, \"ani.mp4\")     av::av_encode_video(input, output, framerate = 10)     # Sys.open(output)    }    file_cleanup(con)  }                                                                                                                                                                                                                                                                                                                                                                                      #> `cl_lapply()` implemented on 2 core(s) using a total of 4 chunk(s) (~2 per core & progress gradations)."},{"path":"https://edwardlavender.github.io/patter/reference/prettyGraphics.html","id":null,"dir":"Reference","previous_headings":"","what":"prettyGraphics in patter — prettyGraphics","title":"prettyGraphics in patter — prettyGraphics","text":"functions internal plotting routines patter taken modified prettyGraphics package.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/prettyGraphics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prettyGraphics in patter — prettyGraphics","text":"","code":"one_page(.one_page, .n = 1L)  par_mf(.n)  par_mf_n(...)  add_sp_path(x, y = NULL, col = hcl.colors(length(x)), ...)"},{"path":"https://edwardlavender.github.io/patter/reference/prettyGraphics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"prettyGraphics in patter — prettyGraphics","text":"Unlike predecessor flapper package, patter import prettyGraphics, default plotting routines much less advanced. may improved future, depending user feedback.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/prettyGraphics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"prettyGraphics in patter — prettyGraphics","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/prettyGraphics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"prettyGraphics in patter — prettyGraphics","text":"","code":"if (FALSE) { # \\dontrun{ #### Example (1): one_page() implementation f <- function() {   pp <- one_page(TRUE, 2)   on.exit(par(pp), add = TRUE)   hist(1:10, main = \"1\")   hist(1:10, main = \"2\")   } f() plot(1) } # }"},{"path":"https://edwardlavender.github.io/patter/reference/raster.vol.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial helper: raster volume — raster.vol","title":"Spatial helper: raster volume — raster.vol","text":"spatialEco::raster.vol() function.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/raster.vol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial helper: raster volume — raster.vol","text":"","code":"raster.vol(x, p = 0.75, sample = FALSE)"},{"path":"https://edwardlavender.github.io/patter/reference/raster.vol.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial helper: raster volume — raster.vol","text":"function copied, modifications, spatialEco package (v.2.0-2). defined separately patter reduce dependencies.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/set_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Julia: set the map(s) — set_map","title":"Julia: set the map(s) — set_map","text":"Use set_map() start workflow export maps study area Julia.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/set_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Julia: set the map(s) — set_map","text":"","code":"set_map(.x, .as_Raster = TRUE, .as_GeoArray = TRUE)"},{"path":"https://edwardlavender.github.io/patter/reference/set_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Julia: set the map(s) — set_map","text":".x map, supplied : terra::SpatRaster, supported Windows MacOS; character string specifying file path raster, supported Windows, MacOS Linux; .as_Raster logical input defines whether read map Raster (see Details). .as_GeoArray logical input defines whether read map GeoArray (see Details).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/set_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Julia: set the map(s) — set_map","text":"function returns invisible(NULL).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/set_map.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Julia: set the map(s) — set_map","text":"set_map() exports map(s) study area Julia. Maps must georeferenced rasters. planar (e.g., Universal Transverse Mercator) projection coordinates metres currently required. Maps used () simulate initial location(s) individual (b) restrict subsequent, simulated movements habitable areas (see ModelMove). NAs define inhospitable regions (land). Initial location(s) subsequent movements restricted non-NA regions. computational reasons, two maps defined Julia. map initial locations sampled exported Raster (named env_init). map incorporated movement model exported GeoArray (named env). Usually, maps identical. reason, default options, .x exported Raster (.as_Raster = TRUE) GeoArray (.as_GeoArray = TRUE). simulate initial locations different map used bound individual movements, export two maps separately, via:","code":"set_map(x1, .as_Raster = TRUE, .as_GeoArray = FALSE) # set initial map set_map(x2, .as_Raster = FALSE, .as_GeoArray = TRUE) # set movement map"},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/set_map.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Julia: set the map(s) — set_map","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/set_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Julia: set the map(s) — set_map","text":"","code":"if (patter_run()) {    julia_connect()   set_seed()    mapfile <- system.file(\"extdata\", \"dat_gebco.tif\",                          package = \"patter\", mustWork = TRUE)   map     <- terra::rast(mapfile)    #### Example (1): Set maps using a SpatRaster   set_map(map)    #### Example (2): Set maps using a file path to a raster   # Use this option on Linux   set_map(mapfile)    #### Example (3): Distinguish between initial and movement maps   # Set 'initial' map from which initial locations are sampled   map_init     <- terra::setValues(map, NA)   cell         <- 25595   map_init[cell] <- 1   set_map(map_init, .as_Raster = TRUE, .as_GeoArray = FALSE)   # Set map for the movement model   set_map(map, .as_Raster = FALSE, .as_GeoArray = TRUE)   # Simulate a movement path   path <- sim_path_walk(.map = map,                         .timeline = seq(as.POSIXct(\"2016-01-01\", tz = \"UTC\"),                                         length.out = 1000L, by = \"2 mins\"))   # The simulated path starts from the set location in `map_init`:   stopifnot(all(     path$x[1] == terra::xFromCell(map, cell),     path$y[1] == terra::yFromCell(map, cell),     path$map_value[1] == terra::extract(map_init, cell)$map_value)   )  } #> `patter::julia_connect()` called @ 2025-04-21 20:41:20...  #> ... Running `Julia` setup via `JuliaCall::julia_setup()`...  #> ... Validating Julia installation...  #> ... Setting up Julia project...  #> ... Handling dependencies...  #> ... `Julia` set up with 11 thread(s).  #> `patter::julia_connect()` call ended @ 2025-04-21 20:41:20 (duration: ~0 sec(s)).  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps."},{"path":"https://edwardlavender.github.io/patter/reference/set_seed.html","id":null,"dir":"Reference","previous_headings":"","what":"Julia: set the seed — set_seed","title":"Julia: set the seed — set_seed","text":"Use set_seed() set seed R Julia start workflow.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/set_seed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Julia: set the seed — set_seed","text":"","code":"set_seed(.seed = 123L)"},{"path":"https://edwardlavender.github.io/patter/reference/set_seed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Julia: set the seed — set_seed","text":".seed integer defined seed (see set.seed()).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/set_seed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Julia: set the seed — set_seed","text":"function returns invisible(NULL).","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/set_seed.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Julia: set the seed — set_seed","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/set_seed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Julia: set the seed — set_seed","text":"","code":"if (patter_run(.geospatial = FALSE)) {   julia_connect()   set_seed(2024L) } #> `patter::julia_connect()` called @ 2025-04-21 20:41:20...  #> ... Running `Julia` setup via `JuliaCall::julia_setup()`...  #> ... Validating Julia installation...  #> ... Setting up Julia project...  #> ... Handling dependencies...  #> ... `Julia` set up with 11 thread(s).  #> `patter::julia_connect()` call ended @ 2025-04-21 20:41:20 (duration: ~0 sec(s))."},{"path":"https://edwardlavender.github.io/patter/reference/sf-helper.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial helper: st_* functions — sf-helper","title":"Spatial helper: st_* functions — sf-helper","text":"Internal sf::sf-package helper functions.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/sf-helper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial helper: st_* functions — sf-helper","text":"","code":"st_invert(.x, .bbox = sf::st_bbox(.x))"},{"path":"https://edwardlavender.github.io/patter/reference/sf-helper.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial helper: st_* functions — sf-helper","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/sim_array.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation: acoustic arrays — sim_array","title":"Simulation: acoustic arrays — sim_array","text":"Simulate acoustic arrays (.e., networks acoustic receiver(s)) grid.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/sim_array.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation: acoustic arrays — sim_array","text":"","code":"sim_array(   .map,   .timeline,   .arrangement = \"random\",   .n_receiver = 10L,   ...,   .receiver_alpha = 4,   .receiver_beta = -0.01,   .receiver_gamma = 750,   .n_array = 1L,   .plot = TRUE,   .one_page = FALSE )"},{"path":"https://edwardlavender.github.io/patter/reference/sim_array.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation: acoustic arrays — sim_array","text":".map terra::SpatRaster defines region interest (see glossary). , .map used : Sample receiver locations appropriate (non NA) regions, via terra::spatSample(); .timeline POSIXct vector regularly spaced time stamps defines timeline simulation. , .timeline used : Define receiver deployment periods (, receiver_start receiver_end columns output data.table::data.table). Receiver deployment periods defined min(.timeline) max(.timeline) constant receivers.  (columns added solely use downstream functions.) .arrangement, .n_receiver, ... Arguments passed terra::spatSample(), used sample receiver locations. .arrangement character defines receiver arrangement (passed method argument). .n_receiver integer defines number receivers simulate (passed size argument). ... Additional arguments, passed terra::spatSample(), excluding x, size, method, replace, na.rm, xy, cells values. .receiver_alpha, .receiver_beta, .receiver_gamma (optional) Numeric constants default detection probability parameters inclusion output data.table::data.table. (columns added solely use downstream functions, sim_observations().) Single inputs expected arguments, constant across receivers. .n_array integer defines number array designs simulate aforementioned parameters. .plot logical variable defines whether plot simulated arrays. .one_page .plot = TRUE, .one_page logical variable defines whether produce plots single page.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/sim_array.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation: acoustic arrays — sim_array","text":"function returns data.table::data.table following columns: array_id—integer vector array IDs, receiver_id—integer vector receiver IDs; receiver_start, receiver_end—POSIXct vectors define receiver deployment periods; receiver_x receiver_y—numeric vectors defines receiver coordinates; receiver_alpha, receiver_beta, receiver_gamma—numeric vectors detection probability parameters, defined;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/sim_array.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulation: acoustic arrays — sim_array","text":"function replaces flapper::sim_array(). Linux, function used within Julia session.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/sim_array.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulation: acoustic arrays — sim_array","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/sim_array.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation: acoustic arrays — sim_array","text":"","code":"if (patter_run(.julia = FALSE, .geospatial = TRUE)) {    #### Define simulation arguments   map      <- dat_gebco()   timeline <- seq(as.POSIXct(\"2016-01-01\", tz = \"UTC\"),                   length.out = 1000L, by = \"2 mins\")    #### Example (1): The default implementation   array <- sim_array(.map = map, .timeline  = timeline)   head(array)    #### Example (2): Customise receiver placement/number   array <- sim_array(.map = map, .timeline = timeline,                      .arrangement = \"regular\", .n_receiver = 100L)    #### Example (3): Customise detection probability parameters   # (This information is used by the default downstream functions)   array <- sim_array(.map = map, .timeline = timeline,                      .receiver_alpha = 4.5,                      .receiver_beta = -0.02,                      .receiver_gamma = 500)    #### Example (4): Control the plot(s)   sim_array(.map = map, .timeline = timeline,             .plot = FALSE)   sim_array(.map = map, .timeline = timeline,             .n_array = 5L, .plot = TRUE, .one_page = TRUE)   sim_array(.map = map, .timeline = timeline,             .n_array = 5L, .plot = TRUE, .one_page = FALSE)  }          #>     array_id receiver_id receiver_start        receiver_end receiver_x #>        <int>       <int>         <POSc>              <POSc>      <num> #>  1:        1           1     2016-01-01 2016-01-02 09:18:00   708542.1 #>  2:        1           2     2016-01-01 2016-01-02 09:18:00   709842.1 #>  3:        1           3     2016-01-01 2016-01-02 09:18:00   706942.1 #>  4:        1           4     2016-01-01 2016-01-02 09:18:00   708742.1 #>  5:        1           5     2016-01-01 2016-01-02 09:18:00   699542.1 #>  6:        1           6     2016-01-01 2016-01-02 09:18:00   710642.1 #>  7:        1           7     2016-01-01 2016-01-02 09:18:00   711042.1 #>  8:        1           8     2016-01-01 2016-01-02 09:18:00   709342.1 #>  9:        1           9     2016-01-01 2016-01-02 09:18:00   706642.1 #> 10:        1          10     2016-01-01 2016-01-02 09:18:00   703942.1 #> 11:        2           1     2016-01-01 2016-01-02 09:18:00   704342.1 #> 12:        2           2     2016-01-01 2016-01-02 09:18:00   708642.1 #> 13:        2           3     2016-01-01 2016-01-02 09:18:00   707742.1 #> 14:        2           4     2016-01-01 2016-01-02 09:18:00   708542.1 #> 15:        2           5     2016-01-01 2016-01-02 09:18:00   710142.1 #> 16:        2           6     2016-01-01 2016-01-02 09:18:00   706642.1 #> 17:        2           7     2016-01-01 2016-01-02 09:18:00   705742.1 #> 18:        2           8     2016-01-01 2016-01-02 09:18:00   699342.1 #> 19:        2           9     2016-01-01 2016-01-02 09:18:00   706242.1 #> 20:        2          10     2016-01-01 2016-01-02 09:18:00   707142.1 #> 21:        3           1     2016-01-01 2016-01-02 09:18:00   709942.1 #> 22:        3           2     2016-01-01 2016-01-02 09:18:00   703142.1 #> 23:        3           3     2016-01-01 2016-01-02 09:18:00   709442.1 #> 24:        3           4     2016-01-01 2016-01-02 09:18:00   706442.1 #> 25:        3           5     2016-01-01 2016-01-02 09:18:00   710342.1 #> 26:        3           6     2016-01-01 2016-01-02 09:18:00   709142.1 #> 27:        3           7     2016-01-01 2016-01-02 09:18:00   707342.1 #> 28:        3           8     2016-01-01 2016-01-02 09:18:00   710942.1 #> 29:        3           9     2016-01-01 2016-01-02 09:18:00   704342.1 #> 30:        3          10     2016-01-01 2016-01-02 09:18:00   709242.1 #> 31:        4           1     2016-01-01 2016-01-02 09:18:00   708142.1 #> 32:        4           2     2016-01-01 2016-01-02 09:18:00   710842.1 #> 33:        4           3     2016-01-01 2016-01-02 09:18:00   699742.1 #> 34:        4           4     2016-01-01 2016-01-02 09:18:00   709542.1 #> 35:        4           5     2016-01-01 2016-01-02 09:18:00   710242.1 #> 36:        4           6     2016-01-01 2016-01-02 09:18:00   707542.1 #> 37:        4           7     2016-01-01 2016-01-02 09:18:00   707242.1 #> 38:        4           8     2016-01-01 2016-01-02 09:18:00   704942.1 #> 39:        4           9     2016-01-01 2016-01-02 09:18:00   711142.1 #> 40:        4          10     2016-01-01 2016-01-02 09:18:00   709342.1 #> 41:        5           1     2016-01-01 2016-01-02 09:18:00   711942.1 #> 42:        5           2     2016-01-01 2016-01-02 09:18:00   702142.1 #> 43:        5           3     2016-01-01 2016-01-02 09:18:00   707042.1 #> 44:        5           4     2016-01-01 2016-01-02 09:18:00   698942.1 #> 45:        5           5     2016-01-01 2016-01-02 09:18:00   706542.1 #> 46:        5           6     2016-01-01 2016-01-02 09:18:00   710142.1 #> 47:        5           7     2016-01-01 2016-01-02 09:18:00   709942.1 #> 48:        5           8     2016-01-01 2016-01-02 09:18:00   707442.1 #> 49:        5           9     2016-01-01 2016-01-02 09:18:00   706942.1 #> 50:        5          10     2016-01-01 2016-01-02 09:18:00   705342.1 #>     array_id receiver_id receiver_start        receiver_end receiver_x #>     receiver_y receiver_alpha receiver_beta receiver_gamma #>          <num>          <num>         <num>          <num> #>  1:    6257707              4         -0.01            750 #>  2:    6264007              4         -0.01            750 #>  3:    6266207              4         -0.01            750 #>  4:    6268007              4         -0.01            750 #>  5:    6265607              4         -0.01            750 #>  6:    6269507              4         -0.01            750 #>  7:    6262307              4         -0.01            750 #>  8:    6260607              4         -0.01            750 #>  9:    6258707              4         -0.01            750 #> 10:    6263607              4         -0.01            750 #> 11:    6251607              4         -0.01            750 #> 12:    6254307              4         -0.01            750 #> 13:    6262207              4         -0.01            750 #> 14:    6262307              4         -0.01            750 #> 15:    6264007              4         -0.01            750 #> 16:    6250807              4         -0.01            750 #> 17:    6252307              4         -0.01            750 #> 18:    6267607              4         -0.01            750 #> 19:    6262207              4         -0.01            750 #> 20:    6250507              4         -0.01            750 #> 21:    6257907              4         -0.01            750 #> 22:    6265707              4         -0.01            750 #> 23:    6253407              4         -0.01            750 #> 24:    6250407              4         -0.01            750 #> 25:    6266007              4         -0.01            750 #> 26:    6252407              4         -0.01            750 #> 27:    6258307              4         -0.01            750 #> 28:    6267707              4         -0.01            750 #> 29:    6265607              4         -0.01            750 #> 30:    6252507              4         -0.01            750 #> 31:    6263907              4         -0.01            750 #> 32:    6253207              4         -0.01            750 #> 33:    6267207              4         -0.01            750 #> 34:    6253507              4         -0.01            750 #> 35:    6265607              4         -0.01            750 #> 36:    6260007              4         -0.01            750 #> 37:    6260207              4         -0.01            750 #> 38:    6252307              4         -0.01            750 #> 39:    6259007              4         -0.01            750 #> 40:    6269807              4         -0.01            750 #> 41:    6256307              4         -0.01            750 #> 42:    6255107              4         -0.01            750 #> 43:    6255707              4         -0.01            750 #> 44:    6269607              4         -0.01            750 #> 45:    6249907              4         -0.01            750 #> 46:    6262407              4         -0.01            750 #> 47:    6250107              4         -0.01            750 #> 48:    6264207              4         -0.01            750 #> 49:    6254307              4         -0.01            750 #> 50:    6264107              4         -0.01            750 #>     receiver_y receiver_alpha receiver_beta receiver_gamma"},{"path":"https://edwardlavender.github.io/patter/reference/sim_observations.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation: observations — sim_observations","title":"Simulation: observations — sim_observations","text":"Simulate time series observations, acoustic detections depth measurements, arising simulated animal movement path(s).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/sim_observations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation: observations — sim_observations","text":"","code":"sim_observations(.timeline, .model_obs, .collect = TRUE)"},{"path":"https://edwardlavender.github.io/patter/reference/sim_observations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation: observations — sim_observations","text":".timeline POSIXct vector regularly spaced time stamps defines timeline simulation. match .timeline used simulate movement paths (see sim_path_walk()). .model_obs named list data.table::data.table. Element names refer ModelObs structures. element  data.table::data.table defines observation model parameters (see glossary). .collect logical variable defines whether collect outputs Julia session R.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/sim_observations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation: observations — sim_observations","text":"Patter.simulate_yobs() creates Dict Julia session (named  yobs). .collect = TRUE, sim_observations() collects outputs R named list, one element sensor type, .model_obs element. element list data.table::data.tables, one simulated path. row time step. columns depend model type. Otherwise, invisible(NULL) returned.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/sim_observations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulation: observations — sim_observations","text":"function wraps Patter.simulate_yobs(). function iterates simulated paths defined Julia workspace sim_path_walk(). path time step, function simulates observation(s). Collectively, .model_obs names parameter data.table::data.table define observation models used simulation (, Vector ModelObs instances). Julia, simulated observations stored hash table (Dict) called yobs, translated named list returned R.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/sim_observations.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulation: observations — sim_observations","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/sim_observations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation: observations — sim_observations","text":"","code":"if (patter_run(.julia = TRUE, .geospatial = TRUE)) {    library(data.table)   library(dtplyr)   library(dplyr, warn.conflicts = FALSE)    #### Connect to Julia   julia_connect()   set_seed()    #### Set up study system   # Define `map` (the region within which movements are permitted)   map <- dat_gebco()   set_map(map)   # Define study period   timeline <- seq(as.POSIXct(\"2016-01-01\", tz = \"UTC\"),                   length.out = 1000L, by = \"2 mins\")    #### Simulate path with default options   paths <- sim_path_walk(.map = map,                          .timeline = timeline,                          .state = \"StateXY\",                          .model_move = model_move_xy())    #### Example (1): Simulate observations via `ModelObsAcousticLogisTrunc`    # Overview:   # * `ModelObsAcousticLogisTrunc`: observation model structure for acoustic observations   # * See ?ModelObsAcousticLogisTrunc   # * See JuliaCall::julia_help(\"ModelObs\")   # * This structure holds:   #   - sensor_id (the receiver_id)   #   - receiver_x, receiver_y (the receiver coordinates)   #   - receiver_alpha, receiver_beta, receiver_gamma   #   - (these are parameters of a truncated logistic detection probability model)   # * Using these fields, it is possible to simulate detections at receivers    # Simulate an acoustic array   a <- 4   b <- -0.01   g <- 750   moorings <- sim_array(.map = map,                         .timeline = timeline,                         .n_receiver = 100L,                         # (optional) Define constant detection probability parameters                         .receiver_alpha = a,                         .receiver_beta = b,                         .receiver_gamma = g)    # This is the shape of detection probability model for the parameters we have chosen   d <- seq(1, 1000, by = 1)   plot(d, ifelse(d <= g, plogis(a * b * d), 0),        ylab = \"Detection probability\",        xlab = \"Distance (m)\",        type = \"l\")    # Define a data.table of observation model parameters   moorings <-     moorings |>     select(sensor_id = \"receiver_id\",            \"receiver_x\", \"receiver_y\",            \"receiver_alpha\", \"receiver_beta\", \"receiver_gamma\") |>     as.data.table()    # Simulate observations   obs <- sim_observations(.timeline = timeline,                           .model_obs = list(ModelObsAcousticLogisTrunc = moorings))    # Examine simulated observations   # * sim_observations() returns a list, with one element for every `.model_obs`   # * Each element is a `list`, with one element for each simulated path   # * Each element is a [`data.table::data.table`] that contains the observations   str(obs)    # Plot detections   detections <-     obs$ModelObsAcousticLogisTrunc[[1]] |>     lazy_dt() |>     filter(obs == 1L) |>     as.data.table()   plot(detections$timestamp, detections$obs)    # Customise `ModelObsAcousticLogisTrunc` parameters   # > Receiver-specific parameters are permitted   moorings[, receiver_alpha := runif(.N, 4, 5)]   moorings[, receiver_beta := runif(.N, -0.01, -0.001)]   moorings[, receiver_gamma := runif(.N, 500, 1000)]   obs <- sim_observations(.timeline = timeline,                           .model_obs = list(ModelObsAcousticLogisTrunc = moorings))    #### Example (2): Simulate observations via `ModelObsDepthUniformSeabed`   # `ModelObsDepthUniformSeabed` is an observation model for depth observations   # * See ?ModelObsAcousticLogisTrunc   # * See JuliaCall::julia_help(\"ModelObsAcousticLogisTrunc\")   pars <- data.frame(sensor_id = 1,                      depth_shallow_eps = 10,                      depth_deep_eps = 20)   obs <- sim_observations(.timeline = timeline,                           .model_obs = list(ModelObsDepthUniformSeabed = pars))    #### Example (3): Simulate observations via `ModelObsDepthNormalTruncSeabed`   # `ModelObsDepthNormalTruncSeabed` is an observation model for depth observations   pars <- data.frame(sensor_id = 1,                      depth_sigma = 10,                      depth_deep_eps = 20)   obs <- sim_observations(.timeline = timeline,                           .model_obs = list(ModelObsDepthNormalTruncSeabed = pars))    #### Example (4): Simulate observations via custom `ModelObs` sub-types   # See `?ModelObs`    #### Example (5): Use multiple observation models   obs <- sim_observations(.timeline = timeline,                           .model_obs = list(ModelObsAcousticLogisTrunc = moorings,                                             ModelObsDepthNormalTruncSeabed = pars))   str(obs)  } #> `patter::julia_connect()` called @ 2025-04-21 20:41:22...  #> ... Running `Julia` setup via `JuliaCall::julia_setup()`...  #> ... Validating Julia installation...  #> ... Setting up Julia project...  #> ... Handling dependencies...  #> ... `Julia` set up with 11 thread(s).  #> `patter::julia_connect()` call ended @ 2025-04-21 20:41:22 (duration: ~0 sec(s)).  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps.    #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps. #> List of 1 #>  $ ModelObsAcousticLogisTrunc:List of 1 #>   ..$ :Classes ‘data.table’ and 'data.frame':\t100000 obs. of  8 variables: #>   .. ..$ timestamp     : POSIXct[1:100000], format: \"2016-01-01 00:00:00\" \"2016-01-01 00:00:00\" ... #>   .. ..$ obs           : int [1:100000] 0 0 0 0 0 0 0 0 0 0 ... #>   .. ..$ sensor_id     : int [1:100000] 1 2 3 4 5 6 7 8 9 10 ... #>   .. ..$ receiver_x    : num [1:100000] 709142 698042 708442 709942 701642 ... #>   .. ..$ receiver_y    : num [1:100000] 6266607 6267507 6266307 6255107 6265107 ... #>   .. ..$ receiver_alpha: num [1:100000] 4 4 4 4 4 4 4 4 4 4 ... #>   .. ..$ receiver_beta : num [1:100000] -0.01 -0.01 -0.01 -0.01 -0.01 -0.01 -0.01 -0.01 -0.01 -0.01 ... #>   .. ..$ receiver_gamma: num [1:100000] 750 750 750 750 750 750 750 750 750 750 ... #>   .. ..- attr(*, \".internal.selfref\")=<externalptr>   #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps. #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps. #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps. #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps. #> List of 2 #>  $ ModelObsAcousticLogisTrunc    :List of 1 #>   ..$ :Classes ‘data.table’ and 'data.frame':\t100000 obs. of  8 variables: #>   .. ..$ timestamp     : POSIXct[1:100000], format: \"2016-01-01 00:00:00\" \"2016-01-01 00:00:00\" ... #>   .. ..$ obs           : int [1:100000] 0 0 0 0 0 0 0 0 0 0 ... #>   .. ..$ sensor_id     : int [1:100000] 1 2 3 4 5 6 7 8 9 10 ... #>   .. ..$ receiver_x    : num [1:100000] 709142 698042 708442 709942 701642 ... #>   .. ..$ receiver_y    : num [1:100000] 6266607 6267507 6266307 6255107 6265107 ... #>   .. ..$ receiver_alpha: num [1:100000] 4.39 4.71 4.11 4.27 4.59 ... #>   .. ..$ receiver_beta : num [1:100000] -0.00438 -0.0074 -0.0082 -0.00279 -0.00345 ... #>   .. ..$ receiver_gamma: num [1:100000] 555 984 693 929 944 ... #>   .. ..- attr(*, \".internal.selfref\")=<externalptr>  #>  $ ModelObsDepthNormalTruncSeabed:List of 1 #>   ..$ :Classes ‘data.table’ and 'data.frame':\t1000 obs. of  5 variables: #>   .. ..$ timestamp     : POSIXct[1:1000], format: \"2016-01-01 00:00:00\" \"2016-01-01 00:02:00\" ... #>   .. ..$ obs           : num [1:1000] 40.2 34.9 41.9 58.5 41.3 ... #>   .. ..$ sensor_id     : int [1:1000] 1 1 1 1 1 1 1 1 1 1 ... #>   .. ..$ depth_sigma   : num [1:1000] 10 10 10 10 10 10 10 10 10 10 ... #>   .. ..$ depth_deep_eps: num [1:1000] 20 20 20 20 20 20 20 20 20 20 ... #>   .. ..- attr(*, \".internal.selfref\")=<externalptr>"},{"path":"https://edwardlavender.github.io/patter/reference/sim_path_walk.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation: movement walks — sim_path_walk","title":"Simulation: movement walks — sim_path_walk","text":"Simulate discrete-time animal movement paths walk models (e.g., random walks, biased random walks, correlated random walks).","code":""},{"path":"https://edwardlavender.github.io/patter/reference/sim_path_walk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation: movement walks — sim_path_walk","text":"","code":"sim_path_walk(   .map = NULL,   .timeline,   .state = \"StateXY\",   .xinit = NULL,   .n_path = 1L,   .model_move = model_move_xy(),   .collect = TRUE,   .plot = .collect & !is.null(.map),   .one_page = FALSE )"},{"path":"https://edwardlavender.github.io/patter/reference/sim_path_walk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation: movement walks — sim_path_walk","text":".map (optional) Windows MacOS, .map terra::SpatRaster defines study area visualisation (see glossary). argument used Linux. , .map used : Plot movement path, .plot = TRUE, via terra::plot(); .timeline POSIXct vector regularly spaced time stamps defines timeline simulation. , .timeline used : Define number time steps simulation; Define time resolution simulation; .state character defines State type (see glossary). .xinit, .n_path Initial State arguments. .xinit specifies initial states simulation (one movement path). .xinit NULL, initial states sampled map. Otherwise, .xinit must data.table::data.table one column state dimension. .n_path integer defines number paths simulate. .model_move character string defines movement model (see ModelMove glossary). .collect logical variable defines whether collect outputs Julia session R. .plot, .one_page Plot options, .collect = TRUE (permitted Windows MacOS). provided, simulated paths plotted .map coloured time step (via internal function add_sp_path()). .plot logical variable defined whether plot .map simulated path(s). path plotted separate plot. .one_page logical variable defines whether produce plots single page. Plot options silently ignored .collect = FALSE.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/sim_path_walk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation: movement walks — sim_path_walk","text":"Patter.simulate_path_walk() creates Vector States Julia session (named  paths). .collect = TRUE, sim_path_walk() collects outputs R data.table::data.table following columns: path_id—integer vector identifies path; timestep—integer vector defines time step; timestamp—POSIXct vector time stamps; x,y,...—numeric vectors define components state; Otherwise, invisible(NULL) returned.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/sim_path_walk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulation: movement walks — sim_path_walk","text":"function simulates movement paths via Patter.simulate_path_walk(): Raster GeoArray maps must set Julia simulation (see set_map()); internal function Patter.sim_states_init() used simulate initial state(s) simulation; , initial coordinates variables (one .n_path). .state one built-options (see State), initial state(s) can sampled map. Otherwise, additional methods data.table::data.table initial states must provided (see Patter.sim_states_init()). Initial states provided .xinit re-sampled, replacement, required, one initial state simulated path. Initial states assigned xinit object Julia, Vector States. Using initial states, Julia function Patter.simulate_path_walk() simulates movement path(s) using movement model (.model_move). Movement paths passed back R convenient visualisation analysis. use new .state /.model_move sub-type sim_path_walk(): Define State sub-type Julia provide name character string function; initialise simulation, write Patter.map_init() Patter.states_init() methods enable automated sampling initial states via Patter.sim_states_init() provide data.table::data.table initial states .xinit; Define corresponding ModelMove sub-type Julia; Instantiate ModelMove instance (, define specific movement model); sim_path_walk() replaces flapper::sim_path_sa(). flapper::sim_path_*() functions currently implemented patter.","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/sim_path_walk.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulation: movement walks — sim_path_walk","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/sim_path_walk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation: movement walks — sim_path_walk","text":"","code":"if (patter_run(.julia = TRUE, .geospatial = TRUE)) {    library(data.table)   library(dtplyr)   library(dplyr, warn.conflicts = FALSE)    #### Connect to Julia   julia_connect()   set_seed()    #### Set up study system   # Define `map` (the region within which movements are permitted)   map <- dat_gebco()   set_map(map)   # Define study period   timeline <- seq(as.POSIXct(\"2016-01-01\", tz = \"UTC\"),                   length.out = 1000L, by = \"2 mins\")    #### Example (1): Simulate path with default options   sim_path_walk(.map = map,                 .timeline = timeline,                 .state = \"StateXY\",                 .model_move = model_move_xy())    #### Example (2): Set the starting location via `.xinit`   # Define an initial location   x <- 708212.6   y <- 6251684   origin <- data.table(map_value = terra::extract(map, cbind(x, y))[1, 1],                        x = x, y = y)   # Run the simulation   sim_path_walk(.map = map,                 .timeline = timeline,                 .state = \"StateXY\",                 .xinit = origin,                 .model_move = model_move_xy())   points(origin$x, origin$y)    #### Example (3): Simulate multiple paths with the same origin via `.xinit`   sim_path_walk(.map = map,                 .timeline = timeline,                 .state = \"StateXY\",                 .xinit = origin,                 .model_move = model_move_xy(),                 .n_path = 4L,                 .one_page = TRUE)    #### Example (4): Simulate multiple paths with different origins via `.xinit`   # Manually specify origins   origins <-     map |>     terra::spatSample(size = 4, xy = TRUE, na.rm = TRUE) |>     select(\"map_value\", \"x\", \"y\") |>     as.data.table()   # Run simulation   sim_path_walk(.map = map,                 .timeline = timeline,                 .state = \"StateXY\",                 .xinit = origins,                 .model_move = model_move_xy(),                 .n_path = 4L,                 .one_page = TRUE)    #### Example (5): Customise two-dimensional random walks via `model_move_xy()`   # Adjust distributions for step lengths and headings   model_move <-     model_move_xy(.mobility = \"750.0\",             .dbn_length = \"truncated(Normal(250, 50), lower = 0.0, upper = 750.0)\",             .dbn_heading = \"VonMises(0.1, 0.1)\")   sim_path_walk(.map = map,                 .timeline = timeline,                 .state = \"StateXY\",                 .model_move = model_move)   # Experiment with other options   model_move <-     model_move_xy(.mobility   = \"300.0\",             .dbn_length = \"truncated(Normal(10.0, 50.0), lower = 0.0, upper = 300.0)\")   sim_path_walk(.map = map,                 .timeline = timeline,                 .state = \"StateXY\",                 .model_move = model_move)    #### Example (6): Use other .state/.model_move combinations   # Simulate a random walk in XYZ   sim_path_walk(.map = map,                 .timeline = timeline,                 .state = \"StateXYZ\",                 .model_move = model_move_xyz())   # Simulate a correlated random walk in XY   sim_path_walk(.map = map,                 .timeline = timeline,                 .state = \"StateCXY\",                 .model_move = model_move_cxy())   # Simulate a correlated random walk in XYZ   sim_path_walk(.map = map,                 .timeline = timeline,                 .state = \"StateCXYZ\",                 .model_move = model_move_cxyz())   # Modify movement model parameters   sim_path_walk(.map = map,                 .timeline = timeline,                 .state = \"StateCXYZ\",                 .model_move = model_move_cxyz(.dbn_heading_delta = \"Normal(0, 1)\",                                         .dbn_z_delta = \"Normal(0, 0.5)\"))    #### Example (7): Use custom .state/.model_move sub-types   # See `?State` and ?ModelMove`    #### Example (8): Simulate numerous paths via `.n_path`   sim_path_walk(.map = map,                 .timeline = timeline,                 .state = \"StateXY\",                 .model_move = model_move_xy(),                 .n_path = 10L)    #### Example (9): Customise plotting options via `.plot` & `.one_page`   # Use one page via `.one_page = TRUE`   sim_path_walk(.map = map,                 .timeline = timeline,                 .state = \"StateXY\",                 .model_move = model_move_xy(),                 .n_path = 2L, .one_page = TRUE)   # Suppress plots via `.plot = FALSE`   sim_path_walk(.map = map,                 .timeline = timeline,                 .state = \"StateXY\",                 .model_move = model_move_xy(),                 .plot = FALSE)  } #> `patter::julia_connect()` called @ 2025-04-21 20:41:26...  #> ... Running `Julia` setup via `JuliaCall::julia_setup()`...  #> ... Validating Julia installation...  #> ... Setting up Julia project...  #> ... Handling dependencies...  #> ... `Julia` set up with 11 thread(s).  #> `patter::julia_connect()` call ended @ 2025-04-21 20:41:26 (duration: ~0 sec(s)).  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps.  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps.  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps.  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps.  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps.  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps.  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps.  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps.  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps.  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps.  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps.           #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps.  #> Warning: Use `seq.POSIXt()` with `from`, `to` and `by` rather than `length.out` for faster handling of time stamps. #>       path_id timestep           timestamp map_value        x       y #>         <int>    <int>              <POSc>     <num>    <num>   <num> #>    1:       1        1 2016-01-01 00:00:00  46.46357 708642.1 6262507 #>    2:       1        2 2016-01-01 00:02:00  44.32810 708764.0 6262474 #>    3:       1        3 2016-01-01 00:04:00  33.80718 708915.9 6262113 #>    4:       1        4 2016-01-01 00:06:00  38.19019 708883.6 6262019 #>    5:       1        5 2016-01-01 00:08:00  33.80718 708937.0 6262101 #>   ---                                                                 #>  996:       1      996 2016-01-02 09:10:00  57.34976 711214.2 6258025 #>  997:       1      997 2016-01-02 09:12:00  55.80263 711210.3 6257954 #>  998:       1      998 2016-01-02 09:14:00  64.60097 711122.9 6257937 #>  999:       1      999 2016-01-02 09:16:00  72.12959 711216.6 6258345 #> 1000:       1     1000 2016-01-02 09:18:00  40.57153 711729.5 6258656"},{"path":"https://edwardlavender.github.io/patter/reference/skill.html","id":null,"dir":"Reference","previous_headings":"","what":"Skill: evaluation metrics — skill","title":"Skill: evaluation metrics — skill","text":"functions standard model skill metrics. patter, support comparisons simulated reconstructed patterns space use.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/skill.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Skill: evaluation metrics — skill","text":"","code":"skill_mb(.obs, .mod, .summarise = \"mean\")  skill_me(.obs, .mod, .summarise = \"mean\")  skill_rmse(.obs, .mod)  skill_R(.obs, .mod)  skill_d(.obs, .mod)"},{"path":"https://edwardlavender.github.io/patter/reference/skill.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Skill: evaluation metrics — skill","text":".obs 'observed' (true) pattern space use, terra::SpatRaster. .mod 'modelled' (reconstructed) pattern space use, terra::SpatRaster. .summarise function, passed terra::global(), used summarise terra::SpatRaster values.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/skill.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Skill: evaluation metrics — skill","text":"functions return number.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/skill.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Skill: evaluation metrics — skill","text":"follow mathematical definitions Lavender et al. (2022) Supplementary Information Sect. 3.2.1. skill_mb() computes mean bias (.summarise = \"mean\"). skill_me() computes mean error (.summarise = \"mean\"). skill_rmse() computes root mean squared error. skill_R() computes Spearman's rank correlation coefficient. skill_d() computes index agreement. functions memory safe. Linux, used within Julia session.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/skill.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Skill: evaluation metrics — skill","text":"Lavender, E. et al. (2022). Benthic animal-borne sensors citizen science combine validate ocean modelling. Sci. Rep. 12: 16613. https://www.doi.org/1038/s41598-022-20254-z","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/reference/skill.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Skill: evaluation metrics — skill","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/skill.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Skill: evaluation metrics — skill","text":"","code":"if (patter_run(.julia = FALSE, .geospatial = TRUE)) {    set.seed(123L)    # Generate hypothetical 'observed' utilisation distribution   obs        <- terra::setValues(dat_gebco(), NA)   obs[24073] <- 1   obs        <- terra::distance(obs)   obs        <- terra::mask(obs, dat_gebco())   obs        <- obs / terra::global(obs, \"sum\", na.rm = TRUE)[1, 1]    # Generate hypothetical modelled' distribution   mod    <- obs   mod[]  <- mod[] + rnorm(n = terra::ncell(mod), mean = 0, sd = 1e-5)   mod    <- terra::mask(mod, dat_gebco())   mod    <- mod / terra::global(mod, \"sum\", na.rm = TRUE)[1, 1]    # Visualise 'observed' versus 'modelled' distributions   pp <- par(mfrow = c(1, 2))   terra::plot(obs)   terra::plot(mod)   par(pp)    # Calculate skill metrics   skill_mb(mod, obs)   skill_me(mod, obs)   skill_rmse(mod, obs)   skill_R(mod, obs)   skill_d(mod, obs)  }  #> [1] 0.8416201"},{"path":"https://edwardlavender.github.io/patter/reference/spat.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial helper: spat* functions — spat","title":"Spatial helper: spat* functions — spat","text":"Internal helpers terra terra::SpatRaster terra::SpatVector objects.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/spat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial helper: spat* functions — spat","text":"","code":"spatIntersect(.x)  spatContainsNA(.x)  spatAllNA(.x)  spatVmap(.map, .mobility, .plot = FALSE, ...)"},{"path":"https://edwardlavender.github.io/patter/reference/spat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial helper: spat* functions — spat","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/utils-lists.html","id":null,"dir":"Reference","previous_headings":"","what":"Utilities: list helpers — utils-lists","title":"Utilities: list helpers — utils-lists","text":"internal list helpers patter.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/utils-lists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utilities: list helpers — utils-lists","text":"","code":"list_compact(l)  list_merge(...)  list_args(.default = list(), .dots = list(), .user = list())"},{"path":"https://edwardlavender.github.io/patter/reference/utils-lists.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Utilities: list helpers — utils-lists","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/utils-signal.html","id":null,"dir":"Reference","previous_headings":"","what":"Utilities: signal messages, warnings or errors — utils-signal","title":"Utilities: signal messages, warnings or errors — utils-signal","text":"functions wrappers message(), warning() stop().","code":""},{"path":"https://edwardlavender.github.io/patter/reference/utils-signal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utilities: signal messages, warnings or errors — utils-signal","text":"","code":"msg(...)  warn(...)  abort(...)"},{"path":"https://edwardlavender.github.io/patter/reference/utils-signal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utilities: signal messages, warnings or errors — utils-signal","text":"... Arguments passed glue::glue().","code":""},{"path":"https://edwardlavender.github.io/patter/reference/utils-signal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utilities: signal messages, warnings or errors — utils-signal","text":"Returned values follow parent functions.","code":""},{"path":"https://edwardlavender.github.io/patter/reference/utils-signal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Utilities: signal messages, warnings or errors — utils-signal","text":"msg() message() wrapper; warn() warning() wrapper immediate, clean warnings; abort() stop() wrapper clean errors;","code":""},{"path":"https://edwardlavender.github.io/patter/reference/utils-signal.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Utilities: signal messages, warnings or errors — utils-signal","text":"Edward Lavender","code":""},{"path":"https://edwardlavender.github.io/patter/reference/utils-str.html","id":null,"dir":"Reference","previous_headings":"","what":"Utilities: strings — utils-str","title":"Utilities: strings — utils-str","text":"Utilities: strings","code":""},{"path":"https://edwardlavender.github.io/patter/reference/utils-str.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utilities: strings — utils-str","text":"","code":"str_items(.items, .quo = \"`\")"},{"path":"https://edwardlavender.github.io/patter/test-environments.html","id":"test-environments","dir":"","previous_headings":"","what":"Test environments","title":"NA","text":"Results: passed, 7m 6.9s, 2025-04-17 Results: passed, 30m 22.7s, 2025-04-17 Results: failed Notes: Patter precompilation failing (2025-04-18) : due GDAL precompilation failure (even base environment) Results AUTO_JULIA_INSTALL = \"false\": Results AUTO_JULIA_INSTALL = \"true\": failed, 2025-02-28 Notes: Requires https://github.com/JuliaInterop/JuliaCall/issues/238 Results: passed, 45m 27.1s, 2025-04-18 Results: passed, 28m 50.3s, 2025-02-28 Results AUTO_JULIA_INSTALL = \"false\": passed, 1m 41.8s, 2025-04-18 Results AUTO_JULIA_INSTALL = \"true\": passed, 6m 37.9s, 2025-04-18 Avoid devtools::load_all() Unset JULIA_PROJ Run patter::julia_connect() global environment Run R CMD Check Results: Results: ","code":": This is due to GDAL precompilation failure (even in base environment)"},{"path":"https://edwardlavender.github.io/patter/news/index.html","id":"patter-v200","dir":"Changelog","previous_headings":"","what":"patter v2.0.0","title":"patter v2.0.0","text":"patter v 2.0.0 includes major internal external changes associated revamp required permit use Linux improvements. breaking changes API functions result. also added new data-assembly routines, assemble_acoustics_containers(), support particle filtering, alongside additional improvements select functions. required existing code, can continue use patter v1.0.1 renv. julia_connect() revised enhanced. .threads argument replaced JULIA_NUM_THREADS. set_map() revamped support applications Linux. function accepts file path raster includes .as_Raster .as_GeoArray arguments. dat_acoustics renamed dat_detections; assemble_acoustics(.timeline, .acoustics, ...) reformulated assemble_acoustics(.timeline, .detections, ...); assemble_xinit_containers() assemble capture/recapture containers, facilitate convergence particle filter fewer particles; assemble_acoustics_containers() assembles acoustic containers; assemble_containers() collates container datasets; assemble_custom() assembles custom datasets; Initial particle samples, formerly generated R via simulate_states_init() associated (internal) routines, moved Patter.jl. change affects sim_path_walk() pf_filter(). .map argument accepted plotting sim_path_walk() longer accepted pf_filter(). See revised examples automated sampling initial states map. bug map_init.ModelObsAcousticLogisTrunc overly restricted region initial samples drawn fixed new Julia routines. New States ModelMoves implemented. Current options StateXY, StateXYZ, StateCXY StateCXZY, map ModelMoveXY, ModelMoveXYZ, ModelMoveCXY ModelMoveCXZY. (StateXYZD ModelMoveXYZD renamed.) model_move_*() wrappers (formerly move_*()) now return character additional ModelMove ModelMove* class label. Plot methods provided -build classes (see plot.ModelMove). sim_path_walk() now fails error invalid maps/movement models. new .collect argument collect outputs R. New model_obs_*() functions implemented, along plot() methods, streamline code. sim_observations() now expects ModelObs structures parameters single named list (passed .model_obs). .model_obs_pars argument dropped. new .collect argument collect outputs R. pf_filter() now expects ModelObs structures observations single named list (passed .yobs). .model_obs argument dropped. new .t_resample argument permits force resampling selected time steps. new .n_iter argument permits multiple runs filter. new .batch argument permits batching, .e., writing particles disk batches (minimise memory requirements cluster implementations). new .collect argument collects outputs R. new .progress argument supports primitive progress bar Windows (addressing #13) enables customisation. revised pf_particles object returned includes callstats [data.table::data.table] replaces convergence element. callstats element includes log likelihood observations given parameters filter run, enabling optimisation static parameters (see third set examples pf_filter()). Patter.particle_smoother_two_filter() re-written enhanced performance; pf_smoother_two_filter() uses flexible .vmap argument, supported set_vmap(), place .box .mobility. Instances two filters incompatible (weights zero) now flagged warning. Formerly, .n_particle copies first particle selected Patter.resample() problematic time steps, leading bottleneck distribution individual’s possible locations. Now 50 % particles forward filter 50 % backward filter randomly selected steps (warning). effective sample size time steps set NA & provides counter number problematic time steps. new .cache argument fixes incorrect caching time-varying movement models enables user turn caching . new .batch argument permits batching (cluster implementations). new .collect argument collects outputs R. new .progress argument enables customisation progress bar (see ). revised pf_particles object returned (see ). pf_plot_xy() deprecated; use renamed function plot_xyt(). map_dens() now requires smoothing bandwidth specified via .sigma argument. new function, bw.h(), default. .use_tryCatch argument now simply named .tryCatch.","code":""},{"path":"https://edwardlavender.github.io/patter/news/index.html","id":"patter-v101","dir":"Changelog","previous_headings":"","what":"patter v1.0.1","title":"patter v1.0.1","text":"Patter.logpdf_step() now includes t argument can used patter map_dens() includes .fterra argument permits parallelisation terra::resample()","code":""},{"path":[]},{"path":"https://edwardlavender.github.io/patter/news/index.html","id":"overview-1-0-0","dir":"Changelog","previous_headings":"","what":"Overview","title":"patter v1.0.0","text":"first version patter. main thrust package provision particle algorithms reconstruction animal movement paths emergent patterns space, focus passive acoustic telemetry systems. package evolved predecessor flapper package, simpler, faster, powerful, better tested easier maintain. current functionality remains streamlined flapper, internal routines—now used specialised, fast Julia backend (Patter.jl)—alongside API supporting documentation substantially improved. package also benefits fewer dependencies fully upgraded line evolution R’s spatial packages (terra sf superseding raster, sp, rgeos associates). Please provide feedback new package. Much work remains!","code":""},{"path":"https://edwardlavender.github.io/patter/news/index.html","id":"de-novo-simulation-1-0-0","dir":"Changelog","previous_headings":"","what":"De-novo simulation","title":"patter v1.0.0","text":"sim_*() functions flapper replaced faster flexible alternatives, including: sim_path_walk(), replaces flapper::sim_path_sa(); sim_array(), replaces flapper::sim_array(); sim_observations(), replaces flapper::sim_detections();","code":""},{"path":"https://edwardlavender.github.io/patter/news/index.html","id":"particle-filter-1-0-0","dir":"Changelog","previous_headings":"","what":"Particle filter","title":"patter v1.0.0","text":"pf_filter() function implements particle filter. brings together enhances ac(), dc(), acdc() pf() functions flapper. major benefit integration likelihood simulated locations evaluated exclusively particle locations, rather across entire grid (ac(), dc() acdc()), much faster. pf_filter() also reparameterises forward simulation individual locations stochastic kick methodology. flapper, simulated new locations calculating movement probabilities surrounding grid cells sampling grid cells line probabilities (directed sampling methodology). approach significant benefits becomes prohibitively expensive grid size (area resolution) increases. patter, stochastic-kick methodology simulates new locations ‘kicking’ previous locations using movement model. Stochastic kicks independent grid resolution, approach much faster.","code":""},{"path":"https://edwardlavender.github.io/patter/news/index.html","id":"backward-smoother-1-0-0","dir":"Changelog","previous_headings":"","what":"Backward smoother","title":"patter v1.0.0","text":"pf_smoother_two_filter() implements particle smoothing. major new routine substantially refines maps space use.","code":""},{"path":"https://edwardlavender.github.io/patter/news/index.html","id":"mapping-1-0-0","dir":"Changelog","previous_headings":"","what":"Mapping","title":"patter v1.0.0","text":"mapping, map_pou() replaces flapper::pf_plot_map() resolves issue calculation weights. map_dens() new function reconstruction maps based spatstat routines. function accounts particle weights fits smooth utilisation distributions using cross validation, superseding approaches flapper based adehabitatHR. approaches can flexibly implemented using data.table::data.table coordinates restricted particle samples. map_hr_*() routines reconstruction home ranges re-implementations get_hr_*() functions flapper. comparison simulated reconstructed patterns, new skill_*() functions can used.","code":""}]
