---
title: "Methodology"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Methodology}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

The `patter` package is a revised implementation of the 'flapper' algorithms for passive acoustic telemetry (Lavender et al., 2023). These algorithms integrate observations and movement in a process-based framework that accounts for all available information to reconstruct movement paths and emergent patterns of space use from detections at receivers (and/or ancillary datasets) (Lavender et al., 2023). This vignette outlines the methodology, providing an entry point to the literature (Lavender et al., in prep) and the package (Lavender et al., in prep). See the `002-workflow` vignette to learn how to implement the methodology using `patter` (type `vignette("002-workflow", package = "patter")`). 

# The flapper algorithms

In Lavender et al.'s original (2023) presentation, the flapper algorithms were introduced as an integrated framework comprised of two branches: an acoustic-container (AC) branch and a particle-filtering (PF) branch. AC-branch algorithms define the set of possible locations of an individual _given the data_. The AC algorithm handles the information from acoustic observations and the DC algorithm handles the information from depth observations (which are often collected alongside acoustic data). PF-branch algorithms refine AC-branch outputs _given a movement model_. In the predecessor [`flapper`](https://github.com/edwardlavender/flapper) package, AC-branch algorithms were implemented via `ac()`, `dc()` and `acdc()` and their outputs were refined through PF via `pf()` and `pf_simplify()`. 

# The forward-filter backward-sampler

In `patter`, we have streamlined, enhanced and formalised the original methodology. Our revised approach falls into the category of forward-filtering backward-sampling algorithms that are described in the particle filtering literature (Doucet & Johansen, 2008). This comprises a forward simulation and a backward pass. In the forward simulation, we simulate the set of possible locations of an individual moving forwards in time, given the data and contingent upon the past. Each location sample is termed a 'particle'. In `patter`, this is achieved with a single function (`pf_forward()`) that integrates the AC- and PF-branch algorithms. 

The forward simulation is followed by a backward pass. In the original implementation, the backward pass was implemented by `pf_simplify()` and involved pruning 'dead ends' from the forward simulation. If you imagine the forward simulation like a growing fungal network between two points in space (representing the start and end of a time series), dead ends are the side branches of the (simulated) fungal network that fail to reach the end. The corresponding (and much improved) routine in `patter` is `pf_backward_killer()`. 

There are two, related limitations with the 'prune' methodology. The first is that the removal of dead ends tends to bias particle samples, because early samples (which invariably sooner-or-later end up on a dead-end) are more likely to get killed than later samples. This is known as particle degeneracy. The second is that while particles are contingent upon the past (a marginal distribution), they do not embody information from the future (the joint distribution). In `patter`, a backward sampling algorithm mitigates these issue to reconstruct movement trajectories (see `pf_backward_sampler()`).

# Forward simulation 

## Overview 

Consider a regular sequence of time steps, along which we have collected observations (at regular or irregular intervals). In the forward simulation, we run along the time series, collecting particle samples (locations that are compatible with the data and properties of movement) as we go. This works as follows:

* **Proposals.** At each time step, propose a series of candidate locations in which the individual could be located. In `patter`, there are two main ways of doing this: 
    * **Stochastic kicks.** Given a previous location, we simulate travel distances and turning angles from a movement model and use these to 'kick' an individual into new locations. 
    * **Directed sampling.** We define the set of reachable locations around a previous location. 
* **Likelihood.** Calculate the likelihood of the data, given each proposal. The likelihoods of acoustic and archival data given each proposal are resolved by the AC and DC algorithms. For example, the AC algorithm calculates the likelihood of acoustic observations (the presence or absence of detections at each receiver), given a model of detection probability. 
* **Weights.** Translate likelihoods into sampling weights that encapsulate the information in the data and the movement model. For stochastic kick proposals, sampling weights and likelihoods are identical because the proposal locations have been generated accounting for the movement model. For directed sampling, we need to combine likelihoods with the probability density of movements into reachable locations and apply numerical normalisation to define weights. 
* **Sampling**. Sample $N$ proposals, with replacement, in line with the weights. This process effectively kills off locations that are incompatible with the data and increases the frequency of more likely proposals. 

This process continues until the end of the time series. The outcome is a set of particle samples (marginal distributions), one for each time step. 

## Implementation 

The implementation of the forward simulation in `patter` is a four step process:

* `pf_setup_data()` is used to setup data (TO DO);
* `pf_setup_obs()` is used to collate observations;
* `acs_()` functions setup AC* algorithm inputs (if required);
* `pf_forward()` implements the forward simulation;

In `pf_forward()`, the key arguments are as follows:

* `.rpropose` is a function that generates proposal locations (e.g., `pf_rpropose_kick()`);
* `.dpropose` is the corresponding function that calculates the density of movements into proposal locations;
* `.moorings` and co. are input datasets required to calculate the likelihood; 
* `.sample` is the sampling function used to sample proposal locations (e.g., `pf_sample_systematic()`);

Most of the complexity in `pf_forward()` is about handling particle degeneracy and convergence. In a standard PF, we 'kick' the particles into new locations, calculate their weights and sample particles accordingly. Degenerate (invalid) particles are removed by the filter. The benefit of this approach is that it is extremely fast (even in `R`, since relevant operations are vectorised). However, particle degeneracy (and convergence) can become an issue, especially for stringent observational models, with many simulated kicks landing in locations that are incompatible with the data. 

`pf_forward()` implements multiple strategies to promote convergence. Quick options are to boost the number of particles and the number of kick attempts at each time step. If this fails, directed sampling is implemented. Under this approach, we propose the complete set of reachable locations and location weights are assigned from the normalised product of proposal likelihoods and movement densities (given the movement model). We then sample from the set of valid proposals, in line with the weights (there is no filtering stage). Other tricks are also available---see `?pf_forward()` for full details. 

`pf_forward()` records `diagnostics` related to particle degeneracy that can guide more efficient algorithm implementations. See the `003-demos` vignette for an illustration of convergence challenges and diagnostics (type `vignette("003-demo", package = "patter")`).

# Backward sampler

The backward sampler is used to reconstruct the joint distribution of particle samples through time (i.e., movement trajectories). For each particle, this approach works as follows:

* Calculate the probability density of movements from that particle to all particles at the previous time step using a movement model; 
* Sample a selected particle at the previous time step, in line with the probability densities linking each pair of particles;
* Repeat this process until the start of the time series;

Backward sampling is implemented via `pf_backward_sampler()` and associates. As noted above, you can also reconstruct paths via `pf_forward()` plus `pf_backward_killer()` (and `pf_path()`), which is much less computationally intensive, but subject to limitations (see above). 

# Analysis 

Particle samples can be used to reconstruct movement paths and maps of space use. Movement paths can be reconstructed in two ways: 

* (original) `pf_forward()` &rarr; `pf_backward_killer()` &rarr; `pf_path()`
* (recommended) `pf_forward()` &rarr; `pf_backward_sampler()`

Patterns of space use (utilisation distributions) can be reconstructed using standard statistical techniques (see `pf_map_pou()` and `map_dens()` for inbuilt functions).

# References

Doucet, A. & Johansen, A. M. (2008). A tutorial on particle filtering and smoothing: Fifteen years later.   <https://www.stats.ox.ac.uk/~doucet/doucet_johansen_tutorialPF2011.pdf>.

Lavender. E. et al. (2023). An integrative modelling framework for passive acoustic telemetry. _Methods in Ecology and Evolution_. <https://doi.org/10.1111/2041-210X.14193>.
