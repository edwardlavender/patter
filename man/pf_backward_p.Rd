% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pf_backward_sampler.R
\name{pf_backward_p}
\alias{pf_backward_p}
\alias{dstep_lookup}
\alias{dstep_read}
\title{PF: run the backward pass}
\usage{
dstep_lookup(.data_now, .data_past, .density)

dstep_read(.data_now, .data_past, .density)

pf_backward_p(
  .history,
  .dens_step = dstep,
  ...,
  .save_history = FALSE,
  .write_history = NULL,
  .cl = NULL,
  .varlist = NULL,
  .progress = TRUE,
  .verbose = TRUE,
  .txt = ""
)
}
\arguments{
\item{.data_now, .data_past, .density}{Arguments for \verb{.dens_step*} functions.
\itemize{
\item \code{.data_now} and \code{.data_past} are \code{\link{data.table}}s (see \code{.dens_step}), below;
\item \code{.density} is either:
\itemize{
\item A \code{list} that contains movement densities (for \code{\link[=dstep_lookup]{dstep_lookup()}}) from \code{\link[=pf_backward_dens]{pf_backward_dens()}};
\item A \code{character} string that defines the directory to \code{parquet} files containing movement densities (for \code{\link[=dstep_read]{dstep_read()}}) from \code{\link[=pf_backward_dens]{pf_backward_dens()}};
}
}}

\item{.history}{Particle samples from the forward simulation, provided either as:
\itemize{
\item A \code{list} of \code{\link{data.table}}s that define cell samples; i.e., the \code{history} element of a \code{\linkS4class{pf}} object.
\item An ordered list of file paths (from \code{\link[=pf_setup_files]{pf_setup_files()}}) that define the directories in which particle samples were written from the forward simulation (as parquet files).
}}

\item{.dens_step, ...}{A function, and associated inputs, used to calculate the probability density of movements between particle samples. \code{.dens_step} must accept the following arguments:
\itemize{
\item \code{.data_now}---a one-row \code{\link{data.table}} that defines the current particle sample (as in \code{.history}).
\item \code{.data_past}---a multi-row \code{\link{data.table}} that defines all particle samples for the previous time step (as in \code{.history}).
\item (optional) \code{...}---additional arguments passed from \code{\link[=pf_backward_p]{pf_backward_p()}}.
}

Three helper functions are provided:
\itemize{
\item \code{\link[=dstep]{dstep()}} calculates distances between current and past particle samples (via \code{\link[terra:distance]{terra::distance()}}) and translates these into probability densities (via \code{\link[=dtruncgamma]{dtruncgamma()}}). Arguments passed via \code{...} are passed to both \code{\link[terra:distance]{terra::distance()}} (which requires a \code{lonlat} input) and \code{\link[=dtruncgamma]{dtruncgamma()}}.
\item \code{\link[=dstep_lookup]{dstep_lookup()}} looks up pre-calculated density values from an object in memory (from XXX);
\item \code{\link[=dstep_read]{dstep_read()}} reads selected pre-calculated density values (from XXX) into memory. This requires the \code{qs} package but, for speed, performs no checks as to whether it is available.
}}

\item{.save_history}{A logical variable that defines whether or not to save updated particle samples in memory (see \code{\link[=pf_forward_1]{pf_forward_1()}}).}

\item{.write_history}{A named list, passed to \code{\link[arrow:write_parquet]{arrow::write_parquet()}}, to write updated particle samples to file (see \code{\link[=pf_forward_1]{pf_forward_1()}}).}

\item{.progress, .cl, .varlist}{(optional) Parallelisation options. Parallelisation is implemented over particles.
\itemize{
\item \code{.progress} is a logical variable that defines whether or not to show a progress bar.
\item \code{.cl} and \code{.varlist} are cluster controls passed to \code{\link[=cl_lapply]{cl_lapply()}}.
}}

\item{.verbose, .txt}{Arguments to monitor function progress (see \code{\link[=pf_forward_1]{pf_forward_1()}}).}
}
\value{
The function returns a \code{\linkS4class{pf_path}} object.
}
\description{
These functions implement backwards sampling of particle samples.
}
\section{Overview}{
The forward filter (\code{\link[=pf_forward_*]{pf_forward_*()}}) reconstructs the possible locations of an individual at each time step, given the previous time step. Backwards sampling refines the particle filter in two ways:
\itemize{
\item We mitigate the issue of particle degeneracy;
\item We reconstruct entire trajectories;
}
}

\section{Pseudocode}{
In outline, the backward pass (backward sampling) proceeds as follows:
\itemize{
\item Identify the final particle samples;
\item For each particle:
\itemize{
\item Calculate the probability density of movements from that particle to all particles at the previous time step via a \code{.dens_step} function.
\item In practice, this typically requires calculating the distances between particle samples and translating these into densities using the movement model;
}
\item Sample a selected particle at the previous time step, in line with the probability densities linking each pair of particles;
\item Repeat this process until the start of the time series;
\item The process can be implemented in parallel for each particle;
}

Note that the algorithm requires large numbers of calculations. Under default options, calculations are implemented on-the-fly, but it may be more efficient to pre-compute the set of distances between the set of unique particle pairs before implementation of the backward sampler.
}

\examples{
#### Set up examples
obs <- dat_obs()
con <- tempdir()
pff_folder <- file.path(tempdir(), "patter", "pf", "forward")
dir.create(pff_folder, recursive = TRUE)
out_pff <- pf_forward(.obs = obs,
                      .bathy = dat_gebco(),
                      .moorings = dat_moorings, .detection_overlaps = dat_overlaps(),
                      .detection_kernels = dat_kernels(),
                      .save_opts = TRUE,
                      .write_opts = list(sink = pff_folder))
# D. Define inputs for pf_backward()
# * Use a subset of samples for speed
history <- out_pff$history[1:10]
gebco <- dat_gebco()

#### Example (1): A. Implementation with default options
out_pfb <-
  pf_backward_p(history,
                .dens_step = dstep, lonlat = FALSE,
                .save_history = TRUE)

#### Example (1): B. Parallelise default implementation
# Use forking
if (.Platform$OS.type == "unix") {
  out_pfb <-
    pf_backward_p(history,
                  .dens_step = dstep, lonlat = FALSE,
                  .save_history = TRUE,
                  .cl = 2L)
}
# Use socket cluster
out_pfb <-
  pf_backward_p(history,
                .dens_step = patter::dstep, lonlat = FALSE,
                .save_history = TRUE,
                .cl = parallel::makeCluster(2L),
                )

#### Example (2): A. Pre-compute step densities in memory
# Pre-compute densities using default dstep() function
densities <- pf_backward_dens(history,
                              .dens_step = dstep, lonlat = FALSE, pairwise = TRUE,
                              .in_memory = TRUE)
# Use pre-computed densities in algorithm
out_pfb <-
  pf_backward_p(history,
                .dens_step = dstep_lookup, .density = densities,
                .save_history = TRUE)

#### Example (2): B. Parallelise algorithm
# Use forking
if (.Platform$OS.type == "unix") {
out_pfb <-
  pf_backward_p(history,
                .dens_step = dstep_lookup, .density = densities,
                .save_history = TRUE,
                .cl = 2L)
}
# Use socket cluster
out_pfb <-
  pf_backward_p(history,
                .dens_step = patter::dstep_lookup, .density = densities,
                .save_history = TRUE,
                .cl = parallel::makeCluster(2L),
                .varlist = "densities")

#### Example (3): Pre-compute step densities without bring data fully into memory

if (FALSE) {

  ## i) Assemble data using {sparklyr} & calculate densities in memory
  # Compute densities
  densities <- pf_backward_dens(pff_folder,
                                .dens_step = dstep, lonlat = FALSE, pairwise = TRUE,
                                .in_memory = FALSE, .collect = Inf)
  # Implement pf_backward_dens() as shown above (in serial or parallel)
  out_pfb <-
    pf_backward_p(history,
                  .dens_step = dstep_lookup, .density = densities,
                  .save_history = TRUE)

  ## ii) Assemble data using {sparklyr} & calculate densities iteratively

  # Compute densities
  pfb_folder <- mktempdir("patter", "pf", "backward", "pre-calcs")
  pf_backward_dens(pff_folder,
                   .dens_step = dstep, lonlat = FALSE, pairwise = TRUE,
                   .in_memory = FALSE,
                   .collect = 0L,
                   .store = pfb_folder)

  # We population {pfb_folder}/density/ with one file for each cell
  # (which is a list of density estimates)
  list.files(pfb_folder)
  dens <-
    file.path(pfb_folder, "density") |>
    list.files(full.names = TRUE, recursive = TRUE)
  qs::qread(dens[1])

  # (optional) Trial parallelisation for density computation
  if (.Platform$OS.type == "unix") {
    pf_backward_dens(pff_folder,
                     .dens_step = dstep, lonlat = FALSE, pairwise = TRUE,
                     .in_memory = FALSE,
                     .collect = 0L,
                     .store = mktempdir("patter", "pf", "backward", "pre-calcs"),
                     .cl = 2L)
  }
  pf_backward_dens(pff_folder,
                   .dens_step = patter::dstep, lonlat = FALSE, pairwise = TRUE,
                   .in_memory = FALSE,
                   .collect = 0L,
                   .store = mktempdir("patter", "pf", "backward", "pre-calcs"),
                   .cl = parallel::makeCluster(2L))

  # Implement `pf_backward()` using `dstep_read()`
  out_pfb <-
    pf_backward_p(history,
                  .dens_step = dstep_read,
                  .density = file.path(pfb_folder, "density"),
                  .save_history = TRUE)

  # Implement `pf_backward()` using `dstep_read()` in parallel
  if (.Platform$OS.type == "unix") {
    out_pfb <-
      pf_backward_p(history,
                    .dens_step = dstep_read,
                    .density = file.path(pfb_folder, "density"),
                    .save_history = TRUE,
                    .cl = 2L)
  }
  out_pfb <-
    pf_backward_p(history,
                  .dens_step = patter::dstep_read,
                  .density = file.path(pfb_folder, "density"),
                  .save_history = TRUE,
                  .cl = parallel::makeCluster(2L),
                  .varlist = "pfb_folder")

}

}
\seealso{
\itemize{
\item The PF (forward simulation) is implemented by \code{\link[=pf_forward_*]{pf_forward_*()}}:
\itemize{
\item \code{\link[=pf_forward_1]{pf_forward_1()}} refines AC-branch algorithm (\code{\link[=acs]{acs()}} and \code{\link[=dc]{dc()}}) outputs using PF;
\item \code{\link[=pf_forward_2]{pf_forward_2()}} is an integrated implementation that couples AC- and PF-branch algorithms internally;
}
\item PF is supported by:
\itemize{
\item Setup helpers, namely \code{\link[=pf_setup_files]{pf_setup_files()}};
\item Template movement models, namely \code{\link[=pf_kick]{pf_kick()}};
}
\item The backward pass is implemented by \code{\link[=pf_backward]{pf_backward()}};
\item Movement paths are built from PF outputs via \code{pf_path()} functions:
\itemize{
\item \code{\link[=pf_path]{pf_path()}} reconstructs paths;
\item \code{\link[=pf_path_pivot]{pf_path_pivot()}} supports path reconstruction;
}
\item To reconstruct maps of space use, see:
\itemize{
\item \code{\link[=pf_coords]{pf_coords()}} to extract particle coordinates;
\item \code{\link[=pf_map_pou]{pf_map_pou()}} for probability-of-use maps;
\item \code{\link[=pf_map_dens]{pf_map_dens()}} for smooth utilisation distributions;
\item \code{\link[=get_hr]{get_hr()}} for home range estimates;
}
}
}
\author{
Edward Lavender
}
