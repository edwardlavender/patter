% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cl_lapply.R
\name{cl_lapply}
\alias{cl_lapply}
\alias{cl_chunk}
\title{Parallelisation via \code{\link[=lapply]{lapply()}}}
\usage{
cl_lapply(
  .x,
  .fun,
  ...,
  .cl = NULL,
  .varlist = NULL,
  .envir = .GlobalEnv,
  .chunk = FALSE,
  .chunk_fun = NULL,
  .use_names = TRUE,
  .combine = NULL
)

cl_chunk(.cl)
}
\arguments{
\item{.x}{A \code{list} or sequence of objects over which to iterate.}

\item{.fun}{A \code{function} that is applied to elements of \code{.x}. This must accept:
\itemize{
\item Elements of \code{.x} as the first argument;
\item A \code{.chunkargs} argument if \code{.chunk_fun} (below) is supplied;
}}

\item{...}{Additional arguments passed to \code{.fun} and \code{.chunk_fun} (if supplied). Since \code{...} is passed to both functions, \code{.fun} and \code{.check_fun} must be able to handle unused arguments.}

\item{.cl, .varlist, .envir}{(optional) Cluster arguments.
\itemize{
\item \code{.cl} is the cluster argument passed to \code{\link[pbapply:pbapply]{pbapply::pblapply()}}, supplied as:
\itemize{
\item A \code{cluster} object from \code{\link[parallel:makeCluster]{parallel::makeCluster()}} or a sister function;
\item An \code{integer} that defines the number of child processes;
}
\item \code{.varlist} is a \code{character} vector of objects for export (see \code{\link[parallel:clusterApply]{parallel::clusterExport()}}).
\item \code{.envir} is the \code{environment} from which to export variables (see \code{\link[parallel:clusterApply]{parallel::clusterExport()}}).
}}

\item{.chunk, .chunk_fun}{(optional) Chunk arguments.
\itemize{
\item \code{chunk} is a \code{logical} vector that defines whether to parallelise over \code{.x} or batches of \code{.x} (chunks).
\itemize{
\item If \code{.chunk = FALSE}, function behaviour matches \code{\link[pbapply:pbapply]{pbapply::pblapply()}}.
\item If \code{.chunk = TRUE}, \code{.x} is split into a series of chunks that are processed in parallel; within each chunk, \code{.fun} is applied to each \code{.x} element. This reduces the parallelisation overhead.
}
\item \code{.chunk_fun} is a \code{function} implemented once for each chunk (unlike \code{.fun} which is implemented for every element of every chunk). This must accept the following argument(s):
\itemize{
\item Elements of \code{.x} for a specific chunk as the first argument;
}
}

The output of \code{.chunk_fun} is made available to \code{.fun} via \code{.chunkargs}.}

\item{.use_names}{A \code{logical} variable that defines whether or use \code{.x}'s names to name output elements. This is silently ignored if \code{.combine} is specified.}

\item{.combine}{(optional) A \code{function} that defines how to combine \code{list} elements. If \code{.combine = NULL}, a \code{list} is returned. Other suitable options are, for example, \code{purrr::list_flatten()} and \code{\link[data.table:rbindlist]{data.table::rbindlist()}}.}
}
\value{
\itemize{
\item \code{\link[=cl_lapply]{cl_lapply()}} invisibly returns a \code{list} or a combined \code{list} (defined by \code{.combine}).
\item \code{\link[=cl_chunk]{cl_chunk()}} returns a \code{logical} variable.
}
}
\description{
\code{\link[=cl_lapply]{cl_lapply()}} is a wrapper for \code{\link[pbapply:pbapply]{pbapply::pblapply()}} that handles cluster checking, set up, batch processing and cluster closure.
}
\details{
\code{\link[=cl_lapply]{cl_lapply()}} is exported, as we have found it useful in other projects, but primarily intended for internal use. Use \code{\link[pbapply:pboptions]{pbapply::pboptions()}} to control the progress bar, including the number of gradations (\code{nout}). \code{nout} also controls the number of chunks on each core. Fewer chunks reduce parallelisation overhead but also the number of gradations on the progress bar.

\code{\link[=cl_chunk]{cl_chunk()}} sets the default chunk behaviour of \code{\link[=cl_lapply]{cl_lapply()}} in wrapper functions:
\itemize{
\item If a single core is specified, \code{\link[=cl_chunk]{cl_chunk()}} returns \code{FALSE}.
\item Otherwise, \code{\link[=cl_chunk]{cl_chunk()}} returns \code{TRUE}.
}

\code{\link[=cl_lapply]{cl_lapply()}} and associated (internal) functions evolved from \href{https://edwardlavender.github.io/flapper/reference/cl.html}{\verb{flapper::cl_*()}} functions.
}
\seealso{
See \href{https://edwardlavender.github.io/flapper/reference/flapper-tips-parallel.html}{\code{flapper-tips-parallel}} for further information about parallelisation, including the differences between socket clusters and forking.
}
\author{
Edward Lavender
}
