% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sims.R
\name{sim_detections}
\alias{sim_detections}
\title{Simulation: acoustic detections}
\usage{
sim_detections(
  .paths,
  .arrays,
  .calc_distance = terra::distance,
  .lonlat = FALSE,
  .rdet = rdet,
  ...,
  .type = c("pairwise", "combinations"),
  .return = c("array_id", "path_id", "timestep", "timestamp", "receiver_id", "dist",
    "pr")
)
}
\arguments{
\item{.paths}{A \code{\link{data.table}} that defines movement path(s) (e.g., from \code{\link[=sim_path_walk]{sim_path_walk()}}). This should contain the following columns:
\itemize{
\item (optional) \code{path_id}---an \code{integer} vector that identifies paths (if the number of paths > 1);
\item \code{timestep}---an \code{integer} vector that defines time steps;
\item \code{x},\code{y}---\code{numeric} vectors that define path coordinates;
}}

\item{.arrays}{A \code{\link{data.table}} that defines array(s) in which to simulate detections. This should contain the following columns:
\itemize{
\item (optional) \code{array_id}---an \code{integer} vector that identifies arrays (if the number of arrays > 1);
\item \code{receiver_id}---a vector that identifies receivers;
\item \code{receiver_easting} and \code{receiver_northing} or \code{receiver_lon} and \code{receiver_lat} (if \code{.lonlat = TRUE})---\code{numeric} vectors that define receiver coordinates;
}}

\item{.calc_distance, .lonlat}{Distance arguments.
\itemize{
\item \code{.calc_distance} is a function that calculates distances between points along a selected path and receiver locations (for a specific array) (e.g., \code{\link[terra:distance]{terra::distance()}}). This should accept:
\item a matrix of path coordinates (for a selected path);
\item a matrix of receiver coordinates (for a specific array);
\item \code{lonlat}, a \code{logical} variable that defines whether or not path/array coordinates are in longitude/latitude format (defined by \code{.lonlat});
}}

\item{.rdet, ...}{A \code{function}, and associated arguments, that simulate detections (such as \code{\link[=rdet]{rdet()}}. A \code{\link{data.table}} is passed to this function (in the form \code{.rdet(.data, ...)}) that defines, for each path point, the distance to each corresponding receiver (in a column called \code{dist}). All other variables in \code{.paths} and \code{.arrays} are also available in this \code{\link{data.table}}. This makes it possible to specify a wide variety of detection probability models (see Examples). The function should return the inputted \code{\link{data.table}} with an \code{integer} \code{detection} column that defines detections (0, 1).}

\item{.type}{If \code{.paths} and \code{.arrays} contain multiple paths/arrays, \code{.type} is a \code{character} that defines whether or not to simulate detections for each path/array pair (\code{.type = "pairwise"}) or for all combinations of paths/arrays (\code{type = "combinations"}).}

\item{.return}{(optional) A \code{character} vector that defines column names retained in the output. \code{NULL} retains all columns in \code{.paths} and \code{.arrays} plus internally computed columns:
\itemize{
\item \code{dist}---the distance between points on the path(s) and the receiver(s) that recorded detections;
\item Columns computed by \code{.rdet}, such as \code{pr} (the probability of detection at receivers that recorded detections), in the case of \verb{.rdet =} \code{\link{rdet}}.
}}
}
\value{
\code{\link[=sim_detections]{sim_detections()}} returns a \code{\link{data.table}} with columns specified by \code{.return}.
}
\description{
These functions facilitate the simulation of detections, arising from animal movement path(s), at passive acoustic telemetry receiver(s).
}
\details{
\code{\link[=sim_detections]{sim_detections()}} implements the simulation. This requires the movement path(s) and array(s) in which detections are simulated to be provided as \code{\link{data.table}}s. If multiple paths and/or arrays are provided, the function simulates detections for each path/array pair (if \code{.type = "pairwise"}) or for all combinations of arrays and paths (if \verb{.type = "combinations}). Detections are simulated in three steps:
\itemize{
\item A distance function (\code{.calc_distance}) is used to calculate distances between points along a selected path and receiver(s):
\item A random generation function (\code{.rdet}) is used to simulate detections, given distances and other information in \code{.paths} and \code{.arrays};
}

In the output, only detections are retained (as in 'real-world' datasets).

These functions replace \href{https://edwardlavender.github.io/flapper/reference/sim_detections.html}{\code{flapper::sim_detections()}} and \href{https://edwardlavender.github.io/flapper/reference/get_detection_pr.html}{\code{flapper::get_detection_pr()}}.
}
\examples{
ssv()

#### Example (1): Implement function for a single path/array
# Simulate an example array & path
a <- sim_array(.n_array = 1L)
p <- sim_path_walk(.n_path = 1L)
# Simulate detections
# * The function returns a data.table with the detections:
sim_detections(.paths = p, .arrays = a)

#### Example (2): Use lon/lat coordinates
r <- dat_gebco()
r <- terra::project(r, "EPSG:4326")
p <- sim_path_walk(r, .lonlat = TRUE, .n_step = 1000, .n_path = 1L)
a <- sim_array(r, .lonlat = TRUE, .n_receiver = 100, .n_array = 1L)
sim_detections(.paths = p, .arrays = a, .lonlat = TRUE)

#### Example (3): Customise the distance function
# E.g., use a shortest-distances function
# See ?cppRouting::get_distance_matrix for one option.

#### Example (4): Customise the simulation function (`.rdet`)
# Re-simulate arrays and paths
a <- sim_array(.n_array = 1L)
p <- sim_path_walk(.n_path = 1L)
# Customise the default .alpha/.beta/.gamma constants
# * If .gamma (detection range) parameter = zero, we get zero detections
dist <- 1:1000
sim_detections(.paths = p, .arrays = a, .gamma = 0)
# E.g., detection probability is perfect, we get detections at every receiver
plot(dist, pdetlogistic(dist, .alpha = Inf, .beta = 1, .gamma = Inf))
sim_detections(.paths = p, .arrays = a, .alpha = Inf, .beta = 1, .gamma = Inf)
# Customise the default function via receiver-specific parameters
a$receiver_range <- runif(nrow(a), 100, 500)
pdetreceiver <- function(.data) {
  pdetlogistic(.x = .data$dist,
               .alpha = 2.5, .beta = -0.02,
               .gamma = .data$receiver_range)
}
sim_detections(.paths = p, .arrays = a, .pdet = pdetreceiver)
# Use a different model that uses information in .arrays/.paths
# * E.g., a logistic model that depends on distance & receiver type
a$receiver_type <- sample(c(0, 1), nrow(a), replace = TRUE)
pdetdrt <- function(.distance, .receiver_type,
                   .alpha = 2.5,
                   .beta_1 = -0.02, .beta_2 = 2,
                   .gamma = 500) {
  pr <- stats::plogis(.alpha + .beta_1 * .distance + .beta_2 * .receiver_type)
  pr[.distance > .gamma] <- 0
  pr
}
dist <- 1:500
plot(dist, pdetdrt(dist, 0), type = "l")
lines(dist, pdetdrt(dist, 1), col = "red")
pdet2 <- function(.data) {
  pdetdrt(.distance = .data$dist, .receiver_type = .data$receiver_type)
}
sim_detections(.paths = p, .arrays = a, .pdet = pdet2)

#### Example (6): Handle multiple paths/arrays
# Simulate observations between each array/path pair
a <- sim_array(.n_array = 2L)
p <- sim_path_walk(.n_path = 2L)
sim_detections(.path = p, .array = a, .type = "pairwise")
# Simulate observations for all arrays/path combinations
a <- sim_array(.n_array = 2L)
p <- sim_path_walk(.n_path = 3L)
sim_detections(.paths = p, .arrays = a, .type = "combinations")
}
\seealso{
\itemize{
\item \verb{sim_*} functions implement \emph{de novo} simulation of movements and observations:
\itemize{
\item \code{\link{sim_helpers}} are convenience functions for simulations;
\item \code{\link[=sim_array]{sim_array()}} simulates acoustic array(s);
\item \code{\link[=sim_path_walk]{sim_path_walk()}} simulates movement path(s) via a walk model;
\item \code{\link[=sim_detections]{sim_detections()}} simulates detection(s) at receivers;
}
\item \code{\link[=pf_forward]{pf_forward()}} and associates implement the simulation-based reconstruction of movements;
\item \code{\link{skill}} functions compared simulated and reconstructed patterns to evaluate model skill;
}
}
\author{
Edward Lavender
}
