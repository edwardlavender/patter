% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pf_forward_ds.R
\name{pf_forward}
\alias{pf_forward}
\title{PF: run the forward simulation}
\usage{
pf_forward(
  .obs,
  .record,
  .kick,
  ...,
  .bathy,
  .n = 100L,
  .save_history = FALSE,
  .write_history = NULL,
  .progress = TRUE,
  .prompt = FALSE,
  .verbose = TRUE,
  .con = ""
)
}
\arguments{
\item{.obs}{A \code{\link{data.table}} that defines the time series of observations (see \code{\link[=acs]{acs()}}). For \code{\link[=pf_forward]{pf_forward()}}, at a minimum, this must contain the following column(s):
\itemize{
\item \code{timestep}---an \code{integer} that defines the time step;
\item Any columns required by \code{.kick} (see below);
}}

\item{.record}{A list of \code{\link{SpatRaster}}s, or a character vector of file paths to \code{\link{SpatRaster}}s (see \code{\link[=pf_setup_record]{pf_setup_record()}}), that define the set of possible locations of the individual according to the data (i.e., an AC* algorithm).}

\item{.kick, ..., .bathy}{A function, and associated inputs, used to 'kick' particles into new (proposal) locations. \code{.kick} must support the following inputs:
\itemize{
\item \code{.particles}---a \code{\link{data.table}} that defines the \code{cell} IDs and associated coordinates (\code{x_now} and \code{y_now}) of current particle samples;
\item (optional) \code{.obs}---the \code{.obs} \code{\link{data.table}};
\item (optional) \code{.t}---the \code{timestep} (used to index \code{.obs});
\item (optional) \code{.bathy}---a \code{\link{SpatRaster}} that defines the bathymetry;
\item (optional) \code{...}---additional arguments, passed via \code{\link[=pf_forward]{pf_forward()}}, if required;
}

See \code{\link[=pf_kick]{pf_kick()}} for an example movement model.}

\item{.n}{An \code{integer} that defines the number of particle samples at each time step.}

\item{.save_history}{A logical variable that defines whether or not to save particle samples in the \code{history} element of the output. This is only sensible for small-scale applications (i.e., short time series and few particles).}

\item{.write_history}{A named list, passed to \code{\link[arrow:write_parquet]{arrow::write_parquet()}}, to save particle samples to file at each time step. The \code{sink} argument should be the directory in which to write files. Files are named by \code{.obs$timestep} (i.e., \verb{1.parquet}, \verb{2.parquet}, ..., \code{N.parquet}).}

\item{.progress}{A logical variable that defines whether or not to implement a progress bar (via \code{\link[progress:progress_bar]{progress::progress_bar()}}).}

\item{.prompt, .verbose, .con}{Controls on function prompts and messages (see \code{\link[=acs]{acs()}}).}
}
\value{
The function returns a \code{\linkS4class{pf}} object.
}
\description{
This function implements forward simulation of possible locations.
}
\details{
The forward simulation is implemented as follows:
\enumerate{
\item At each time step, \code{.n} grid cells (particles) are sampled (at \code{t = 1}) or resampled from a set of proposals (at subsequent time steps) with replacement, in line with AC* weights;
\item The previous locations (\code{NA} for \code{t = 1}) and the (accepted) current locations are recorded;
\item Each particle is 'kicked' into new (proposal) location (grid cell), by the movement model;
\item Steps 1--3 are repeated until the end of the time series;
}
}
\examples{
#### Set up examples

# Define input datasets
acoustics <- dat_acoustics[individual_id == 25, ]
archival <- dat_archival[individual_id == 25, ]
obs <- acs_setup_obs(acoustics, archival, "2 mins", 500)
obs <- obs[1:200, ]
gebco <- dat_gebco()

# Implement AC* algorithm
dat_moorings$receiver_range <- 500
containers <- acs_setup_detection_containers(gebco, dat_moorings)
overlaps <- acs_setup_detection_overlaps(containers, dat_moorings)
kernels <-
  acs_setup_detection_kernels(dat_moorings,
                              .calc_detection_pr = acs_setup_detection_pr,
                              .bathy = gebco)
ac_folder <- file.path(tempdir(), "ac")
dir.create(ac_folder)
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .save_record = TRUE,
      .write_record = list(filename = ac_folder, overwrite = TRUE))

#### Example (1): Implement pf_forward() with default options
out_pf <- pf_forward(.obs = obs,
                     .record = out_ac$record,
                     .n = 1e3,
                     .kick = pf_kick,
                     .bathy = gebco,
                     .save_history = TRUE)
# The function returns a named list:
summary(out_pf)

#### Example (2): Pass a list of SpatRasters to `.record`
spats <- pf_setup_record(ac_folder)
out_pf <- pf_forward(.obs = obs,
                     .record = spats,
                     .n = 1e3,
                     .kick = pf_kick,
                     .bathy = gebco,
                     .save_history = TRUE)

#### Example (3): Write history to file (similar to acs())
pf_folder <- file.path(tempdir(), "pf")
dir.create(pf_folder)
pf_forward(.obs = obs,
           .record = out_ac$record,
           .n = 1e3,
           .kick = pf_kick,
           .bathy = gebco,
           .save_history = TRUE,
           .write_history = list(sink = pf_folder))
utils::head(list.files(pf_folder))

#### Example (4): Customise verbose options (as in acs())
# Suppress progress bar
out_pf <- pf_forward(.obs = obs,
                     .record = out_ac$record,
                     .n = 1e3,
                     .kick = pf_kick,
                     .bathy = gebco,
                     .save_history = TRUE,
                     .progress = FALSE)
# Use prompt = TRUE for debugging
if (interactive()) {
  out_pf <- pf_forward(.obs = obs,
                       .record = out_ac$record,
                       .n = 1e3,
                       .kick = pf_kick,
                       .bathy = gebco,
                       .save_history = TRUE,
                       .prompt = TRUE)
}
# Use con to write messages to file
log.txt <- tempfile(fileext = ".txt")
out_pf <-
  pf_forward(.obs = obs,
             .record = out_ac$record,
             .n = 1e3,
             .kick = pf_kick,
             .bathy = gebco,
             .con = log.txt,
             .save_history = TRUE)
readLines(log.txt) |> utils::head()

#### Example (5): Customise movement model
# Modify `.kick()` to use alternative movement models, e.g.:
# * Use random walk
# * Use correlated random walk
# * Use temporally varying movement model
# * Use spatio-temporal movement model

# Clean up
unlink(ac_folder, recursive = TRUE)
unlink(pf_folder, recursive = TRUE)
}
\author{
Edward Lavender
}
