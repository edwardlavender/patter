% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pf_backward_sampler.R
\name{pf_backward_sampler}
\alias{pf_backward_sampler}
\alias{pf_backward_sampler_p}
\alias{pf_backward_sampler_v}
\title{PF: backward sampler}
\usage{
pf_backward_sampler_p(
  .history,
  .dpropose = pf_dpropose,
  .obs = NULL,
  .dlist,
  .dargs = list(),
  .control = pf_opt_control(),
  .cl = NULL,
  .cl_varlist = NULL,
  .cl_chunk = cl_chunk(.cl),
  .record = pf_opt_record(),
  .verbose = getOption("patter.verbose")
)

pf_backward_sampler_v(
  .history,
  .dpropose = pf_dpropose,
  .obs = NULL,
  .dlist,
  .dargs = list(),
  .control = pf_opt_control(),
  .record = pf_opt_record(),
  .verbose = getOption("patter.verbose")
)
}
\arguments{
\item{.history}{Particle samples from the forward simulation, provided in any format accepted by \code{\link[=.pf_history_list]{.pf_history_list()}}. Particle samples must contain \code{timestep}, \code{cell_now}, \code{x_now} and \code{y_now} columns.}

\item{.dpropose, .obs, .dlist, .dargs}{A \code{function} and associated arguments used to evaluate the probability density of movement between location pairs (see \code{\link[=pf_forward]{pf_forward()}} and \code{\link[=pf_dpropose]{pf_dpropose()}}). \code{.dpropose} must accept the following arguments, even if they are unused:
\itemize{
\item \code{.particles}, a \code{\link{data.table}} of particle samples that contains pairs of particles from the current and previous time steps. This contains the following columns:
\itemize{
\item \code{cell_now}, \code{x_now}, \code{y_now}---an \code{integer} vector of particle (grid cell) IDs and \code{numeric} vectors of particle coordinates for the current time step;
\item \code{cell_past}, \code{x_past}, \code{y_past}---as above but for the previous time step;
}
\item \code{.obs}, a \code{\link{data.table}} of observations (see \code{\link[=pf_forward]{pf_forward()}});
\item \code{.t}, an \code{integer} that defines the time step;
\item \code{.dlist}, a \code{named} list of data and parameters required to calculate movement densities (see \code{\link[=pf_forward]{pf_forward()}});
\item (optional) Additional arguments, passed in a named \code{list} via \code{.dargs} (see \code{\link[=pf_forward]{pf_forward()}});
}

Using these inputs, \code{.dpropose} must calculate the probability density of movements from each \code{cell_past} to \code{cell_now}, returning the inputted \code{\link{data.table}} with a \code{dens} column. In \code{\link[=pf_backward_sampler_p]{pf_backward_sampler_p()}}, we only consider a single \code{cell_now} at each time step alongside all previous locations. In \code{\link[=pf_backward_sampler_v]{pf_backward_sampler_v()}}, we simultaneously consider all \code{cell_now} entries at the current time step alongside all previous locations.

The default function uses \code{.particles} and \code{.dlist$spatial$lonlat}. It calculates Euclidean distances between particle coordinates and translates these into probabilities via \code{.dkick} (see \code{\link[=pf_dpropose]{pf_dpropose()}}).

See \code{\link[=pf_forward]{pf_forward()}} and \code{\link[=pf_dpropose]{pf_dpropose()}} for full details on required function arguments, inputs and outputs.}

\item{.control}{A named \code{list} of control options, from \code{\link[=pf_opt_control]{pf_opt_control()}}.}

\item{.cl, .cl_varlist, .cl_chunk}{For \code{\link[=pf_backward_sampler_p]{pf_backward_sampler_p()}}, \verb{.cl*} arguments are parallelisation options, passed to \code{\link[=cl_lapply]{cl_lapply()}}.}

\item{.record}{A named \code{list} of output options, from \code{\link[=pf_opt_record]{pf_opt_record()}}.}

\item{.verbose}{User output control (see \code{\link{patter-progress}} for supported options).}
}
\value{
The functions return a \code{\linkS4class{pf_particles}} object:
\itemize{
\item \code{\link[=pf_backward_sampler_p]{pf_backward_sampler_p()}} automatically populates the \code{path} and \code{time} elements;
\item \code{\link[=pf_backward_sampler_v]{pf_backward_sampler_v()}} automatically populates the \code{history} and \code{time} elements;
}
}
\description{
These functions implement the backward sampling algorithm.
\itemize{
\item \code{\link[=pf_backward_sampler_p]{pf_backward_sampler_p()}} is a parallel particle-by-particle implementation;
\item \code{\link[=pf_backward_sampler_v]{pf_backward_sampler_v()}} is a vectorised implementation;
}
}
\section{Overview}{
The forward-filtering backward-sampling algorithm in \code{\link{patter}} is implemented via \code{\link[=pf_forward]{pf_forward()}} plus \code{\link[=pf_backward_*]{pf_backward_*()}}. \code{\link[=pf_forward]{pf_forward()}} runs a simulation forwards in time, generating location (particle) samples that are consistent with the data up to and including each time point (a marginal distribution). The backward sampler runs a simulation backwards in time. This generates a set of particle samples at each time step that embodies all information from both the past \emph{and the future}; i.e., the full joint distribution of individual locations and data (see \code{\link[=pf_backward_*]{pf_backward_*()}})
}

\section{Parallel implementation}{
\subsection{Overview}{

The backward sampler begins with particle samples from \code{\link[=pf_forward]{pf_forward()}} for the final time step. \code{\link[=pf_backward_sampler_p]{pf_backward_sampler_p()}} iterates over particles and time steps. Moving backwards in time, for time step (> 1) and each particle, the algorithm acts as follows:
\itemize{
\item Calculate the probability density of movements from that particle to all particles at the previous time step via a \code{.dpropose} function.
\item (In practice, this typically requires calculating the distances between particle samples and translating these into densities using the movement model);
\item Sample a selected particle at the previous time step, in line with the probability densities linking each pair of particles;
}

This implementation returns a \code{\linkS4class{pf_particles}} object, but only the \code{paths} and \code{time} elements are populated by default. Unlike the vectorised implementation, we do not directly keep track of particle histories.
}

\subsection{Advantages}{
\itemize{
\item Simple. This routine is simpler than the vectorised approach.
\item Memory-safe. The function is effectively memory safe, since we handle one particle at a time.
\item Scalable. The algorithm is embarrassingly parallel and it is possible to achieve substantial speed ups with parallelisation.
\item Permits pre-calculated densities. It is straightforward to use precomputed densities for any given cell into surrounding cells. Simply use \code{.dpropose} to read precomputed densities from a selected cell (\code{.particles$cell_now[1]}) to surrounding cells into memory and match them onto the \code{.particles} \code{\link{data.table}}. Set \code{NA}s to zero for re-sampling (see below).
\item Paths. By iterating over each particle, we automatically generate movement paths, unlike \code{\link[=pf_backward_sampler_v]{pf_backward_sampler_v()}} which requires post-hoc path assembly (see \code{\link[=pf_path]{pf_path()}}).
}

\code{\link[=pf_backward_sampler_p]{pf_backward_sampler_p()}} is preferable if:
\itemize{
\item You have massive parallelisation capacities;
\item You can (and want to) use precomputed densities;
\item You want to obtain movement trajectories automatically;
}
}

\subsection{Use cases}{

We used this approach in the \href{https://github.com/edwardlavender/patter-eval}{\code{patter-eval}} project. In that project, we considered a relatively small study area within which we implemented tens of thousands of simulations in parallel. This made it possible (and worthwhile) to precompute movement densities across a grid. In the backward sampler, we read precomputed densities into memory at each time step. This was massively faster than the repetitive vectorised implementation.
}
}

\section{Vectorised implementation}{
Unlike \code{\link[=pf_backward_sampler_p]{pf_backward_sampler_p()}}, \code{\link[=pf_backward_sampler_v]{pf_backward_sampler_v()}} iterates over time steps and vectorises probability density calculations:
\itemize{
\item At each time step, we identify all combinations of particle samples for the current and previous time step.
\item Probability densities are evaluated between particle pairs and re-sampling is implemented by particle.
}

This approach assumes that particle combinations can be held in memory (this is reasonable for \eqn{\leq 1000} particles but is relatively easy to relax if required) and that likelihood evaluations are cheap. Under these circumstances, this approach is faster than similar, more memory-efficient approaches based on the subset of unique cell combinations.

The vectorised implementation returns a \code{\linkS4class{pf_particles}} object, as in \code{\link[=pf_forward]{pf_forward()}} and \code{\link[=pf_backward_killer]{pf_backward_killer()}}. Unlike a particle-by-particle implementation, we do not automatically reconstruct trajectories. \code{\link[=pf_path]{pf_path()}} is required to translate particle samples into trajectories.
\subsection{Advantages}{
\itemize{
\item Speed. The main advantage of \code{\link[=pf_backward_sampler_v]{pf_backward_sampler_v()}} is speed when only modest numbers of cores are available. We anticipate that in most cases \code{\link[=pf_backward_sampler_v]{pf_backward_sampler_v()}} is preferable for this reason.
\item History. We keep track of particle histories.
}
}

\subsection{Use cases}{

We used this approach in the \href{https://github.com/edwardlavender/patter-flapper}{\code{patter-flapper}} project. In that project, we considered a large grid, exceeding four billion cells. It was not feasible to pre-calculate movement densities. We implemented the algorithms in parallel over individuals. We used the vectorised implementation of the backward sampler which, on a single core, exhibited similar speeds to a parallelised implementation of \code{\link[=pf_backward_sampler_p]{pf_backward_sampler_p()}} over 10 cores.
}
}

\section{Mobility}{
Currently, we assume that at each time step there is at least one valid connection from each location to location(s) at the preceding step. If this assumption is violated, you will receive an error along the lines of \verb{Error in sample.int(0, size = 1L, prob = 1) : invalid first argument} (\code{\link[=pf_backward_sampler_p]{pf_backward_sampler_p()}}) or \verb{Supplied \{N\} items to be assigned to \{n < N\} items of column 'index'} (\code{\link[=pf_backward_sampler_v]{pf_backward_sampler_v()}}). This indicates a discrepancy in the movement models used to generate locations and calculate probability densities (and probably an inconsistent handling of \code{.mobility}, possibly as a result of discretisation). See \code{\link{pf_propose}} for further details.
}

\section{Costs}{
The backward sampler requires large numbers of (potentially replicate) calculations. Under default settings, calculations are implemented on-the-fly. For intermediate-sized problems, it may be more efficient to precompute densities, or variables required for density estimation (such as distance), between (unique) particle pairs before implementation of the backward sampler. This is easiest in \code{\link[=pf_backward_sampler_p]{pf_backward_sampler_p()}}, since we consider only a single particle (grid cell) at each time step. Modify \code{.dpropose}  to read and match densities from objects in memory or from file onto the \code{.particles} \code{\link{data.table}}. However, for big datasets, identifying and storing unique particle combinations becomes difficult and expensive and we do not currently have a better solution than on-the-fly calculations. If \verb{pf_backward_sampler_*()} is prohibitively expensive, it is acceptable to use particle samples from \code{\link[=pf_forward]{pf_forward()}}) and/or \code{\link[=pf_backward_killer]{pf_backward_killer()}} for trajectory construction and mapping. The extent to which backward sampling refines trajectories and patterns of space use is context-specific.
}

\examples{
#### Set up
# Use precomputed function inputs & particle samples from `?pf_forward()`:
# * Data list (see `?pat_setup_data()` and `?pf_forward()`)
# * Observations timeline (see `?pf_setup_obs()` and `?pf_forward()`)
# * Particle samples (see `?pf_forward()`)
obs      <- dat_obs()
dlist    <- dat_dlist()
out_pff  <- dat_pff()
# Implement `pf_backward_killer()` (for comparison)
out_pfbk <- pf_backward_killer(.history = out_pff,
                               .record = pf_opt_record(.save = TRUE))
# Define the number of time steps
nt       <- length(out_pff$history)

#### Example (1): Implement function with default arguments
ssv()
out_pfbs <- pf_backward_sampler_v(.history = out_pff,
                                  .dlist = dlist,
                                  .record = pf_opt_record(.save = TRUE))
# The function returns a pf_particles-class object
summary(out_pfbs)
# Particle samples are located in the `history` element
head(out_pfbs$history[[1]])
head(out_pfbs$history[[2]])
head(out_pfbs$history[[nt]])
# The `time` element records timing
out_pfbs$time

#### Example (2): Use particle samples in memory or on file
# Particles can be provided in any format accepted by `?.pf_history_list()`
# Here, we use precomputed samples:
ssv()
out_pfbs_b <- pf_backward_sampler_v(.history = out_pff$history,
                                    .dlist = dlist,
                                    .record = pf_opt_record(.save = TRUE))
ssv()
out_pfbs_c <- pf_backward_sampler_v(.history = dat_pff_src(),
                                    .dlist = dlist,
                                    .record = pf_opt_record(.save = TRUE))
ssv()
out_pfbs_d <- pf_backward_sampler_v(.history = pf_files(dat_pff_src()),
                                    .dlist = dlist,
                                    .record = pf_opt_record(.save = TRUE))
stopifnot(all.equal(out_pfbs$history, out_pfbs_b$history))
stopifnot(all.equal(out_pfbs$history, out_pfbs_c$history))
stopifnot(all.equal(out_pfbs$history, out_pfbs_d$history))

#### Example (3): Customise the movement model
# Use .dpropose and .dargs

#### Example (4): Write history to file (as in `pf_forward()`)
con        <- file.path(tempdir(), "patter")
pfbs_folder <- file.path(con, "backward", "sampler")
dir.create(pfbs_folder, recursive = TRUE)
ssv()
out_pfbs <- pf_backward_sampler_v(.history = out_pff,
                                  .dlist = dlist,
                                  .record = pf_opt_record(.save = TRUE,
                                                          .sink = pfbs_folder))
cl_lapply(seq_len(nt), function(i) {
  a <- out_pfbs$history[[i]]
  b <- arrow::read_parquet(file.path(pfbs_folder, paste0(i, ".parquet")))
  stopifnot(all.equal(a, b))
})

#### Example (4): Adjust standard `patter-progress` options
# See `?pf_backward_killer()` for examples

#### Example (5): Compare particle diagnostics (e.g., degeneracy)
# Extract diagnostics
diag_f <- pf_diag_summary(out_pff)
diag_k <- pf_diag_summary(out_pfbk)
diag_s <- pf_diag_summary(out_pfbs)
# Compare the number of unique samples through time
ylim <- range(c(diag_f$nu, diag_k$nu, diag_s$nu))
plot(diag_f$timestep, diag_f$nu,
     ylim = ylim,
     xlab = "Time (steps)", ylab = "Number unique samples",
     type = "b", cex = 0.5, col = "red")
lines(diag_k$timestep, diag_k$nu,
      type = "b", cex = 0.5, col = "orange")
lines(diag_s$timestep, diag_s$nu,
      type = "b", cex = 0.5, col = "darkgreen")

#### Example (6): Compare maps
pp    <- par(mfrow = c(1, 3))
gebco <- dat_gebco()
map_dens(.map = gebco,
         .coord = pf_coord(.history = out_pff, .bathy = gebco),
         sigma = spatstat.explore::bw.diggle)
map_dens(.map = gebco,
         .coord = pf_coord(.history = out_pfbk, .bathy = gebco),
         sigma = spatstat.explore::bw.diggle)
map_dens(.map = gebco,
         .coord = pf_coord(.history = out_pfbs, .bathy = gebco),
         sigma = spatstat.explore::bw.diggle)
par(pp)


# Clean up
unlink(con, recursive = TRUE)
}
\seealso{
The forward filtering--backward sampling algorithm samples locations (particles) that represent the possible locations of an individual through time, accounting for all data and the individual's movement.
\itemize{
\item To set up data, use \code{\link[=pat_setup_data]{pat_setup_data()}}.
\item \code{\link[=pf_forward]{pf_forward()}} implements the forward filter:
\itemize{
\item To set up an observations timeline, use \code{\link[=pf_setup_obs]{pf_setup_obs()}}.
\item For proposal (movement) models, see \code{\link{pf_propose}}.
\item For likelihood functions, to evaluate the likelihood of the data at proposal locations, see \code{\link{pf_lik}}.
\item For sampling functions, to (re)sample plausible proposal locations, see \code{\link{pf_sample}}.
\item For tuning parameters, see \code{\link{pf_opt}}.
}
\item \code{\link[=pf_backward_*]{pf_backward_*()}} refines outputs from the forward filter:
\itemize{
\item \code{\link[=pf_backward_killer]{pf_backward_killer()}} removes dead-ends;
\item \code{\link{pf_backward_sampler}}\verb{_*()} implements the backward sampler;
}
\item To reconstruct movement paths from particle samples, use \code{\link[=pf_path]{pf_path()}}.
\item To map emergent patterns of space use, use \code{\link[=pf_coord]{pf_coord()}} plus a \verb{map_*()} function, such as \code{\link[=map_pou]{map_pou()}}, \code{\link[=map_dens]{map_dens()}} and/or \code{\link{map_hr}}\verb{_()}.
\item For additional utilities, see supporting \verb{pf_*()} functions, such as \code{\link[=pf_files]{pf_files()}}, \code{\link[=pf_files_size]{pf_files_size()}}, \code{\link[=pf_plot_history]{pf_plot_history()}}, \code{\link[=pf_diag_convergence]{pf_diag_convergence()}} and \code{\link[=pf_diag_summary]{pf_diag_summary()}}.
}
}
\author{
Edward Lavender
}
