% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pf_backward_sampler.R
\name{pf_backward_sampler}
\alias{pf_backward_sampler}
\title{PF: run the backward pass}
\usage{
pf_backward_sampler(
  .history,
  .dens_step = dstep,
  ...,
  .save_history = FALSE,
  .write_history = NULL,
  .cl = NULL,
  .cl_varlist = NULL,
  .cl_chunks = TRUE,
  .verbose = TRUE
)
}
\arguments{
\item{.history}{Particle samples from the forward simulation, provided either as:
\itemize{
\item A \code{list} of \code{\link{data.table}}s that define cell samples; i.e., the \code{history} element of a \code{\linkS4class{pf}} object.
\item An ordered list of file paths (from \code{\link[=pf_setup_files]{pf_setup_files()}}) that define the directories in which particle samples were written from the forward simulation (as parquet files).
}}

\item{.dens_step, ...}{A function, and associated inputs, used to calculate the probability density of movements between particle samples. \code{.dens_step} must accept the following arguments:
\itemize{
\item \code{.data_now}---a one-row \code{\link{data.table}} that defines the current particle sample (as in \code{.history}).
\item \code{.data_past}---a multi-row \code{\link{data.table}} that defines all particle samples for the previous time step (as in \code{.history}).
\item (optional) \code{...}---additional arguments passed from \code{\link[=pf_backward_sampler]{pf_backward_sampler()}}.
}

Three helper functions are provided:
\itemize{
\item \code{\link[=dstep]{dstep()}} calculates distances between current and past particle samples (via \code{\link[terra:distance]{terra::distance()}}) and translates these into probability densities (via \code{\link[=dtruncgamma]{dtruncgamma()}}). Arguments passed via \code{...} are passed to both \code{\link[terra:distance]{terra::distance()}} (which requires a \code{lonlat} input) and \code{\link[=dtruncgamma]{dtruncgamma()}}.
}}

\item{.save_history}{A logical variable that defines whether or not to save updated particle samples in memory (see \code{\link[=pf_forward]{pf_forward()}}).}

\item{.write_history}{A named list, passed to \code{\link[arrow:write_parquet]{arrow::write_parquet()}}, to write updated particle samples to file (see \code{\link[=pf_forward]{pf_forward()}}).}

\item{.cl, .cl_varlist, .cl_chunks}{(optional) Parallelisation options passed to \code{\link[=cl_lapply]{cl_lapply()}}. Parallelisation is implemented over particles.}

\item{.verbose}{Arguments to monitor function progress (see \code{\link[=pf_forward]{pf_forward()}}).}
}
\value{
The function returns a \code{\linkS4class{pf_path}} object.
}
\description{
These functions implement backwards sampling of particle samples.
}
\section{Overview}{
The forward filter (\code{\link[=pf_forward]{pf_forward()}}) reconstructs the possible locations of an individual at each time step, given the previous time step. Backwards sampling refines the particle filter in two ways:
\itemize{
\item We mitigate the issue of particle degeneracy;
\item We reconstruct entire trajectories;
}
}

\section{Pseudocode}{
In outline, the backward pass (backward sampling) proceeds as follows:
\itemize{
\item Identify the final particle samples;
\item For each particle:
\itemize{
\item Calculate the probability density of movements from that particle to all particles at the previous time step via a \code{.dens_step} function.
\item In practice, this typically requires calculating the distances between particle samples and translating these into densities using the movement model;
}
\item Sample a selected particle at the previous time step, in line with the probability densities linking each pair of particles;
\item Repeat this process until the start of the time series;
\item The process can be implemented in parallel for each particle;
}

Note that the algorithm requires large numbers of calculations. Under default options, calculations are implemented on-the-fly, but it may be more efficient to pre-compute the set of distances between the set of unique particle pairs before implementation of the backward sampler. However, this is not currently implemented.
}

\examples{
#### Set up examples
obs <- dat_obs()
con <- tempdir()
pff_folder <- file.path(tempdir(), "patter", "pf", "forward")
dir.create(pff_folder, recursive = TRUE)
out_pff <- pf_forward(.obs = obs,
                      .bathy = dat_gebco(),
                      .moorings = dat_moorings, .detection_overlaps = dat_overlaps(),
                      .detection_kernels = dat_kernels(),
                      .record = list(save = TRUE, sink = pff_folder))
# D. Define inputs for pf_backward_*()
# * Use a subset of samples for speed
history <- out_pff$history[1:10]
gebco <- dat_gebco()

#### Example (1): Implementation with default options
out_pfb <-
  pf_backward_sampler(history,
                      .dens_step = dstep, lonlat = FALSE,
                      .save_history = TRUE)

#### Example (2): Parallelise default implementation
# Use forking
if (.Platform$OS.type == "unix") {
  out_pfb <-
    pf_backward_sampler(history,
                        .dens_step = dstep, lonlat = FALSE,
                        .save_history = TRUE,
                        .cl = 2L)
}
# Use socket cluster
out_pfb <-
  pf_backward_sampler(history,
                      .dens_step = patter::dstep, lonlat = FALSE,
                      .save_history = TRUE,
                      .cl = parallel::makeCluster(2L),
  )
}
\seealso{
\itemize{
\item The PF (forward simulation) is implemented by \code{\link[=pf_forward]{pf_forward()}};
\item PF is supported by:
\itemize{
\item Setup helpers, namely \code{\link[=pf_setup_files]{pf_setup_files()}};
}
\item The backward pass is implemented by \code{\link[=pf_backward_*]{pf_backward_*()}};
\item Movement paths are built from PF outputs via \code{pf_path()} functions:
\itemize{
\item \code{\link[=pf_path]{pf_path()}} reconstructs paths;
\item \code{\link[=pf_path_pivot]{pf_path_pivot()}} supports path reconstruction;
}
\item To reconstruct maps of space use, see:
\itemize{
\item \code{\link[=pf_coords]{pf_coords()}} to extract particle coordinates;
\item \code{\link[=pf_map_pou]{pf_map_pou()}} for probability-of-use maps;
\item \code{\link[=pf_map_dens]{pf_map_dens()}} for smooth utilisation distributions;
\item \code{\link[=get_hr]{get_hr()}} for home range estimates;
}
}
}
\author{
Edward Lavender
}
