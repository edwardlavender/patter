% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/particle-smoother.R
\name{pf_smoother_two_filter}
\alias{pf_smoother_two_filter}
\alias{set_vmap}
\title{PF: two-filter smoother}
\usage{
set_vmap(.map = NULL, .mobility = NULL, .vmap = NULL, .plot = FALSE, ...)

pf_smoother_two_filter(
  .n_particle = NULL,
  .n_sim = 100L,
  .verbose = getOption("patter.verbose")
)
}
\arguments{
\item{.map, .mobility, .vmap, .plot, ...}{(optional) 'Validity map' arguments for \code{\link[=set_map]{set_map()}}, used for two-dimensional states.
\itemize{
\item \code{.map} is a \code{\link{SpatRaster}} that defines the study area of the simulation (see \code{\link[=pf_filter]{pf_filter()}}).
\item \code{.mobility} is a \code{numeric} value that defines the maximum moveable distance between two time steps (e.g., \code{.timeline[1]} and \code{.timeline[2]} in \code{\link[=pf_filter]{pf_filter()}}).
\item \code{.vmap} is a \code{\link{SpatRaster}} that defines the validity map. This can be supplied, from a previous implementation of \code{\link[=set_vmap]{set_vmap()}} or the internal function \code{\link[=spatVmap]{spatVmap()}}, instead of \code{.map} and \code{.mobility} to avoid re-computation.
\item \code{.plot} is a \code{logical} variable that defines whether or not to plot the map.
\item \code{...} is a placeholder for additional arguments, passed to \code{\link[terra:plot]{terra::plot()}}, if \code{.plot = TRUE}.
}}

\item{.n_particle}{(optional) An \code{integer} that defines the number of particles to smooth.
\itemize{
\item If specified, a sub-sample of \code{.n_particle}s is used.
\item Otherwise, \code{.n_particle = NULL} uses all particles from the filter.
}}

\item{.n_sim}{An \code{integer} that defines the number of Monte Carlo simulations.}

\item{.verbose}{User output control (see \code{\link{patter-progress}} for supported options).}
}
\value{
\itemize{
\item \code{\link[=set_vmap]{set_vmap()}} returns the validity map (a \code{\link{SpatRaster}}), invisibly;
\item \code{\link[=pf_smoother_two_filter]{pf_smoother_two_filter()}} returns a \code{\linkS4class{pf_particles}} object;
}
}
\description{
\code{\link[=pf_smoother_two_filter]{pf_smoother_two_filter()}} function implements the two-filter particle smoother (Fearnhead et al., \href{https://doi.org/10.1093/biomet/asq013}{2010}).
}
\details{
The two-filter smoother smooths particle samples from the particle filter (\code{\link[=pf_filter]{pf_filter()}}). Particles from a forward and backward filter run are required in the \code{Julia} workspace (as defined by \code{\link[=pf_filter]{pf_filter()}}). The backend function \href{https://edwardlavender.github.io/Patter.jl/}{\code{Patter.two_filter_smoother()}} does the work. Essentially, the function runs a simulation backwards in time and re-samples particles in line with the probability density of movements between each combination of states from the backward filter at time \code{t} and states from the forward filter at time \code{t - 1}. The time complexity of the algorithm is thus \eqn{O(TN^2)}. The probability density of movements is evaluated by \href{https://edwardlavender.github.io/Patter.jl/}{\code{Patter.logpdf_step()}} and \href{https://edwardlavender.github.io/Patter.jl/}{\code{Patter.logpdf_move()}}. If individual states are two-dimensional (see \code{\link{StateXY}}), a validity map can be pre-defined in \code{Julia} via \code{\link[=set_vmap]{set_vmap()}} to speed up probability calculations. The validity map is defined as the set of valid (non-\code{NA} or bordering) locations on the \code{.map}, shrunk by \code{.mobility}. Within this region, the probability density of movement between two states can be calculated directly. Otherwise, a Monte Carlo simulation, of \code{.n_sim} iterations, is required to compute the normalisation constant (accounting for movements into inhospitable areas, or beyond the boundaries of the study area).
}
\examples{
#### Set up example
# Set up the particle filter with an example dataset
# (See `?pf_filter()` for the full workflow)
args <- example_setup("pf_smoother_two_filter")
# Run the particle filter forwards
args$.direction <- "forward"
fwd <- do.call(pf_filter, args)
# Run the particle filter backwards
args$.direction <- "backward"
bwd <- do.call(pf_filter, args)

#### Example (1): Implement the smoother with default options
# Run the smoother
# * This uses objects defined by `pf_filter()` in `Julia`
# (set_vmap() is explained below)
smo <- pf_smoother_two_filter()
# The filter returns a `pf_particles`-class object
# (See `?pf_filter()` for examples)
class(smo)
summary(smo)

#### Example (2): Implement the smoother using a validity map
# We can use a validity map b/c `.state` = "StateXY"
args$.state
# To define the validity map, define:
# * `.map`
# * `.mobility`, which we can see here is 750 m:
args$.model_move
# Run the smoother
set_vmap(.map = args$.map, .mobility = 750.0, .plot = TRUE)
smo <- pf_smoother_two_filter()
# Reset `vmap` in `Julia` to run the smoother for other state types
# ... in the same R session:
set_vmap()

#### Example (3): Implement the smoother with a sub-sample of particles
# This is useful for quick tests
set_vmap(.map = args$.map, .mobility = 750.0)
smo <- pf_smoother_two_filter(.n_particle = 50L)

#### Example (4): Adjust the number of MC simulations
# set_vmap(.map = args$.map, .mobility = 750.0)
smo <- pf_smoother_two_filter(.n_sim = 1000L)

#### Example (5): Analyse smoothed particles
# * See `map_*()` functions (e.g., `?map_dens()`) to map utilisation distributions

# Cleanup (reset vmap)
set_vmap()
}
\references{
Fearnhead, P. et al. (2010). A sequential smoothing algorithm with linear computational cost. Biometrika 97, 447â€“464. \url{https://doi.org/10.1093/biomet/asq013}.
}
\seealso{
Particle filters and smoothers sample states (particles) that represent the possible locations of an individual through time, accounting for all data and the individual's movement.
\itemize{
\item To simulate artificial datasets, see \verb{sim_*()} functions (especially \code{\link[=sim_path_walk]{sim_path_walk()}}, \code{\link[=sim_array]{sim_array()}} and \code{\link[=sim_observations]{sim_observations()}}).
\item To assemble real-world datasets for the filter, see \code{\link{assemble}}\verb{_*()} functions.
\item \code{\link[=pf_filter]{pf_filter()}} runs the filter:
\itemize{
\item For state types, see \code{\link{State}};
\item For observation models, see \code{\link{ModelObs}};
\item For movement models, see \code{\link{ModelMove}};
}
\item To run particle smoothing, use \code{\link[=pf_smoother_two_filter]{pf_smoother_two_filter()}}.
\item To map emergent patterns of space use, use a \verb{map_*()} function (such as \code{\link[=map_pou]{map_pou()}}, \code{\link[=map_dens]{map_dens()}} and \code{\link[=map_hr]{map_hr()}}).
}
}
\author{
Edward Lavender
}
