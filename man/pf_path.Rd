% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pf_path.R
\name{pf_path}
\alias{pf_path}
\title{PF: path reconstruction}
\usage{
pf_path(
  .history,
  .bathy = NULL,
  .obs = NULL,
  .cols = NULL,
  .verbose = TRUE,
  .con = "",
  .return = c("long", "wide")
)
}
\arguments{
\item{.history}{Particle samples from the particle filter, provided either as:
\itemize{
\item A \code{list} of \code{\link{data.table}}s that define cell samples; i.e., the \code{history} element of a \code{\linkS4class{pf}} object. This must contain columns that define cell samples at each time step (\code{cell_now}) alongside previous samples (\code{cell_past}).
\item An ordered list of file paths (from \code{\link[=pf_setup_files]{pf_setup_files()}}) that define the directories in which particle samples were written from the forward simulation (as parquet files).
}}

\item{.bathy}{(optional) If \code{.return = "long"}, a bathymetry \code{\link{SpatRaster}} can be supplied to define cell coordinates (see \code{\link[=pf_path_pivot]{pf_path_pivot()}}).}

\item{.obs, .cols}{(optional) If \code{.return = "long"}, \code{.obs} and \code{.cols} are a \code{\link{data.table}} and a \code{character} vector of column names in \code{.obs} to match onto the output (see \code{\link[=pf_path_pivot]{pf_path_pivot()}}).}

\item{.verbose, .con}{Arguments to monitor function progress (see \code{\link[=pf_forward]{pf_forward()}}).}

\item{.return}{A \code{character} that defines the return format:
\itemize{
\item \code{long} specifies a long-format \code{\link{data.table}} that defines path IDs, time steps and associated locations (see \code{\link[=pf_path_pivot]{pf_path_pivot()}}).
\item \code{wide} specifies a wide-format \code{\link{data.table}}, with:
\itemize{
\item one row for each path;
\item one column for each time step (named \code{x1}, \code{x2}, etc.);
}
}}
}
\value{
The function returns a long- or wide-format \code{\link{data.table}} (see \code{.return}).
}
\description{
This function implements the path-reconstruction algorithm.
}
\details{
The path reconstruction algorithm 'chains' sequential particle samples into movement paths. This function evolved from \href{https://edwardlavender.github.io/flapper/reference/pf_simplify.html}{\code{pf_simplify()}} in the \href{https://github.com/edwardlavender/flapper}{\code{flapper}} package. This implementation uses the fast \code{\link[collapse:join]{collapse::join()}} function.
}
\examples{
#### Set up examples

# (A) Define input datasets
acoustics <- dat_acoustics[individual_id == 25, ]
archival <- dat_archival[individual_id == 25, ]
obs <- acs_setup_obs(acoustics, archival, "2 mins", 500)
obs <- obs[1:200, ]
gebco <- dat_gebco()

# (B) Implement AC* algorithm
containers <- acs_setup_detection_containers(gebco, dat_moorings)
overlaps <- acs_setup_detection_overlaps(containers, dat_moorings)
kernels <-
  acs_setup_detection_kernels(dat_moorings,
                              .calc_detection_pr = acs_setup_detection_pr,
                              .bathy = gebco)
ac_folder <- file.path(tempdir(), "ac")
dir.create(ac_folder)
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .save_record = TRUE)

# (C) Implement forward simulation
forward_folder <- file.path(tempdir(), "pf", "forward")
dir.create(forward_folder, recursive = TRUE)
out_pff <- pf_forward(.obs = obs,
                      .record = out_ac$record,
                      .n = 1e3,
                      .kick = pf_kick,
                      .bathy = gebco,
                      .save_history = TRUE,
                      .write_history = list(sink = forward_folder))

# (D) Implement backward pass
backward_folder <- file.path(tempdir(), "pf", "backward")
dir.create(backward_folder, recursive = TRUE)
out_pfb <- pf_backward(pf_setup_files(forward_folder),
                       .save_history = TRUE,
                       .write_history = list(sink = backward_folder))

#### Example (1): Implement pf_path() from `pf` object
p1 <- pf_path(out_pfb$history)

#### Example (2): Implement pf_path from parquet files
p2 <- pf_path(pf_setup_files(backward_folder))
stopifnot(all.equal(p1, p2))

#### Example (3): Include cell coordinates/obs columns
p3 <- pf_path(out_pfb$history, gebco, obs, .cols = "depth")
head(p3)

#### Example (4): Control messages
# Suppress messages
p4 <- pf_path(out_pfb$history, .verbose = FALSE)
# Write messages to log
log.txt <- tempfile(fileext = ".txt")
p4 <- pf_path(out_pfb$history, .con = log.txt)
readLines(log.txt)

#### Example (5): Examine outputs
# Load packages
require(data.table)
require(dtplyr)
require(dplyr, warn.conflicts = FALSE)
# Compute (Euclidean) distances between sequential samples
gebco <- dat_gebco()
p5 <-
  p3 |>
  group_by(path_id) |>
  mutate(
    dist = terra::distance(cbind(cell_x, cell_y),
                           lonlat = FALSE, sequential = TRUE))
max(p5$dist, na.rm = TRUE)
# Visualise example path
terra::plot(gebco)
path_1 <- p5[p5$path_id == 1, ]
s <- seq_len(nrow(path_1))
graphics::arrows(x0 = path_1$cell_x[s], x1 = path_1$cell_x[s + 1],
                 y0 = path_1$cell_y[s], y1 = path_1$cell_y[s + 1],
                 length = 0.02)

#### Example (6): Change output format
p6 <- pf_path(out_pfb$history, .return = "wide")
str(p6)
}
\seealso{
\itemize{
\item \code{\link[=pf_forward]{pf_forward()}} and \code{\link[=pf_backward]{pf_backward()}} implement particle filtering.
\item \code{\link[=pf_pou]{pf_pou()}} maps probability-of-use from particle samples.
\item \code{\link[=pf_path]{pf_path()}} builds movement paths from particle samples and \code{\link[=pf_path_pivot]{pf_path_pivot()}} converts wide-format paths into long-format.
}
}
\author{
Edward Lavender
}
