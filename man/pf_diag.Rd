% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pf-diagnostics.R
\name{pf_diag}
\alias{pf_diag}
\alias{pf_diag_convergence}
\alias{pf_diag_summary}
\title{PF: particle diagnostics}
\usage{
pf_diag_convergence(.sink, ...)

pf_diag_summary(.history, ...)
}
\arguments{
\item{.sink}{For \code{\link[=pf_diag_convergence]{pf_diag_convergence()}}, \code{.sink} specifies particle diagnostics. The following inputs are accepted:
\itemize{
\item A \code{\linkS4class{pf_particles}} object;
\item A \code{character} string that defines the directory containing \code{parquet} files, specified in one of the following formats:
\itemize{
\item \code{{.record$sink}} (as specified in \code{\link[=pf_forward]{pf_forward()}});
\item \verb{\{.record$sink\}/diagnostics/};
}
}}

\item{...}{Additional arguments.
\itemize{
\item In \code{\link[=pf_diag_convergence]{pf_diag_convergence()}}, \code{...} is passed to \code{\link[arrow:open_dataset]{arrow::open_dataset()}}.
\item In \code{\link[=pf_diag_summary]{pf_diag_summary()}}, \code{...} is passed to \code{\link[=.pf_history_dt]{.pf_history_dt()}}. \code{.collect}, if used, is necessarily \code{TRUE} and should not be specified.
}}

\item{.history}{For \code{\link[=pf_diag_summary]{pf_diag_summary()}}, \code{.history} expects particle samples, provided in any format accepted by \code{\link[=.pf_history_dt]{.pf_history_dt()}}.}
}
\value{
\verb{pf_diag_*()} functions return \code{\link{data.table}}s.

\code{\link[=pf_diag_convergence]{pf_diag_convergence()}} returns the \code{diagnostics} \code{\link{data.table}} of a \code{pf_particles-class} object.

\code{\link{pf_diag_summary}} returns a summary \code{\link{data.table}} with the following columns:
\itemize{
\item \code{timestep}---an \code{integer} that defines the time step;
\item \code{n}---an \code{integer} that defines the number of particles;
\item \code{n_u}---an \code{integer} that defines the number of unique location samples (see \code{\link[=.pf_diag_nu]{.pf_diag_nu()}});
\item \code{ess}---a \code{double} that defines the effective sample size (see \code{\link[=.pf_diag_ess]{.pf_diag_ess()}}).
}
}
\description{
These functions collate particle diagnostics from \code{\link[=pf_forward]{pf_forward()}} and \code{\link[=pf_backward_*]{pf_backward_*()}}.
}
\details{
Particle diagnostics are fully described in \code{\link{pf_diag-internal}}.

\code{\link[=pf_diag_convergence]{pf_diag_convergence()}} collates convergence diagnostic outputs from \code{\link[=pf_forward]{pf_forward()}}. If \code{\link[=pf_forward]{pf_forward()}} is implemented with \code{.record$save = TRUE}, the outputted \code{\linkS4class{pf_particles}} object from \code{\link[=pf_forward]{pf_forward()}} includes a pre-compiled \code{\link{data.table}} of diagnostics (see \code{\link[=pf_opt_record]{pf_opt_record()}}). \code{\link[=pf_diag_convergence]{pf_diag_convergence()}} accepts a \code{\linkS4class{pf_particles}} object, but there is really no need for this, as a \code{diagnostics} element is already present in this object. Instead, \code{\link[=pf_diag_convergence]{pf_diag_convergence()}} is primarily designed to collate particle diagnostics on file. \code{\link[=pf_forward]{pf_forward()}} writes particle diagnostics to \code{{.record$sink}/diagnostics} (see \code{\link[=pf_opt_record]{pf_opt_record()}}). You can supply \code{{.record$sink}} or \verb{\{.record$sink\}/diagnostics/} to this function. The individual \code{\link{data.table}}s are collated to match the form in which they are provided by \code{\link[=pf_forward]{pf_forward()}} when \code{.record$save = TRUE}.

\code{\link[=pf_diag_summary]{pf_diag_summary()}} summarises particle diagnostics directly from (accepted) particle samples. This can be used for \code{\link[=pf_forward]{pf_forward()}} or \code{\link[=pf_backward_*]{pf_backward_*()}}.
}
\examples{
#### Example (1): Examine convergence diagnostics from `pf_forward()`

# For outputs stored in memory, extract the `diagnostics` element
dat_pff()$diagnostics

# `pf_diag_convergence()` also works but is unnecessary
pf_diag_convergence(dat_pff())

# For outputs stored on file, use `pf_diag_convergence()`
pff_folder <- dat_pff_src(.folder = NULL)
pf_diag_convergence(pff_folder)
pf_diag_convergence(file.path(pff_folder, "diagnostics"))

# Outputs are identical
stopifnot(isTRUE(all.equal(
  dat_pff()$diagnostics,
  pf_diag_convergence(pff_folder)
)))

#### Example (2): Summarise diagnostics for accepted particle samples

## (A) Use particle samples from pf_forward() or pf_backward_*()
pf_diag_summary(.history = out_pff())
pf_diag_summary(.history = out_pfbk())
# pf_diag_summary(.history = out_pfbs())

## (B) Use particle samples in memory or on file
# Particles can be provided in any format accepted by `?.pf_history_dt()`
d1 <- pf_diag_summary(.history = out_pfbk())
d2 <- pf_diag_summary(.history = out_pfbk()$history)
d3 <- pf_diag_summary(.history = dat_pfbk_src())
d4 <- pf_diag_summary(.history = pf_files(dat_pfbk_src()))
stopifnot(isTRUE(all.equal(d1, d2)))
stopifnot(isTRUE(all.equal(d1, d3)))
stopifnot(isTRUE(all.equal(d1, d4)))

## (C) Examine trends in particle diagnostics

# Collate particle diagnostics
diag_f <- pf_diag_summary(dat_pff())
diag_k <- pf_diag_summary(dat_pfbk())
diag_s <- pf_diag_summary(dat_pfbs())

# Plot diagnostic time series
pf_plot_diag_ts <- function(.f, .k, .s, .metric = c("n", "nu", "ess"), ...){
  # Define base plot
  .metric <- match.arg(metric)
  ylim <- range(c(.f[[.metric]], .k[[.metric]], .s[[.metric]]))
  plot(.f$timestep, .f[[.metric]],
       xlab = "time step", ylab = .metric,
       ylim = ylim, type = "n", ...)
  # Add diagnostics for each algorithm
  add_diag <- function(x, y, col) {
    if (!all(is.na(y))) {
      ct <- col2rgb(col) / 255
      ct <- rgb(ct[1], ct[2], ct[3], alpha = 0.25)
      lines(loess.smooth(x, y), lwd = 2, col = ct)
      points(x, y, cex = 0.5, col = col)
    }
    invisible(NULL)
  }
  add_diag(.f$timestep, .f[[.metric]], col = "red")
  add_diag(.k$timestep, .k[[.metric]], col = "orange")
  add_diag(.s$timestep, .s[[.metric]], col = "darkgreen")
}

# Plot time series
pp <- par(mfrow = c(1, 3))
cl_lapply(c("n", "nu", "ess"), function(.metric) {
  pf_plot_diag_ts(.f = diag_f,
                  .k = diag_k,
                  .s = diag_s,
                  .metric = .metric)
})
par(pp)
}
