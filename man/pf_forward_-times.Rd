% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pf_forward.R
\name{pf_forward_*}
\alias{pf_forward_*}
\title{PF: run the forward simulation}
\description{
\code{\link{patter}} provides two options for the forward simulation of possible locations.
\itemize{
\item \strong{Two-step implementation.} In the two-step implementation, an AC-branch algorithm (e.g., \code{\link[=acs]{acs()}}, \code{\link[=dc]{dc()}}) is used to reconstruct the possible locations of an individual over a grid. The resultant surfaces are passed to \code{\link[=pf_forward_1]{pf_forward_1()}}, which uses a particle filtering algorithm to refine the set of possible locations for the individual through time. This is the original implementation in both \href{https://github.com/edwardlavender/flapper}{\code{flapper}} and \code{\link{patter}}. A benefit of this approach is that the deterministic and stochastic parts of the algorithm are separated, which facilitates diagnosing the causes of any convergence failures (e.g., \code{\link[=acs]{acs()}} failures suggest overly restrictive detection probability or mobility parameters whereas \code{\link[=pf_forward_1]{pf_forward_1()}} failures suggest incorrect mobility parameters or insufficient sampling). \code{\link[=pf_forward_1]{pf_forward_1()}} is also fast because pre-calculated weights are used in calculations. However, with high-resolution and/or large grids, this approach may become prohibitively expensive because \code{\link[=acs]{acs()}} and \code{\link[=dc]{dc()}} are implemented over the entire grid, whereas in actuality we only require AC-branch weights at sampled (particle) locations.
\item \strong{Integrated implementation.} In the integrated implementation, AC-branch and PF-branch algorithms are implemented via \code{\link[=pf_forward_2]{pf_forward_2()}}. In this approach, AC-branch calculations are only implemented at particle locations, which is much more efficient. \strong{This is generally the recommended approach.}
}
}
\seealso{
\itemize{
\item The PF (forward simulation) is implemented by \code{\link[=pf_forward_*]{pf_forward_*()}}:
\itemize{
\item \code{\link[=pf_forward_1]{pf_forward_1()}} refines AC-branch algorithm (\code{\link[=acs]{acs()}} and \code{\link[=dc]{dc()}}) outputs using PF;
\item \code{\link[=pf_forward_2]{pf_forward_2()}} is an integrated implementation that couples AC- and PF-branch algorithms internally;
}
\item PF is supported by:
\itemize{
\item Setup helpers, namely \code{\link[=pf_setup_files]{pf_setup_files()}};
\item Template movement models, namely \code{\link[=pf_kick]{pf_kick()}};
}
\item The backward pass is implemented by \code{\link[=pf_backward]{pf_backward()}};
\item Movement paths are built from PF outputs via \code{pf_path()} functions:
\itemize{
\item \code{\link[=pf_path]{pf_path()}} reconstructs paths;
\item \code{\link[=pf_path_pivot]{pf_path_pivot()}} supports path reconstruction;
}
\item To reconstruct maps of space use, see:
\itemize{
\item \code{\link[=pf_coords]{pf_coords()}} to extract particle coordinates;
\item \code{\link[=pf_map_pou]{pf_map_pou()}} for probability-of-use maps;
\item \code{\link[=pf_map_dens]{pf_map_dens()}} for smooth utilisation distributions;
\item \code{\link[=get_hr]{get_hr()}} for home range estimates;
}
}
}
