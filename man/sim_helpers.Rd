% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sims.R
\name{sim_helpers}
\alias{sim_helpers}
\alias{ssf}
\alias{ssv}
\alias{rbern}
\alias{dbern}
\alias{rdet}
\alias{ddetlogistic}
\alias{ddet}
\alias{rtruncgamma}
\alias{dtruncgamma}
\alias{rwn}
\alias{rlen}
\alias{rangrw}
\alias{rangcrw}
\alias{rstep}
\alias{cstep}
\alias{dstep}
\alias{clen}
\alias{cang}
\title{Simulation: distribution functions}
\usage{
ssf()

ssv()

rbern(.n, .prob)

dbern(.x, .prob)

rdet(.data, .ddet = ddet, ...)

ddetlogistic(.x, .alpha = 4, .beta = -0.01, .gamma = 750)

ddet(.data, .ddetx = ddetlogistic, ...)

rtruncgamma(.n = 1L, .shape = 15, .scale = 15, .mobility = 500, ...)

dtruncgamma(.x, .shape = 15, .scale = 15, .mobility = 500, ...)

rwn(.n = 1L, .mu = 0, .rho = 0, .sd = 1, ...)

rlen(.n = 1L, .prior = NULL, .t = NULL, ...)

rangrw(.n = 1L, .prior = NULL, .t = NULL, ...)

rangcrw(.n = 1L, .prior = NULL, .t = NULL, ...)

rstep(
  .xy0,
  .xy1 = matrix(NA, nrow = fnrow(.xy0), ncol = 2L),
  .rlen = rlen,
  .rang = rangrw,
  ...,
  .lonlat
)

cstep(
  .xy0,
  .xy1 = matrix(NA, nrow = fnrow(.xy0), ncol = 2L),
  .len,
  .ang,
  .lonlat
)

dstep(
  .xy0,
  .xy1,
  .clen = clen,
  .cang,
  .dlen = dtruncgamma,
  .dang,
  ...,
  .lonlat
)

clen(.xy0, .xy1, .lonlat)

cang(.xy0, .xy1, .lonlat)
}
\arguments{
\item{.n, .x}{Arguments for distribution functions (\code{\link[=rbern]{rbern()}}, \code{\link[=dbern]{dbern()}}, \code{\link[=rtruncgamma]{rtruncgamma()}} and \code{\link[=dtruncgamma]{dtruncgamma()}}):
\itemize{
\item \code{.n} is an \code{integer} that defines the number of simulated outcome(s);
\item \code{.x} is a \code{numeric} vector that simulated outcome(s);
}}

\item{.prob}{Additional argument(s) for \code{\link[=rbern]{rbern()}} and \code{\link[=dbern]{dbern()}}:
\itemize{
\item \code{.prob} is \code{numeric} vector of probabilities.
}}

\item{.data, .ddet}{Arguments for \code{\link[=rdet]{rdet()}}.
\itemize{
\item \code{.data} is a \code{\link{data.table}}.
\item \code{.ddet} is a \code{function} evaluates the probability of a detection;
}

For \code{\link[=rdet]{rdet()}}, \code{.ddet} must accept the \code{.data} \code{\link{data.table}} as its first argument and evaluate the probability of a detection accordingly. \code{\link[=rbern]{rbern()}} then simulates detection(s). For \verb{.ddet =} \code{\link{ddet}}, \code{.data} must include a \code{dist} column that defines the distances between transmission locations and receivers. In \code{\link[=ddet]{ddet()}}, \code{.data$dist} is passed to \code{\link[=ddetlogistic]{ddetlogistic()}} to calculate detection probabilities (see Details).}

\item{...}{Arguments passed to/from functions.
\itemize{
\item \code{\link[=ssf]{ssf()}}, \code{\link[=ssv]{ssv()}}: not used;
\item \code{\link[=rbern]{rbern()}}, \code{\link[=ddet]{ddet()}}: not used;
\item \code{\link[=rdet]{rdet()}}, \code{\link[=ddet]{ddet()}}: passed to \code{.ddet} ( = \code{\link[=ddet]{ddet()}}, wrapping \code{\link[=ddetlogistic]{ddetlogistic()}});
\item \code{\link[=ddetlogistic]{ddetlogistic()}}: not used;
\item \code{\link[=rtruncgamma]{rtruncgamma()}}, \code{\link[=dtruncgamma]{dtruncgamma()}}: silently ignored;
\item \code{\link[=rwn]{rwn()}}: silently ignored;
\item \code{\link[=rlen]{rlen()}}: passed to \code{\link[=rtruncgamma]{rtruncgamma()}};
\item \code{\link[=rangrw]{rangrw()}}: passed to \code{\link[=rwn]{rwn()}};
\item \code{\link[=rangcrw]{rangcrw()}}: passed to \code{\link[=rwn]{rwn()}}, excluding \code{.mu};
\item \code{\link[=rstep]{rstep()}}: passed to \code{.rlen} and \code{.rang};
\item \code{\link[=dstep]{dstep()}}: not used;
\item \code{\link[=dstep]{dstep()}}: passed to \code{.dlen} and \code{.cang};
\item \code{\link[=clen]{clen()}}: not used;
\item \code{\link[=cang]{cang()}}: not used;
}}

\item{.alpha, .beta, .gamma}{Additional arguments for \code{\link[=ddetlogistic]{ddetlogistic()}} (see Details).
\itemize{
\item \code{.alpha} is a \code{numeric} value for the intercept, on the scale of the logistic function.
\item \code{.beta} is a \code{numeric} value for the gradient, on the scale of the logistic function.
\item \code{.gamma} is a \code{numeric} value for the receiver detection range.
}}

\item{.ddetx}{Additional arguments for \code{\link[=ddet]{ddet()}}.
\itemize{
\item \code{.ddetx} is a function that evaluates the probability density of detections from a \code{numeric} vector (e.g,. of distances).
}}

\item{.shape, .scale, .mobility}{Additional arguments for \code{\link[=rtruncgamma]{rtruncgamma()}} and \code{\link[=dtruncgamma]{dtruncgamma()}}:
\itemize{
\item \code{.shape} is a \code{numeric} value that defines the shape parameter of a Gamma distribution (see \code{\link[stats:GammaDist]{stats::rgamma()}}).
\item \code{.scale} is a \code{numeric} value that defines the scale parameter of a Gamma distribution (see \code{\link[stats:GammaDist]{stats::rgamma()}}).
\item \code{.mobility} is a \code{numeric} value that defines the maximum possible value (step length) (see \code{truncdist::rtrunc()}).
}}

\item{.mu, .rho, .sd}{Arguments for \code{\link[=rwn]{rwn()}} for the simulation of turning angles, passed to the \code{mu}, \code{rho} and \code{sd} arguments of \code{\link[circular:wrappednormal]{circular::rwrappednormal()}}.}

\item{.prior, .t}{Additional arguments for \code{\link[=rlen]{rlen()}}, \code{\link[=rangrw]{rangrw()}} and \code{\link[=rangcrw]{rangcrw()}}, as used in top-level functions (i.e., \code{\link[=sim_path_walk]{sim_path_walk()}}):
\itemize{
\item \code{.n}---an \code{integer} that defines the number of simulated outcome(s);
\item \code{.prior}---a \code{numeric} vector that defines the simulated value(s) from the previous time step;
\item \code{.t}---an \code{integer} that defines the time step;
\item \code{...}---additional arguments, if needed;
}}

\item{.xy0, .xy1, .lonlat}{Shared arguments for \verb{*step()} functions and \verb{c*()} functions.
\itemize{
\item \code{.xy0}---a two-column object (\code{\link{matrix}}, \code{\link{data.frame}}, \code{\link{data.table}}) of (x, y) coordinates;
\item \code{.xy1}---a two-column object of (x, y) coordinates;
\item \code{.lonlat}---a \code{logical} variable that defines whether or not coordinates are in longitude/latitude or planar coordinates;
}}

\item{.rlen, .rang}{Additional arguments for \code{\link[=rstep]{rstep()}}.
\itemize{
\item \code{.rlen}---A \code{function} that simulates step lengths (metres);
\item \code{.rang}---A \code{function} that simulates turning angles (degrees);
}

The first argument to both functions must be the number of values to simulate. Other arguments are passed via \code{...}.}

\item{.len, .ang}{Additional arguments for \code{\link[=cstep]{cstep()}}.
\itemize{
\item \code{.len}---A \code{numeric} vector of lengths (e.g., from \code{\link[=rlen]{rlen()}});
\item \code{.ang}---A \code{numeric} vector of turning angles (e.g., from \code{\link[=rangrw]{rangrw()}});
}}

\item{.clen, .cang, .dlen, .dang}{Additional arguments for \code{\link[=dstep]{dstep()}}.
\itemize{
\item \code{.clen}---A \code{function} that calculates step lengths between coordinate pairs, such as \code{\link[=clen]{clen()}};
\item \code{.cang}---(ignored);
\item \code{.dlen}---A \code{function} that calculates the probability density of step lengths, such as \code{\link[=dtruncgamma]{dtruncgamma()}};
\item \code{.dang}---(ignored);
}

\code{.cang} and \code{.dang} arguments are not yet implemented and must be \code{\link{missing}}.}
}
\description{
These convenience functions support the generation of animal movement paths and observations in \emph{de novo} simulations (\verb{sim_*()} functions) and simulation-based reconstructions of movement paths (\code{\link[=pf_forward]{pf_forward()}} and \code{\link[=pf_backward_sampler]{pf_backward_sampler()}}).
\itemize{
\item \verb{ss*()} functions set seeds;
\item \verb{r*()} functions simulate random variates;
\item \verb{c*()} functions calculate outcomes from random-variate inputs;
\item \verb{d*()} functions return densities;
}

\verb{r*()} and \verb{c*()} functions are used in \emph{de novo} simulations (via \verb{sim_*()} functions such as \code{\link[=sim_path_walk]{sim_path_walk()}} and \code{\link[=sim_detections]{sim_detections()}}) and the forward simulation-based reconstruction of movement paths (in \code{\link[=pf_forward]{pf_forward()}}).

\verb{d*()} functions are primarily used in the simulation-based reconstruction of movement paths as part of the backward sampler via \code{\link[=pf_backward_sampler]{pf_backward_sampler()}}.
}
\section{Reproducibility}{
\itemize{
\item \code{\link[=ssf]{ssf()}} sets a fixed seed (wrapping \code{set.seed(123L)});
\item \code{\link[=ssv]{ssv()}} sets a time-varying seed (wrapping \code{set.seed(as.integer(as.Date(Sys.time())))}) and is primarily intended for package testing;
}
}

\section{Detections}{
\subsection{Distribution functions}{
\itemize{
\item \verb{*bern()} functions are distribution functions for the Bernoulli distribution:
\itemize{
\item \code{\link[=rbern]{rbern()}} wraps \code{\link[stats:Binomial]{stats::rbinom()}} and simulates values from a Bernoulli distribution;
\item \code{\link[=dbern]{dbern()}} wraps \code{\link[stats:Binomial]{stats::dbinom()}} and evaluates the probability density of simulated values;
}
}
}

\subsection{Wrappers}{
\itemize{
\item \verb{*det()} functions wrap \verb{*bern()} functions for the simulation of detections at receivers:
\itemize{
\item \code{\link[=rdet]{rdet()}} wraps \code{\link[=ddet]{ddet()}} and \code{\link[=rbern]{rbern()}} to simulate detections;
\item \code{\link[=ddet]{ddet()}} wraps \code{\link[=ddetlogistic]{ddetlogistic()}} to calculate the probability density of detections;
\item \code{\link[=ddetlogistic]{ddetlogistic()}} effectively wraps \code{\link[=dbern]{dbern()}} and evaluates the probability density of a detection event (at receiver \eqn{k} at time \eqn{t}), given a transmission from location \eqn{\bold{s} = (x, y)} (i.e., \eqn{p(\text{ev}[k, t] | \bold{s})}), as a truncated \eqn{\text{logistic}} function of the distance (\code{.x}) between the transmission (\bold{s}) and receiver (\bold{r}) locations, i.e.,
\deqn{
p(\text{ev}[k, t] | \bold{s}) =  \text{Bernoulli}(\text{.prob}) \\
\text{.prob} =
 \begin{cases}
   \text{logistic}(\text{.alpha} + \text{.beta} \times .x) & \text{if } .x < \text{.gamma} \\
   0 & \text{otherwise}
 \end{cases}
}
where \eqn{\text{logistic}(x) = 1 + e^{-x}}; \code{.alpha}, and \code{.beta} are parameters; and \code{.gamma} is the receiver's detection range.
}
}
}
}

\section{Movement}{
\subsection{Distribution functions}{
\itemize{
\item \verb{*truncgamma()} functions are distribution functions for the truncated Gamma distribution:
\itemize{
\item \code{\link[=rtruncgamma]{rtruncgamma()}} simulates values from a truncated Gamma distribution with a \code{.mobility} parameter that truncates the right-hand side of the distribution;
\item \code{\link[=dtruncgamma]{dtruncgamma()}} returns the densit(ies) of specified values(s);
}
\item \verb{*wn()} functions are distribution functions for the wrapped normal distribution:
\itemize{
\item \code{\link[=rwn]{rwn()}} wraps \code{\link[circular:wrappednormal]{circular::rwrappednormal()}} and simulates turning angle(s).
\item \code{dwn()} is not currently implemented.
}
}
}

\subsection{Step length and turning angle wrappers}{
\itemize{
\item \verb{*len()} functions wrap \verb{*truncgamma()} for the simulation of movement step lengths:
\itemize{
\item \code{\link[=rlen]{rlen()}} wraps \code{\link[=rtruncgamma]{rtruncgamma()}};
\item \code{dlen()} is not currently implemented;
\item \code{\link[=clen]{clen()}} calculates the distance (step length) between coordinate pair(s) for \code{\link[=dstep]{dstep()}};
}
\item \verb{*ang*()} functions wrap \verb{*rw()} for turning angles:
\itemize{
\item \code{\link[=rangrw]{rangrw()}} wraps \code{\link[=rwn]{rwn()}} and is used to simulate random-walk turning angles;
\item \code{\link[=rangcrw]{rangcrw()}} wraps \code{\link[=rwn]{rwn()}} with \code{.mu = .prior} (if specified) and is used to simulate correlated random walks;
\item \code{dangrw} and \code{dangcrw()} are not currently implemented;
\item \code{\link[=cang]{cang()}} calculates turning angles between coordinate pairs;
}
}
}

\subsection{Step wrappers}{
\itemize{
\item \code{\link[=rstep]{rstep()}} wraps \verb{.rlen =} \code{\link{rlen}} and \verb{.rang =} \code{\link{rangrw}} to simulate coordinates (via \code{\link[=cstep]{cstep()}});
\item \code{\link[=cstep]{cstep()}} used (simulated) step lengths and turning angles to calculate coordinates;
\item \code{\link[=dstep]{dstep()}} evaluates the probability density of movements between locations. At the time of writing, this only evaluates the density of step lengths and is only suitable for random walks;
}
}
}

\section{Properties}{
\itemize{
\item All angles are in degrees (-180, 180):
\itemize{
\item North = 0 degrees
\item East = 90 degrees
\item South = 180 degrees
\item West = -90 degrees
}
}
}

\section{Warnings}{
\itemize{
\item It is possible to simulate correlated random walks in \code{\link[=sim_path_walk]{sim_path_walk()}} but at the time of writing this is not supported \code{\link[=pf_forward]{pf_forward()}}. Probability density functions for correlated random walks, as required for \code{\link[=pf_forward]{pf_forward()}} and \code{\link[=pf_backward_sampler]{pf_backward_sampler()}} (e.g., \code{dangrw()}, \code{dangcrw()}) are not implemented.
}
}

\examples{
require(data.table)
require(circular)
require(terra)
require(geosphere)
require(testthat)


#### --------------------------------------------------
# Detection examples

#### Bernoulli distribution random generation
rbern(1, 1)
rbern(10, 0.5)

#### Bernoulli distribution densities
dbern(1, 1)
dbern(c(1, 1), 0.5)
dbern(c(1, 1), 0.25)

#### Random generation of detections
# Define a data.table of distances
dists <- data.table(individual_id = 1L,
                    receiver_id = 1L,
                    dist = runif(100, 0, 1000))
# Simulate detections using default arguments
rdet(.data = data.table(dists))[]
# Customise arguments passed to .ddet -> ddet() -> ddetlogistic()
rdet(.data = dists, .gamma = 10)[]
# Customise .ddet model
# * See below.

#### Probability density of detections
# Use ddetlogistic() to evaluate densities via a logistic function of distances
ddetlogistic(1:10)
ddetlogistic(1:10, .gamma = 500)
# Use ddet() wrapper function
ddet(dists)
ddet(dists, .gamma = 500)
# Customise .ddetx model
ddetlinear <- function(.x, .alpha = 1, .beta = -0.002, .gamma = 500) {
  pr <- .alpha + .beta * .x
  pr <- pmax(pr, 0)
  pr <- pmin(pr, 1)
  pr[.x > .gamma] <- 0
  # pr <- dbern(.x = 1L, size = 1L, prob = pr)
  pr
}
plot(1:500, ddetlinear(1:500),
     xlim = c(0, 500), ylim = c(0, 1),
     xlab = "Detection probability", ylab = "Distance (m)",
     type = "l")
ddet(dists, .ddetx = ddetlinear)
# Use ddetlinear in rdet()
det <- rdet(.data = dists, .ddetx = ddetlinear)
points(det$dist, det$detection)


#### --------------------------------------------------
# Movement examples

ssv()
n <- 1e5L

#### Truncated gamma random generation
# Simulate values from truncated gamma with different parameters
hist(rtruncgamma(n))
hist(rtruncgamma(n, .shape = 1.5, .scale = 100))
hist(rtruncgamma(n, .shape = 1.5, .scale = 100, .mobility = 50))

#### Truncated gamma densities
# Calculate densities from truncated gamma with different parameters
dtruncgamma(10, .shape = 1.5, .scale = 100)
dtruncgamma(10, .shape = 1.5, .scale = 100, .mobility = 50)
# Visualise density curve with dtruncgamma()
curve(dtruncgamma, 0, 500)
# Show correspondence between rtruncgamma() and dtruncgamma()
hist(rtruncgamma(n), freq = FALSE)
lines(1:500, dtruncgamma(1:500))

#### Wrapped normal random generation
# Simulate values from wrapped normal distribution
hist(rwn(n))
hist(rwn(n, .mu = degrees(0), .rho = 0.7))
hist(rwn(n, .mu = degrees(0), .sd = 100))

#### Random generation of step lengths & turning angles
# Simulate step lengths with different parameters
hist(rlen(n))
hist(rlen(n, .shape = 50))
# Simulate random-walk angles
hist(rangrw(n))
hist(rangrw(n, .mu = degrees(10), .rho = 0.99))
# Simulate correlated random-walk angles
a1 <- rangrw(n)
a2 <- rangcrw(n, .prior = a1, .rho = 0.999)
cor.circular(degrees(a1), degrees(a2))

#### Calculate lengths and angles
# Simulate two coordinate matrices
m0  <- cbind(runif(n), runif(n))
m1  <- rstep(m0, .lonlat = FALSE)
# Calculate step lengths and turning angles
len <- clen(m0, m1, .lonlat = FALSE)
ang <- cang(m0, m1, .lonlat = FALSE)
# Show that cstep(m0, m1) = m1
expect_equal(
  m1,
  cstep(m0, m1,
        .len = len,
        .ang = ang,
        .lonlat = FALSE)
  )
# Show alignment between simulated lengths and probability densities
hist(len, freq = FALSE)
points(len,
       dstep(m0, m1, .lonlat = FALSE) + rnorm(n, 0, 0.0001),
       col = "red", pch = ".")

#### Compare lonlat versus planar coordinates
# Simulate coordinates
gebco <- dat_gebco()
m0    <- terra::spatSample(gebco, size = terra::ncell(gebco),
                           xy = TRUE, values = FALSE) |> unname()
m1    <- rstep(m0, .lonlat = FALSE)
m0_ll <- terra::project(m0, from = terra::crs(gebco), to = "EPSG:4326")
m1_ll <- terra::project(m1, from = terra::crs(gebco), to = "EPSG:4326")
# Validate length calculations
len    <- clen(m0, m1, .lonlat = FALSE)
len_ll <- clen(m0_ll, m1_ll, .lonlat = TRUE)
head(cbind(len, len_ll))
max(abs(len - len_ll))
expect_equal(len, len_ll, tolerance = 0.1)
# Validate angle calculations
ang    <- cang(m0, m1, .lonlat = FALSE)
ang_ll <- cang(m0_ll, m1_ll, .lonlat = TRUE)
head(cbind(ang, ang_ll))
max(abs((ang - ang_ll + 180) \%\% 360 - 180))
expect_equal(ang, ang_ll, tolerance = 0.1)
# Validate cstep()
expect_equal(
  m1,
  cstep(m0, .len = len, .ang = ang, .lonlat = FALSE)
)
expect_equal(
  m1_ll,
  cstep(m0_ll, .len = len_ll, .ang = ang_ll, .lonlat = TRUE)
)
# Validate dstep()
hist(len, freq = FALSE)
points(len, dstep(m0, m1, .lonlat = FALSE))
hist(len_ll, freq = FALSE)
points(len_ll, dstep(m0_ll, m1_ll, .lonlat = TRUE))

#### --------------------------------------------------
# Understanding movement angles

#### TLDR
# 0 = North
# 90 = East
# 180 = South
# -90 (or 270) = West

#### Define planar and lon/lat grids
g   <- dat_gebco()
gll <- project(g, "EPSG:4326")

#### Define lon/lat coordinates
centre <- cbind(-5.614005, 56.43463)
north  <- cstep(centre, .len = 2e5, .ang = 0, .lonlat = TRUE)
east   <- cstep(centre, .len = 2e5, .ang = 90, .lonlat = TRUE)
south  <- cstep(centre, .len = 2e5, .ang = 180, .lonlat = TRUE)
west   <- cstep(centre, .len = 2e5, .ang = -90, .lonlat = TRUE)

#### Define planar coordinates
proj_utm <- function(.xy) {
  terra::project(.xy, from = crs(gll), to = crs(g))
}
centre_utm <- proj_utm(centre)
north_utm  <- proj_utm(north)
east_utm   <- proj_utm(east)
south_utm  <- proj_utm(south)
west_utm   <- proj_utm(west)

#### geosphere::bearing() returns initial bearings [-180, 180]
bearing(centre, north) # 0
bearing(centre, east)  # 90
bearing(centre, south) # 180
bearing(centre, west)  # -90
# cf. (geosphere::bearingRhumb() returns rhumbline bearings [0, 360])
bearingRhumb(centre, north) # 0
bearingRhumb(centre, east)  # ~90
bearingRhumb(centre, south) # 180
bearingRhumb(centre, west)  # ~270

#### cang(..., .lonlat = TRUE) wraps geosphere::bearing()
cang(centre, north, .lonlat = TRUE) # 0
cang(centre, east, .lonlat = TRUE)  # 90
cang(centre, south, .lonlat = TRUE) # 180
cang(centre, west, .lonlat = TRUE)  # -90

#### cang(..., .lonlat = FALSE) returns [-180, 180] to match geosphere::bearing()
cang(centre_utm, north_utm, .lonlat = FALSE) # ~0
cang(centre_utm, east_utm, .lonlat = FALSE)  # ~90
cang(centre_utm, south_utm, .lonlat = FALSE) # ~180
cang(centre_utm, west_utm, .lonlat = FALSE)  # ~ -90

#### Visual comparison
# Demonstrate (consistent) definition of angles on lon/lat and planar grids
compare <- function(.ang = 0) {
  pp <- par(mfrow = c(1, 2))
  on.exit(par(pp))
  # Plot lon/lat grid and add centre + new coord
  terra::plot(gll)
  points(centre)
  new <- cstep(centre, .len = 2e3, .ang = .ang, .lonlat = TRUE)
  points(new, col = "red")
  # Plot UTM grid and add centre + new coord
  terra::plot(g)
  points(centre_utm)
  new <- cstep(centre_utm, .len = 2e3, .ang = .ang, .lonlat = FALSE)
  points(new, col = "red")
  invisible()
}
# Compare north
compare(0)
# Compare east
compare(90)
# Compare South
compare(180)
# Compare West
compare(-90)
compare(270)
}
\seealso{
\itemize{
\item \verb{sim_*} functions implement \emph{de novo} simulation of movements and observations:
\itemize{
\item \code{\link{sim_helpers}} are convenience functions for simulations;
\item \code{\link[=sim_array]{sim_array()}} simulates acoustic array(s);
\item \code{\link[=sim_path_walk]{sim_path_walk()}} simulates movement path(s) via a walk model;
\item \code{\link[=sim_detections]{sim_detections()}} simulates detection(s) at receivers;
}
\item \code{\link[=pf_forward]{pf_forward()}} implements forward simulation-based reconstruction of movement paths;
\item \code{\link[=pf_backward_sampler]{pf_backward_sampler()}} implements backward simulation-based reconstruction of movement paths;
\item \code{\link{skill}} functions compared simulated and reconstructed patterns to evaluate model skill;
}
}
\author{
Edward Lavender
}
