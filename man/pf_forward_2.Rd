% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pf_forward_2.R
\name{pf_forward_2}
\alias{pf_forward_2}
\title{PF: run the forward simulation}
\usage{
pf_forward_2(
  .obs,
  .origin = NULL,
  .bathy,
  .lonlat = FALSE,
  .moorings = NULL,
  .detection_overlaps = NULL,
  .detection_kernels = NULL,
  .update_ac = NULL,
  .kick,
  ...,
  .n = 100L,
  .save_history = FALSE,
  .write_history = NULL,
  .progress = TRUE,
  .verbose = TRUE,
  .txt = ""
)
}
\arguments{
\item{.obs}{A \code{\link{data.table}} that defines the time series of observations for a selected individual (e.g., from \code{\link[=acs_setup_obs]{acs_setup_obs()}}). At a minimum, this must contain the following columns:
\itemize{
\item \code{timestep}--an \code{integer} that defines the time step;
\item Columns required by the AC algorithm, if implemented; i.e.:
\itemize{
\item \code{date}---a \code{character} column that defines the date;
\item \code{detection}---an \code{integer} column that uniquely defines each detection;
\item \code{detection_id}---an \code{integer} column that distinguishes the time steps at which detections were (1) or were not (0) recorded;
\item \code{receiver_id}---a \code{list} column that defines the receiver(s) that recorded detections at each time step;
\item \code{receiver_id_next}---a \code{list} column that define receiver(s) that recorded the next detection(s);
\item \code{buffer_future_incl_gamma}---a numeric column that defines the maximum distance of the individual from \code{receiver_id_next};
}
\item Columns required by \code{.update_ac};
\item Columns required by \code{.kick};
}}

\item{.origin}{(optional) A \code{\link{data.table}} that defines a set of 'quadrature points' from which the first \code{.n} particles are sampled (with replacement, according to their weights). If supplied, \code{.origin} must include three columns:
\itemize{
\item \code{cell_now}---an \code{integer} vector that defines the cell ID (on \code{.bathy});
\item \code{x_now}---a \code{numeric} vector that defines the x coordinates;
\item \code{y_now}---a \code{numeric} vector that defines y coordinates;
}

If un-supplied, quadrature points are sampled from within acoustic containers using \code{.bathy} (if applicable) or from \code{.bathy} at large (see Details).}

\item{.bathy}{A \code{\link{SpatRaster}} over the region of interest. This is used to:
\itemize{
\item Coerce receiver coordinates onto the grid, if necessary (see \code{.moorings});
\item Define quadrature points, if necessary (see \code{.origin});
\item Filter particle samples from inhospitable habitats (define by \code{NA}), if necessary;
\item (optional) Define or update particle weights (via \code{.update_ac});
\item (optional) Simulate movement (via \code{.kick});
\item Coerce simulated positions onto the grid;
}}

\item{.lonlat}{A \code{logical} variable that defines whether or not spatial inputs (namely \code{.bathy} and \code{.moorings} coordinates) are defined in terms of longitude/latitude or a planar coordinate reference system.}

\item{.moorings, .detection_overlaps, .detection_kernels}{(optional) AC* arguments. These arguments are used to implement the AC* algorithm on the fly.
\itemize{
\item \code{moorings} is a \code{\link{data.table}} that defines receiver deployments. This must contain the following columns:
\itemize{
\item \code{receiver_id}---an \code{integer} vector of receiver IDs;
\item \code{receiver_easting} and \code{receiver_northing} (if \code{.lonlat = FALSE}) or \code{receiver_lon} and \code{receiver_lat} (if\code{.lonlat = FALSE}) ---\code{numeric} vectors that define receiver coordinates;
}
\item \code{detection_overlaps} is a \code{list} of detection container overlaps (see \code{\link[=acs]{acs()}}).
\item \code{detection_kernels} is a named \code{list} of detection kernels (see \code{\link[=acs]{acs()}}).
}

\code{.moorings}, \code{.detection_overlaps} and \code{.detection_gaps} can be \code{NULL} if the AC algorithm is not implemented.}

\item{.update_ac}{A \code{list} of function(s) used to calculate, or update, particle weights. Each function in the list must accept four named arguments, even if unused:
\itemize{
\item \code{.particles}---a \code{\link{data.table}} that defines particle locations, with columns \code{cell_now}, \code{x_now} and \code{y_now};
\item \code{.obs}---the \code{.obs} \code{\link{data.table}};
\item \code{.t}---an \code{integer} that defines the time step (used to index \code{.obs});
\item \code{.bathy}---the \code{.bathy} \code{\link{SpatRaster}}
}

The function must return a numeric vector of weights (one for each particle). The weights from the AC* algorithm (if applicable) and the functions in \code{.update_ac} are combined internally and used to (re-)sample particles.}

\item{.kick, ...}{A function, and associated inputs, used to 'kick' particles into new (proposal) locations (see \code{\link[=pf_forward_1]{pf_forward_1()}}).}

\item{.n}{An \code{integer} that defines the number of particle samples at each time step.}

\item{.save_history, .write_history}{Arguments to save particle samples in memory or to file (see \code{\link[=pf_forward_1]{pf_forward_1()}}).}

\item{.progress, .verbose, .txt}{Controls of function prompts and messages (see \code{\link[=pf_forward_1]{pf_forward_1()}}).}
}
\value{
The function returns a \code{\link{pf}} object.
}
\description{
This function simulates the possible locations of an animal forwards in time. This function optionally incorporates AC* dynamics alongside the movement model in the simulation, unlike \code{\link[=pf_forward_1]{pf_forward_1()}} which takes the outputs of an AC* algorithm as the starting point for the forward simulation.
}
\details{
The forward simulation is implemented as follows:
\enumerate{
\item At each time step, at quadrature points (\code{t = 1}) or proposal locations (\code{t > 1}), weights are calculated according to the AC* algorithm (if specified) and/or models for ancillary data as specified in \code{.update_ac}. Unlike \code{\link[=pf_forward_1]{pf_forward_1()}}, weights are calculated at particle locations rather than across \code{.bathy} as a whole. Weights are calculated in four steps:
\itemize{
\item Land filter. Quadrature points/particles on land (in \code{NA} cells on \code{.bathy}) are dropped.
\item (optional) Container filter. Particle proposals that are incompatible with AC dynamics are dropped.
\item (optional) AC weights. For the set of remaining particles, AC weights are calculated  (using \code{.detection_overlaps} and \code{.detection_kernels}).
\item Updated weights. Weights are calculated, or updated, based on additional models (e.g., to account for depth time series).
}
\item \code{.n} locations (particles) are sampled from the quadrature points (\code{t = 1}) or resampled from a set of proposals (\code{t > 1}), with replacement, in line with calculated weights;
\item The previous locations (\code{NA} for \code{t = 1}) and the (accepted) current locations are recorded;
\item Each particle is 'kicked' into a new (proposal) location by the movement model;
\item Steps 1-4 are repeated until the end of the time series.
}

The essential difference between \code{\link[=pf_forward_1]{pf_forward_1()}} and \code{\link[=pf_forward_2]{pf_forward_2()}}  is that former is part of a coupled workflow in which (a) an AC* algorithm is used to calculate weights across the entire grid and (b) the weights are provided as an argument to \code{\link[=pf_forward_1]{pf_forward_1()}} which simulates movement trajectories, whereas the is an integrated implementation in which  weights are calculated on the fly. In both cases, AC* weights are defined based on pre-computed \code{\link{SpatRaster}}s (namely \code{.detection_kernels}) and movements are represented across the same grid.
}
\examples{
#### Set up examples
# Use pre-prepared datasets (see also `?acs()`)
# * Note that the default grid is low resolution
# * The grid should be resampled for real analyses to higher resolution
moorings  <- dat_moorings
obs       <- dat_obs()
gebco     <- dat_gebco()
overlaps  <- dat_overlaps()
kernels   <- dat_kernels()

#### Example (1): Implement the ACPF algorithm using default options
# * AC algorithm is implemented on the fly using overlaps & kernels
# * These pre-prepared datasets assume a particular detection probability model
# * PF is implemented using the default movement model
out_pff <- pf_forward_2(obs,
                        .bathy = gebco,
                        .moorings = moorings,
                        .detection_overlaps = overlaps,
                        .detection_kernels = kernels,
                        .kick = pf_kick,
                        .save_history = TRUE)
# The function returns a list as `pf_forward_1()`:
summary(out_pff)

#### Example (2): Implement the DCPF algorithm
# Define depth-error model (see also `?acs()` and ?dc()`)
# * We imagine the individual's depth is known Â± 25 m with equal probability
calc_depth_error   <- function(...) matrix(c(-25, 25), nrow = 2)
# Define shallow/deep depth limits
obs$depth_shallow <- obs$depth + calc_depth_error(obs$depth)[1, ]
obs$depth_deep    <- obs$depth + calc_depth_error(obs$depth)[2, ]
# Define function that calculates DC weights
update_ac <- function(.particles, .bathy, .obs, .t, ...) {
  # Extract depth of seabed at particle positions
  .particles$bathy <- terra::extract(.bathy, as.matrix(.particles[, c("x_now", "y_now")]))
  # Weight = 1 in locations where bathymetric depth is within possible limits, otherwise 0
  (.particles$bathy  >= .obs$depth_shallow[.t] & .particles$bathy <= .obs$depth_deep[.t]) + 0
}
# Implement DCPF
out_pff <- pf_forward_2(obs,
                        .bathy = gebco,
                        .kick = pf_kick,
                        .update_ac = update_ac,
                        .save_history = TRUE)
# Extract coordinates & validate implementation of depth-error model
out_pfxy <- pf_coords(out_pff$history, gebco,
                      .obs = obs, .cols = c("depth_shallow", "depth_deep"))
stopifnot(all(out_pfxy$depth >= out_pfxy$depth_shallow - 25 &
                out_pfxy$depth <= out_pfxy$depth_shallow + 25))

#### Example (3): Implement the ACDCPF algorithm
# Note that this algorithm may fail to converge on this low resolution grid
out_pff <- pf_forward_2(obs,
                        .bathy = gebco,
                        .moorings = moorings,
                        .detection_overlaps = overlaps,
                        .detection_kernels = kernels,
                        .update_ac = update_ac,
                        .kick = pf_kick,
                        .save_history = TRUE)

#### Example (4): Write history to file
# See `pf_forward_1()`

#### Example (4): Customise verbose options
# See `pf_forward_1()`

#### Example (5): Customise movement model (as in `pf_forward_1()`)
# See `pf_forward_1()`

#### Example (6): Implement the backward pass
# `pf_forward_*()` should be followed by `pf_backward()`
}
\seealso{
\itemize{
\item The PF (forward simulation) is implemented by \code{\link[=pf_forward_*]{pf_forward_*()}}:
\itemize{
\item \code{\link[=pf_forward_1]{pf_forward_1()}} refines AC-branch algorithm (\code{\link[=acs]{acs()}} and \code{\link[=dc]{dc()}}) outputs using PF;
\item \code{\link[=pf_forward_2]{pf_forward_2()}} is an integrated implementation that couples AC- and PF-branch algorithms internally;
}
\item PF is supported by:
\itemize{
\item Setup helpers, namely \code{\link[=pf_setup_files]{pf_setup_files()}};
\item Template movement models, namely \code{\link[=pf_kick]{pf_kick()}};
}
\item The backward pass is implemented by \code{\link[=pf_backward]{pf_backward()}};
\item Movement paths are built from PF outputs via \code{pf_path()} functions:
\itemize{
\item \code{\link[=pf_path]{pf_path()}} reconstructs paths;
\item \code{\link[=pf_path_pivot]{pf_path_pivot()}} supports path reconstruction;
}
\item To reconstruct maps of space use, see:
\itemize{
\item \code{\link[=pf_coords]{pf_coords()}} to extract particle coordinates;
\item \code{\link[=pf_map_pou]{pf_map_pou()}} for probability-of-use maps;
\item \code{\link[=pf_map_dens]{pf_map_dens()}} for smooth utilisation distributions;
\item \code{\link[=get_hr]{get_hr()}} for home range estimates;
}
}
}
\author{
Edward Lavender
}
