% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/particle-filter.R
\name{pf_filter}
\alias{pf_filter}
\title{PF: particle filter}
\usage{
pf_filter(
  .map,
  .timeline,
  .state = "StateXY",
  .xinit = NULL,
  .xinit_pars = list(),
  .yobs = list(),
  .model_obs,
  .model_move,
  .n_move = 100000L,
  .n_particle = 1000L,
  .n_resample = .n_record * 0.5,
  .n_record = 1000L,
  .direction = c("forward", "backward"),
  .verbose = getOption("patter.verbose")
)
}
\arguments{
\item{.map}{A \code{\link{SpatRaster}} that defines the study area for the simulation. Here, \code{.map} is used to:
\itemize{
\item Simulate initial states if \code{.xinit = NULL} (via \code{\link[=sim_states_init]{sim_states_init()}});
}}

\item{.timeline}{A \code{POSIXct} vector of regularly spaced time stamps that defines the timeline for the simulation. Here, \code{.timeline} is used to:
\itemize{
\item Define the time steps of the simulation;
}}

\item{.state, .xinit, .xinit_pars}{Arguments used to simulate initial states (see \code{\link[=sim_states_init]{sim_states_init()}}).
\itemize{
\item \code{.state}---A \code{character} that defines the \code{\link{State}} sub-type;
\item \code{.xinit}---\code{NULL} or a \code{\link{data.table}} that defines the initial states for the simulation;
\item \code{.xinit_pars}---A named \code{list} of parameters passed to the \code{.pars} argument of \code{\link[=sim_states_init]{sim_states_init()}};
}}

\item{.yobs, .model_obs}{Observations and observation models.
\itemize{
\item \code{.yobs} is a \code{list} of formatted datasets, one for each data type. Each element must be a \code{\link{data.table}} with the following columns:
\itemize{
\item \code{timestamp}---A \code{POSIXct} vector of time stamps;
\item \code{sensor_id}---A vector of 'sensor' IDs (such as receiver IDs);
\item \code{obs}---A vector of observations, as recorded by the sensor(s) at the corresponding time stamp;
\item Additional columns containing the parameters of the associated observation model instance (i.e., \code{.model_obs});
}
\item \code{.model_obs} is a \code{character} vector of \code{\link{ModelObs}} sub-types, one for each dataset in \code{yobs};
}}

\item{.model_move, .n_move}{The movement model.
\itemize{
\item \code{.model_move}---A \code{character} string that defines the movement model (see \code{\link{ModelMove}});
\item \code{.n_move}---An \code{integer} that defines the number of attempts to find a legal move;
}}

\item{.n_particle}{An \code{integer} that defines the number of particles.}

\item{.n_resample}{A \code{double} that defines the effective sample size at which to re-sample particles.}

\item{.n_record}{An \code{integer} that defines the number of recorded particles at each time step.}

\item{.direction}{A \code{character} string that defines the direction of the filter:
\itemize{
\item \code{"forward"} runs the filter from \code{.timeline[1]:.timeline[length(.timeline)]};
\item \code{"backward"} runs the filter from \code{.timeline[length(.timeline)]:.timeline[1]};
}}

\item{.verbose}{User output control (see \code{\link{patter-progress}} for supported options).}
}
\value{
The function returns a \code{\linkS4class{pf_particles}} object.
}
\description{
This function runs the particle filter. The filter samples possible states (typically locations, termed particles) of an animal at each time point given the data up to (and including) that time point and a movement model.
}
\section{Overview}{
The particle filter iterates over time steps, simulating states (termed 'particles') that are consistent with the preceding data and a movement model at each time step.

The initial states for the algorithm are defined by \code{.xinit} or simulated via \code{\link[=sim_states_init]{sim_states_init()}}. The word 'state' typically means location but may include additional parameters. If the initial state of the animal is known, it should be supplied via \code{.xinit}. Otherwise, \code{\link[=sim_states_init]{sim_states_init()}} samples \code{.n_particle} initial coordinates from \code{.map} (via \code{\link[=coords_init]{coords_init()}}), which are then translated into a \code{\link{data.table}} of states (that is, \code{.xinit}, via \code{\link[=states_init]{states_init()}}). The regions on \code{.map} from which initial coordinates are sampled can be restricted by the observations (\code{.yobs}) and other parameters. For automated handling of custom states and observation models at this stage, see the Details for \code{\link[=sim_states_init]{sim_states_init()}}.

At subsequent time steps, the filter comprises three stages:
\enumerate{
\item A movement step, in which we simulate possible states (particles) for the individual.
\item A weights step, in which we calculate particle weights from the log-likelihood of the data at each particle.
\item A re-sampling step, in which we optionally re-sample valid states using the weights.
}

The filter is implemented by the \code{Julia} function \href{https://github.com/edwardlavender/Patter.jl}{\code{Patter.particle_filter()}}. To multi-thread movement and likelihood evaluations, set the number of threads via \code{\link[=julia_connect]{julia_connect()}}. Use \code{JuliaCall::julia_help("particle_filter")} for further information.
}

\section{Algorithms}{
This is highly flexible routine for the reconstruction of the possible locations of an individual through time, given the data up to that time point. By modifying the observation models, it is straightforward to implement the ACPF, DCPF and ACDCPF algorithms introduced by Lavender et al. (2023) for reconstructing movements using (a) acoustic time series, (b) archival time series and (c) acoustic and archival time series. \code{\link[=pf_filter]{pf_filter()}} thus replaces (and enhances) the \href{https://edwardlavender.github.io/flapper/reference/ac.html}{\code{flapper::ac()}}, \href{https://edwardlavender.github.io/flapper/reference/dc.html}{\code{flapper::dc()}}, \href{https://edwardlavender.github.io/flapper/reference/acdc.html}{\code{flapper::acdc()}} and \href{https://edwardlavender.github.io/flapper/reference/pf.html}{\code{flapper::pf()}} functions.
}

\seealso{
Particle filters and smoothers sample states (particles) that represent the possible locations of an individual through time, accounting for all data and the individual's movement.
\itemize{
\item To assemble real-world datasets for the filter, see \code{\link{assemble}}\verb{_*()} functions.
\item \code{\link[=pf_filter]{pf_filter()}} runs the filter:
\itemize{
\item For state types, see \code{\link{State}};
\item For observation models, see \code{\link{ModelObs}};
\item For movement models, see \code{\link{ModelMove}};
}
\item To run particle smoothing, use \code{\link[=pf_smoother_two_filter]{pf_smoother_two_filter()}}.
\item To map emergent patterns of space use, use a \verb{map_*()} function.
}
}
\author{
Edward Lavender
}
