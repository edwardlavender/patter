% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/particle-filter.R
\name{pf_filter}
\alias{pf_filter}
\title{PF: particle filter}
\usage{
pf_filter(
  .timeline,
  .state = "StateXY",
  .xinit = NULL,
  .model_move = move_xy(),
  .yobs,
  .n_move = 100000L,
  .n_particle = 1000L,
  .n_resample = as.numeric(.n_particle),
  .t_resample = NULL,
  .n_record = 1000L,
  .n_iter = 1L,
  .direction = c("forward", "backward"),
  .verbose = getOption("patter.verbose")
)
}
\arguments{
\item{.timeline}{A \code{POSIXct} vector of regularly spaced time stamps that defines the timeline for the simulation. Here, \code{.timeline} is used to:
\itemize{
\item Define the time steps of the simulation;
}}

\item{.state, .xinit}{Arguments used to simulate initial states.
\itemize{
\item \code{.state}---A \code{character} that defines the \code{\link{State}} sub-type;
\item \code{.xinit}---\code{NULL} or a \code{\link{data.table}} that defines the initial states for the simulation;
}}

\item{.model_move, .n_move}{The movement model.
\itemize{
\item \code{.model_move}---A \code{character} string that defines the movement model (see \code{\link{ModelMove}});
\item \code{.n_move}---An \code{integer} that defines the number of attempts to find a legal move;
}}

\item{.yobs}{The observations. Acceptable inputs are:
\itemize{
\item A named \code{list} of formatted datasets, one for each data type (see \code{\link{glossary}});
\item An empty \code{list}, to run the filter without observations;
\item \code{missing}, if the datasets are already available in the \code{Julia} session (from a previous run of \code{\link[=pf_filter]{pf_filter()}}) and you want to re-run the filter without the penalty of re-exporting the observations;
}}

\item{.n_particle}{An \code{integer} that defines the number of particles.}

\item{.n_resample, .t_resample}{Resampling options.
\itemize{
\item \code{.n_resample} is an a \code{double} that defines the effective sample size (ESS) at which to re-sample particles;
\item \code{.t_resample} is \code{NULL} or an \code{integer}/\code{integer} vector that defines the time steps at which to resample particles, regardless of the ESS;
}

Guidance:
\itemize{
\item To resample at every time step, set \code{.n_resample = as.numeric(.n_particle)} (default) or \code{.t_resample = 1:length(.timeline)};
\item To only resample at selected time steps, set \code{.t_resample} as required and set \code{.n_resample > as.numeric(.n_particle)};
\item To only resample based on ESS, set \code{.t_resample = NULL} and \code{.n_resample} as required;
}}

\item{.n_record}{An \code{integer} that defines the number of recorded particles at each time step.}

\item{.n_iter}{An \code{integer} that defines the number of iterations of the filter.}

\item{.direction}{A \code{character} string that defines the direction of the filter:
\itemize{
\item \code{"forward"} runs the filter from \code{.timeline[1]:.timeline[length(.timeline)]};
\item \code{"backward"} runs the filter from \code{.timeline[length(.timeline)]:.timeline[1]};
}}

\item{.verbose}{User output control (see \code{\link{patter-progress}} for supported options).}
}
\value{
The function returns a \code{\linkS4class{pf_particles}} object.
}
\description{
This function runs the particle filter. The filter samples possible states (typically locations, termed particles) of an animal at each time point given the data up to (and including) that time point and a movement model.
}
\section{Overview}{
The particle filter iterates over time steps, simulating states (termed 'particles') that are consistent with the preceding data and a movement model at each time step.

A raster map of study area must be exported to \code{Julia} for this function (see \code{\link[=set_map]{set_map()}}).

The initial states for the algorithm are defined by \code{.xinit} or simulated via \href{https://github.com/edwardlavender/Patter.jl}{\code{Patter.simulate_states_init()}}. The word 'state' typically means location but may include additional parameters. If the initial state of the animal is known, it should be supplied via \code{.xinit}. Otherwise, \href{https://github.com/edwardlavender/Patter.jl}{\code{Patter.simulate_states_init()}} samples \code{.n_particle} initial coordinates from \code{.map} (via \href{https://github.com/edwardlavender/Patter.jl}{\code{Patter.coords_init()}}), which are then translated into a \code{DataFrame} of states (that is, \code{.xinit}, via \href{https://github.com/edwardlavender/Patter.jl}{\code{Patter.states_init()}}). The regions on the map from which initial coordinates are sampled can be restricted by the observations (\code{.yobs}) and other parameters. For automated handling of custom states and observation models at this stage, custom \code{Patter.map_init} and \code{Patter.states_init} methods are required (see the Details for \href{https://github.com/edwardlavender/Patter.jl}{\code{Patter.simulate_states_init()}}).

The filter comprises three stages:
\enumerate{
\item A movement step, in which we simulate possible states (particles) for the individual (for time steps 2, ..., T).
\item A weights step, in which we calculate particle weights from the log-likelihood of the data at each particle.
\item A re-sampling step, in which we optionally re-sample valid states using the weights.
}

The time complexity of the algorithm is \eqn{O(TN)}.

The filter is implemented by the \code{Julia} function \href{https://github.com/edwardlavender/Patter.jl}{\code{Patter.particle_filter()}}. To multi-thread movement and likelihood evaluations, set the number of threads via \code{\link[=julia_connect]{julia_connect()}}. See \href{https://github.com/edwardlavender/Patter.jl}{\code{Patter.particle_filter()}} or \code{JuliaCall::julia_help("particle_filter")} for further information.
}

\section{Algorithms}{
This is highly flexible routine for the reconstruction of the possible locations of an individual through time, given the data up to that time point. By modifying the observation models, it is straightforward to implement the ACPF, DCPF and ACDCPF algorithms introduced by Lavender et al. (2023) for reconstructing animal movements in passive acoustic telemetry systems using (a) acoustic time series, (b) archival time series and (c) acoustic and archival time series. \code{\link[=pf_filter]{pf_filter()}} thus replaces (and enhances) the \href{https://edwardlavender.github.io/flapper/reference/ac.html}{\code{flapper::ac()}}, \href{https://edwardlavender.github.io/flapper/reference/dc.html}{\code{flapper::dc()}}, \href{https://edwardlavender.github.io/flapper/reference/acdc.html}{\code{flapper::acdc()}} and \href{https://edwardlavender.github.io/flapper/reference/pf.html}{\code{flapper::pf()}} functions.
}

\examples{
if (julia_run()) {

  library(data.table)
  library(dtplyr)
  library(dplyr, warn.conflicts = FALSE)

  #### Julia set up
  julia_connect()
  set_seed()

  #### Define study period
  # The resolution of the timeline defines the resolution of the simulation
  timeline <- seq(as.POSIXct("2016-01-01", tz = "UTC"),
                  as.POSIXct("2016-01-01 03:18:00", tz = "UTC"),
                  by = "2 mins")

  #### Define study area
  # `map` is a SpatRaster that defines the region within which movements are permitted
  # Here, we consider the movements of an aquatic animal in Scotland
  # ... `map` represents the bathymetry in the relevant region
  # Use `set_map()` to export the map to `Julia`
  map <- dat_gebco()
  terra::plot(map)
  set_map(map)


  #### --------------------------------------------------
  #### Simulation-based workflow

  #### Scenario
  # We have studied the movements of flapper skate off the west coast of Scotland.
  # We have collected acoustic detections at receivers and depth time series.
  # Here, we simulate movements and acoustic/archival observations arising from movements.
  # We then apply particle filtering to the 'observations' to reconstruct
  # ... simulated movements.

  #### Simulate an acoustic array
  moorings <- sim_array(.map = map,
                        .timeline = timeline,
                        .n_receiver = 100L)

  # `moorings` includes the following default observation model parameters
  # * These describe how detection probability declines with distance from a receiver
  # * These are the parameters of the `ModelObsAcousticLogisTrunc` observation model
  a <- moorings$receiver_alpha[1]
  b <- moorings$receiver_beta[1]
  g <- moorings$receiver_gamma[1]
  d <- seq(1, 1000, by = 1)
  plot(d, ifelse(d <= g, plogis(a * b * d), 0),
       ylab = "Detection probability",
       xlab = "Distance (m)",
       type = "l")

  #### Simulate a movement path
  # Define `State` sub-type
  # > We will consider the animal's movement in two-dimensions (x, y)
  state    <- "StateXY"
  # Define the maximum moveable distance (m) between two time steps
  mobility <- 750
  # Define the movement model
  # > We consider a two-dimensional random walk
  model_move <-
    move_xy(mobility   = "750.0",
            dbn_length = "truncated(Gamma(1, 250.0), upper = 750.0)",
            dbn_angle  = "Uniform(-pi, pi)")
  # Simulate a path
  paths <- sim_path_walk(.map = map,
                         .timeline = timeline,
                         .state = state,
                         .model_move = model_move)

  #### Simulate observations
  # Define observation model(s)
  # * We simulate acoustic observations and depth time series
  # * Acoustic observations are simulated according to `ModelObsAcousticLogisTrunc`
  # * Depth observations are simulated according to `ModelObsDepthUniform`
  # Define a `list` of parameters for the observation models
  # (See `?ModelObs` for details)
  pars_1 <-
    moorings |>
    select(sensor_id = "receiver_id", "receiver_x", "receiver_y",
           "receiver_alpha", "receiver_beta", "receiver_gamma") |>
    as.data.table()
  pars_2 <- data.table(sensor_id = 1L,
                       depth_shallow_eps = 10,
                       depth_deep_eps = 10)
  model_obs <- list(ModelObsAcousticLogisTrunc = pars_1,
                    ModelObsDepthUniform = pars_2)
  # Simulate observational datasets
  obs <- sim_observations(.timeline = timeline,
                          .model_obs = model_obs)
  summary(obs)
  head(obs$ModelObsAcousticLogisTrunc[[1]])
  head(obs$ModelObsDepthUniform[[1]])
  # Identify detections
  detections <-
    obs$ModelObsAcousticLogisTrunc[[1]] |>
    filter(obs == 1L) |>
    as.data.table()
  # Collate datasets for filter
  # > This requires a list of datasets, one for each data type
  # > We could also include acoustic containers here for efficiency (see below)
  yobs <- list(ModelObsAcousticLogisTrunc = obs$ModelObsAcousticLogisTrunc[[1]],
               ModelObsDepthUniform = obs$ModelObsDepthUniform[[1]])

  #### Example (1): Run the filter using the default options
  fwd <- pf_filter(.timeline = timeline,
                   .state = state,
                   .xinit = NULL,
                   .model_move = model_move,
                   .yobs = yobs,
                   .n_particle = 1e4L,
                   .direction = "forward")

  ## Output object structure:
  # The function returns a `pf_particles` list:
  class(fwd)
  summary(fwd)
  # `xinit` is a `data.table` of initial particles
  fwd$xinit
  # `states` is a `data.table` of particles:
  fwd$states
  # `diagnostics` is a `data.table` of filter diagnostics
  fwd$diagnostics
  # fwd$convergence is a Boolean that defines whether or not the algorithm converged
  fwd$convergence
  # fwd$trials is an integer that defines the number of trials

  ## Map output states:
  # Map particle coordinates
  pf_plot_xy(.map = map, .coord = fwd$states, .steps = 1L)
  # Map a utilisation distribution
  # * Use sigma = spatstat.explore::bw.diggle() for CV bandwidth estimate
  map_dens(.map = map,
           .coord = fwd$states)

  ## Analyse filter diagnostics
  # `maxlp` is the maximum log-posterior at each time step
  # > exp(fwd$diagnostics$maxlp) = the highest likelihood score at each time step (0-1)
  # > This should not be too low!
  plot(fwd$diagnostics$timestamp, fwd$diagnostics$maxlp, type = "l")
  # `ess` is the effective sample size
  # > For a 2D distribution,  >= 500 particles at each time step should be sufficient
  # > But we often have a low ESS at the moment of a detection
  # > If this is too low, we can trying boosting `.n_particle`
  plot(fwd$diagnostics$timestamp, fwd$diagnostics$ess, type = "l")
  points(detections$timestamp, rep(0, nrow(detections)),
         pch = 21, col = "red", bg = "red", cex = 0.5)
  abline(h = 500, col = "royalblue", lty = 3)

  #### Example (2): Customise initial states for the filter
  # Option (A): Mark the known starting location on `.map`
  # > Initial states are automatically sampled from `.map`
  # > We have to reset the initial map in Julia
  # > Use set_map with .as_Raster = TRUE and .as_GeoArray = FALSE
  # > (After the example, we reset the map for later examples)
  origin       <- terra::setValues(map, NA)
  cell         <- terra::cellFromXY(map, cbind(paths$x[1], paths$y[1]))
  origin[cell] <- paths$map_value[1]
  set_map(.x = origin, .as_Raster = TRUE, .as_GeoArray = FALSE)
  fwd <- pf_filter(.timeline = timeline,
                   .state = state,
                   .xinit = NULL,
                   .yobs = yobs,
                   .model_move = model_move,
                   .n_particle = 1e4L)
  set_map(map, .as_Raster = TRUE, .as_GeoArray = FALSE)
  # Option (B): Specify `.xinit` manually
  # > `.xinit` is resampled, as required, to generate `.n_particle` initial states
  xinit <- data.table(map_value = paths$map_value[1], x = paths$x[1], y = paths$y[1])
  fwd   <- pf_filter(.timeline = timeline,
                     .state = state,
                     .xinit = xinit,
                     .yobs = yobs,
                     .model_move = model_move,
                     .n_particle = 1e4L)

  #### Example (3): Customise selected settings
  # Boost the number of particles
  fwd   <- pf_filter(.timeline = timeline,
                     .state = state,
                     .xinit = xinit,
                     .yobs = yobs,
                     .model_move = model_move,
                     .n_particle = 1.5e4L)
  # Change the threshold ESS for resampling
  fwd   <- pf_filter(.timeline = timeline,
                     .state = state,
                     .xinit = xinit,
                     .yobs = yobs,
                     .model_move = model_move,
                     .n_particle = 1.5e4L,
                     .n_resample = 1000L)
  # Force resampling at selected time steps
  # * Other time steps are resampled if ESS < .n_resample
  fwd   <- pf_filter(.timeline = timeline,
                     .state = state,
                     .xinit = xinit,
                     .yobs = yobs,
                     .model_move = model_move,
                     .t_resample = which(timeline \%in\% detections$timestamp),
                     .n_particle = 1.5e4L,
                     .n_resample = 1000L)
  # Change the number of particles retained in memory
  fwd   <- pf_filter(.timeline = timeline,
                     .state = state,
                     .xinit = xinit,
                     .yobs = yobs,
                     .model_move = model_move,
                     .n_particle = 1.5e4L,
                     .n_record = 2000L)

  #### Example (2): Run the filter backwards
  # (A forward and backward run is required for the two-filter smoother)
  fwd <- pf_filter(.timeline = timeline,
                   .state = state,
                   .xinit = NULL,
                   .yobs = yobs,
                   .model_move = model_move,
                   .n_particle = 1e4L,
                   .direction = "backward")


  #### --------------------------------------------------
  #### Real-world examples

  #### Assemble datasets

  # Define datasets for a selected animal
  # > Here, we consider detections and depth time series from an example flapper skate
  individual_id <- NULL
  det <- dat_detections[individual_id == 25L, ][, individual_id := NULL]
  arc <- dat_archival[individual_id == 25L, ][, individual_id := NULL]

  # Define a timeline
  # * We can do this manually or use the observations to define a timeline:
  timeline <- assemble_timeline(list(det, arc), .step = "2 mins", .trim = TRUE)
  timeline <- timeline[1:1440]
  range(timeline)

  # Assemble a timeline of acoustic observations (0, 1) and model parameters
  # * The default acoustic observation model parameters are taken from `.moorings`
  acoustics <- assemble_acoustics(.timeline = timeline,
                                  .detections = det,
                                  .moorings = dat_moorings)

  # Assemble corresponding acoustic containers
  # * This is recommended with acoustic observations
  # * Note this dataset is direction specific (see below)
  containers <- assemble_acoustics_containers(.timeline = timeline,
                                              .acoustics = acoustics,
                                              .mobility = mobility)

  # Assemble a timeline of archival observations and model parameters
  # * Here, we include model parameters for `ModelObsDepthNormalTrunc`
  archival <- assemble_archival(.timeline = timeline,
                                .archival =
                                  arc |>
                                  rename(obs = depth) |>
                                  mutate(depth_sigma = 50,
                                         depth_deep_eps = 20))

  # Define the .yobs list for each run of the particle filter
  yobs_fwd <- list(ModelObsAcousticLogisTrunc = acoustics,
                   ModelObsAcousticContainer = containers$forward,
                   ModelObsDepthNormalTrunc = archival)
  yobs_bwd <- list(ModelObsAcousticLogisTrunc = acoustics,
                   ModelObsAcousticContainer = containers$backward,
                   ModelObsDepthNormalTrunc = archival)

  #### Visualise realisations of the movement model (the prior)
  # We will use the same movement model as in previous examples
  sim_path_walk(.map = map,
                .timeline = timeline,
                .state = state,
                .model_move = model_move,
                .n_path = 10L, .one_page = TRUE)

  #### Example (1): Run filter forwards
  fwd <- pf_filter(.timeline = timeline,
                   .state = state,
                   .yobs = yobs_fwd,
                   .model_move = model_move)

  #### Example (2): Run the filter backwards
  bwd <- pf_filter(.timeline = timeline,
                   .state = state,
                   .yobs = yobs_bwd,
                   .model_move = model_move,
                   .direction = "backward")

}
}
\seealso{
Particle filters and smoothers sample states (particles) that represent the possible locations of an individual through time, accounting for all data and the individual's movement.
\itemize{
\item To simulate artificial datasets, see \verb{sim_*()} functions (especially \code{\link[=sim_path_walk]{sim_path_walk()}}, \code{\link[=sim_array]{sim_array()}} and \code{\link[=sim_observations]{sim_observations()}}).
\item To assemble real-world datasets for the filter, see \code{\link{assemble}}\verb{_*()} functions.
\item \code{\link[=pf_filter]{pf_filter()}} runs the filter:
\itemize{
\item For state types, see \code{\link{State}};
\item For observation models, see \code{\link{ModelObs}};
\item For movement models, see \code{\link{ModelMove}};
}
\item To run particle smoothing, use \code{\link[=pf_smoother_two_filter]{pf_smoother_two_filter()}}.
\item To map emergent patterns of space use, use a \verb{map_*()} function (such as \code{\link[=map_pou]{map_pou()}}, \code{\link[=map_dens]{map_dens()}} and \code{\link[=map_hr]{map_hr()}}).
}
}
\author{
Edward Lavender
}
