% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pf_backward_sampler.R
\name{pf_backward_dens}
\alias{pf_backward_dens}
\title{PF: pre-calculate densities for the backward pass}
\usage{
pf_backward_dens(
  .history,
  .dens_step,
  ...,
  .in_memory = TRUE,
  .collect = 1e+09,
  .store = NULL,
  .cl = NULL,
  .varlist = NULL,
  .verbose = TRUE,
  .txt = ""
)
}
\arguments{
\item{.history}{Particle samples from the forward simulation.

If \code{.in_memory = TRUE}, this can be provided as:
\itemize{
\item A \code{list} of \code{\link{data.table}}s that define cell samples; i.e., the \code{history} element of a \code{\linkS4class{pf}} object.
\item An ordered list of file paths (from \code{\link[=pf_setup_files]{pf_setup_files()}}) that define the directories in which particle samples were written from the forward simulation (as parquet files).
}

If \code{.in_memory = FALSE}, this must be a character string that defines the directory within which parquet files are stored.}

\item{.dens_step, ...}{A function, and associated arguments, to calculate the density of movements between locations (see \code{\link[=pf_backward_sampler]{pf_backward_sampler()}} and \code{\link[=dstep]{dstep()}}). This must accept the arguments described in \code{\link[=pf_backward_sampler]{pf_backward_sampler()}}:
\itemize{
\item \code{.data_now}---a \code{\link{data.table}} of particle locations;
\item \code{.data_past}---a \code{\link{data.table}} of paired particle locations;
\item (optional) \code{...}---additional arguments;
}

However, note that the exact form of \code{.data_now} and \code{.data_past} differ depending on the implementation (see Details):
\itemize{
\item For implementation options (1) and (2A), densities are calculated between all cell pairs (i.e., two multi-row \code{\link{data.table}}s), by default via \code{\link[=dstep]{dstep()}}. Internally, this uses \code{\link[terra:distance]{terra::distance()}} so you must specify \code{lonlat} and \code{pairwise = TRUE}.
\item For implementation option (2B) \code{.data_now} is a single row (as described in \code{\link[=pf_backward_sampler]{pf_backward_sampler()}}). Under the default implementation, \code{lonlat} is required but \code{pairwise} is optional.
}

For custom functions, note that coordinates are stored in each \code{\link{data.table}} in \code{x_now} and \code{y_now} columns. Other columns are dropped, with some exceptions.}

\item{.in_memory}{A logical variable that defines whether or not to begin processing in memory (see Details).}

\item{.collect}{If \code{.in_memory = FALSE}, \code{.collect} is an \code{integer} that controls whether or not particle pairs are brought into memory for density calculations (see Details). If the number of particle pairs exceeds \code{.collect}, processing continues without bringing the data fully into memory.}

\item{.store}{If \code{.in_memory = FALSE} and \code{.collect} is exceeded, \code{.store} is required. This is a character string that defines the path to an empty directory within which to write files.}

\item{.cl, .varlist}{Parallelisation options for implementation 2B (see Details and \code{\link[=cl_lapply]{cl_lapply()}}).}

\item{.verbose, .txt}{Arguments to monitor function progress (see \code{\link[=pf_forward]{pf_forward()}}).}
}
\value{
The function returns:
\itemize{
\item Implementations 1 and 2A: a named, nested \code{list}
\item Implementation 2B: \code{invisible(NULL)} (see Details)
}
}
\description{
This function is used to pre-calculate densities for the backward pass.
}
\details{
The backward pass sweeps backwards in time through particle samples to reconstruct movement paths (see \code{\link[=pf_backward_sampler]{pf_backward_sampler()}}). For each particle, at each time step this algorithm samples a preceding location according to the probability densities connecting that particle to all particles from the preceding time step. The purpose of this function is to identify the set of unique transitions between particle pairs and pre-calculate probability densities for \code{\link[=pf_backward_sampler]{pf_backward_sampler()}}.

There are five steps:
\enumerate{
\item Identify cells. The first step is to identify set of unique locations (grid cells) sampled (by the forward filter) at each time step.
\item Identify transitions. The second step is to reconstruct the set of possible transitions between cells at each time step. This requires a cross-join operation (at each time step, each (unique) cell is paired against all (unique) cells from the previous time step). This is memory intensive and can be optionally implemented using \code{sparklyr} (see below).
\item Identify distinct transitions. The third step is to identify the set of unique cell combinations for which probability densities are required. This is hopefully considerably fewer less than the total number of transitions.
\item Calculate densities. The fourth step is to calculate densities (e.g., via \code{\link[=dstep]{dstep()}}).
\item Return outputs. The final step is to return densities in a format that can be efficiently accessed in \code{\link[=pf_backward_sampler]{pf_backward_sampler()}} (e.g., via \code{\link[=dstep_lookup]{dstep_lookup()}} or \code{\link[=dstep_read]{dstep_read()}}).
}

There are three implementation options:
\enumerate{
\item \code{.in_memory} is \code{TRUE}. Under this option, steps 1--5 are implemented in memory. A \code{list} is returned that can be accessed in \code{\link[=pf_backward_sampler]{pf_backward_sampler()}} via \code{\link[=dstep_lookup]{dstep_lookup()}}.
\item \code{.in_memory} is \code{FALSE}. Under this option, steps 1--5 are implemented without bringing the data (fully) into memory. Steps 1--3 are achieved using \code{sparklyr}. The function establishes a connection to Spark, implements 1--3 using Spark, and counts the resultant number of unique transitions for which densities are required (\code{n}). What happens next depends on whether or not \code{n <= .collect}:
\itemize{
\item (A) \code{n <= .collect}. If \code{n < .collect}, data are brought into memory for steps 4--5. A \code{list} is returned that can be accessed in \code{\link[=pf_backward_sampler]{pf_backward_sampler()}} via \code{\link[=dstep_lookup]{dstep_lookup()}}.
\item (B) \code{n > .collect}. If \code{n > .collect}, steps 4--5 are implemented in batches:
\itemize{
\item For each grid cell, a parquet file is written to \verb{\{.store\}/pairs/\{cell\}.parquet} with the coordinates of cell pairs;
\item Parquet files are iteratively read into memory, density calculations are implemented and, for each grid cell, a \code{list} of densities to paired cells is written to \verb{\{.store\}/density/\{cell\}.qs}. This step can be optionally parallelised. Limited experimentation suggested that this approach is faster than a full Spark implementation. The resultant files can be accessed in \code{\link[=pf_backward_sampler]{pf_backward_sampler()}} via \code{\link[=dstep_read]{dstep_read()}}. The function itself returns \code{invisible(NULL)}.
}
}
}
}
\examples{
# See ?`pf_backward_sampler()` for examples

}
\seealso{
\itemize{
\item \code{\link[=pf_forward]{pf_forward()}} to implement the forward simulation;
\item \code{\link[=pf_backward_*]{pf_backward_*()}} implements the backward pass;
\item \code{\link[=pf_path]{pf_path()}} reconstructs movement paths;
\item \code{\link[=pf_map_pou]{pf_map_pou()}} and \code{\link[=pf_map_dens]{pf_map_dens()}} generate maps of space use;
\item \code{\link[=pf_setup_files]{pf_setup_files()}} and \code{\link[=pf_coords]{pf_coords()}} are helper functions;
}
}
\author{
Edward Lavender
}
