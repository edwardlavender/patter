% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/assemble-data.R
\name{assemble}
\alias{assemble}
\alias{assemble_timeline}
\alias{assemble_acoustics}
\alias{assemble_archival}
\title{Assemble observations}
\usage{
assemble_timeline(.datasets = list(), .step, .trim = FALSE)

assemble_acoustics(.timeline, .acoustics, .moorings)

assemble_archival(.timeline, .archival)
}
\arguments{
\item{.datasets, .step, .trim}{Arguments for \code{\link[=assemble_timeline]{assemble_timeline()}}.
\itemize{
\item \code{.datasets}---A \code{list} of \code{\link{data.table}}s, one for each data type, each containing a \code{timestamp} column;
\item \code{.step}---A \code{character} (such as \code{"2 mins"}), passed to \code{\link[lubridate:round_date]{lubridate::round_date()}} and \code{\link[=seq.POSIXt]{seq.POSIXt()}}, that defines the resolution of the timeline;
\item \code{.trim}---A \code{logical} variable that defines whether or not to trim the timeline to the overlapping period between datasets;
}}

\item{.timeline}{A \code{POSIXct} vector of regularly spaced time stamps that defines the timeline for the simulation (optionally from \code{\link[=assemble_timeline]{assemble_timeline()}}). Here, \code{timeline} is used to:
\itemize{
\item Define the resolution of observations;
}}

\item{.acoustics, .moorings}{The \link{data.table}s for \code{\link[=assemble_acoustics]{assemble_acoustics()}}.
\itemize{
\item \code{.acoustics} is a \link{data.table} of acoustic detections \strong{for a single individual}. This must contain the \code{receiver_id} and \code{timestamp} columns.
\item \code{.moorings} is a \code{\link{data.table}} of acoustic receiver deployments. This must contain the \code{receiver_id}, \code{receiver_start}, and \code{receiver_end} columns, plus additional parameter columns.
}}

\item{.archival}{For \code{\link[=assemble_archival]{assemble_archival()}}, \code{.archival} is a \code{\link{data.table}} of archival observations (such as depth measurements) \strong{for a single individual}. This must contain \code{timestamp} and \code{obs} columns plus additional parameter columns.}
}
\description{
These functions assemble a timeline and observations for the particle filter (\code{\link[=pf_filter]{pf_filter()}}).
}
\details{
\code{\link[=assemble_timeline]{assemble_timeline()}} is a simple function that defines a regular timeline, of resolution \code{.step}, from a \code{list} of input datasets.
\itemize{
\item If \code{.trim = FALSE}, this defines a sequence of regular time stamps across the full range of time stamps in the input datasets.
\item If \code{.trim = TRUE}, the timeline is trimmed to the overlapping period between datasets.
}

\code{\link[=assemble_acoustics]{assemble_acoustics()}} and \code{\link[=assemble_archival]{assemble_archival()}} prepare timelines of acoustic and archival observations as required for the particle filter (\code{\link[=pf_filter]{pf_filter()}}). The filter expects a \code{list} of datasets (one for each data type). Each dataset must contain the following columns: \code{timestamp}, \code{sensor_id}, \code{obs} and additional columns with the parameters of the observation model (see \code{\link{glossary}}).
\itemize{
\item \code{\link[=assemble_acoustics]{assemble_acoustics()}} prepares a timeline of acoustic observations, as required by the filter. This function expects a 'standard' acoustic dataset (that is, a \code{\link{data.table}} like \code{\link{dat_acoustics}}) that defines detections at receivers alongside a moorings dataset (like \code{\link{dat_moorings}}) that defines receiver deployment periods. \code{\link[=assemble_acoustics]{assemble_acoustics()}} uses these datasets to assemble a complete time series of acoustic observations; that is, a \code{\link{data.table}} of time stamps and receivers that defines, for each time step and each operational receiver whether (\code{1L}) or not (\code{0L}) a detection was recorded at that time step. Duplicate observations (that is, detections at the same receiver in the same time step, are dropped.) If available in \code{.moorings}, additional columns (\code{receiver_alpha}, \code{receiver_beta} and \code{receiver_gamma}) are included as required for the default acoustic observation model (that is, \code{\link{ModelObsAcousticLogisTrunc}}). If observation model parameters vary both by receiver and through time, simply amend these columns as required.
\item \code{\link[=assemble_archival]{assemble_archival()}} prepares a timeline of archival observations (such as depth measurements), as required by the filter. This function expects a \code{\link{data.table}} that includes, at a minimum, the \code{timestamp} and \code{obs} columns. The latter defines the observations. For archival data, the \code{sensor_id} column (if unspecified) is simply set to \code{1L}. The function re-expresses time stamps at the resolution specified by \code{timeline}. Duplicate observations (that is, multiple measurements in the same time step) throw a \code{\link{warning}}.
}

Additional datasets are easy to incorporate into the particle filter but require manual preparation in the format described above. Observations can be recorded irregularly or regularly through time but must be expressed at the temporal resolution defined by the timeline.

In \code{Julia}, datasets are translated into a hash-table (\code{Dict}) of observations (via \href{https://edwardlavender.github.io/Patter.jl/}{\code{Patter.assemble_yobs()}}). For each time stamp with an observation, this includes a \code{Vector} of \code{Tuple}s, each containing the observation and the associated \code{\link{ModelObs}} instance that defines the parameters of the observation model. The particle filter (\href{https://edwardlavender.github.io/Patter.jl/}{\code{Patter.particle_filter()}}) iterates over each time step in the timeline, uses a movement model to simulate animal movement and, for the time stamps with observations, evaluates the likelihood of those observations for the simulated locations (particles).

\verb{assemble_*()} routines are only required for real-world analyses.
}
\examples{
library(data.table)
library(dtplyr)
library(dplyr, warn.conflicts = FALSE)

#### Define example dataset(s) for a selected individual
# Acoustic time series
# * Observation model parameters are defined in `.moorings`
acc <-
  dat_acoustics |>
  filter(individual_id == 25L) |>
  select("timestamp", "receiver_id") |>
  as.data.table()
# Archival time series
# * Observation model parameters must be included
# * Here, we define parameters for `?ModelObsDepthNormalTrunc`
arc <-
  dat_archival |>
  filter(individual_id == 25L) |>
  select("timestamp", obs = "depth") |>
  mutate(depth_sigma = 50, depth_deep_eps = 20) |>
  as.data.table()

#### Example (1): Define a timeline
# Define a timeline manually
timeline <- seq(as.POSIXct("2016-03-01 00:00:00", tz = "UTC"),
                as.POSIXct("2016-04-01 00:00:00"),
                by = "2 mins")
# Use `assemble_timeline()` with `.trim = FALSE`
timeline <- assemble_timeline(list(acc, arc), .step = "2 mins")
range(timeline)
# Use `assemble_timeline()` with `.trim = TRUE`
timeline <- assemble_timeline(list(acc, arc), .step = "2 mins", .trim = TRUE)
timeline <- timeline[1:1440]
range(timeline)

#### Example (2): Assemble an acoustic timeline
# Assemble a timeline of acoustic observations (0, 1) and model parameters
# * The default acoustic observation model parameters are taken from `.moorings`
# * But can be modified or added afterwards for custom observation models
acoustics <- assemble_acoustics(.timeline = timeline,
                                .acoustics = acc,
                                .moorings = dat_moorings)
head(acoustics)

#### Example (3): Assemble an archival timeline
# Assemble a timeline of archival observations and model parameters
archival <- assemble_archival(.timeline = timeline,
                              .archival = arc)
head(archival)

#### Example (4): Implement particle filter
# Use `pf_filter()` to implement the particle filter
# A list of assembled datasets is passed to the `yobs` argument
# The corresponding `ModelObs` subtypes must also be specified
}
\seealso{
Particle filters and smoothers sample states (particles) that represent the possible locations of an individual through time, accounting for all data and the individual's movement.
\itemize{
\item To simulate artificial datasets, see \verb{sim_*()} functions (especially \code{\link[=sim_path_walk]{sim_path_walk()}}, \code{\link[=sim_array]{sim_array()}} and \code{\link[=sim_observations]{sim_observations()}}).
\item To assemble real-world datasets for the filter, see \code{\link{assemble}}\verb{_*()} functions.
\item \code{\link[=pf_filter]{pf_filter()}} runs the filter:
\itemize{
\item For state types, see \code{\link{State}};
\item For observation models, see \code{\link{ModelObs}};
\item For movement models, see \code{\link{ModelMove}};
}
\item To run particle smoothing, use \code{\link[=pf_smoother_two_filter]{pf_smoother_two_filter()}}.
\item To map emergent patterns of space use, use a \verb{map_*()} function (such as \code{\link[=map_pou]{map_pou()}}, \code{\link[=map_dens]{map_dens()}} and \code{\link[=map_hr]{map_hr()}}).
}
}
\author{
Edward Lavender
}
