% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/acs.R
\name{acs}
\alias{acs}
\title{AC* algorithm back-end}
\source{
This function evolved from \code{.acs()} in the \href{https://github.com/edwardlavender/flapper}{flapper} package. Key developments include:
\itemize{
\item Implementation of the algorithm over a single timeline;
\item Re-parameterisation of container dynamics at each time step with respect to the possible locations of the individual given the data, given the past and given the future;
\item Exploitation of \code{\link{data.table}} and \code{\link{terra}} for substantially improved speed;
\item The use of \code{\link[terra:buffer]{terra::buffer()}} to represent container dynamics, which is faster and removes the polygon versus grid discrepancy in \href{https://github.com/edwardlavender/flapper}{flapper};
\item Implementation of the \code{.ac_update} argument to implement the ACDC algorithm or any related approach;
}
}
\usage{
acs(
  .obs,
  .bathy,
  .detection_overlaps = NULL,
  .detection_kernels,
  .update_ac = NULL,
  ...,
  .save_cumulative = FALSE,
  .save_record = FALSE,
  .write_record = NULL,
  .progress = TRUE,
  .prompt = FALSE,
  .verbose = TRUE,
  .con = ""
)
}
\arguments{
\item{.obs}{A \code{\link{data.table}} with observations, from \code{\link[=acs_setup_obs]{acs_setup_obs()}}.}

\item{.bathy}{A \code{\link{SpatRaster}} that defines the grid over which the algorithms are implemented.}

\item{.detection_overlaps}{A named \code{list}, from \code{\link[=acs_setup_detection_overlaps]{acs_setup_detection_overlaps()}}.}

\item{.detection_kernels}{A \code{list}, from \code{\link[=acs_setup_detection_kernels]{acs_setup_detection_kernels()}}.}

\item{.update_ac, ...}{(optional) A function and additional arguments used to update the \code{\link{SpatRaster}} that defines the possible locations of the individual given the data (according to the AC algorithm) at each time step. For example, if you have depth observations, you could use a depth-error model to build a probability surface that describes the possible locations of the individual at each time step and that is combined with the information from the AC algorithm. Information from other variables can be integrated in the same way. The must accept five arguments (even if they are unused):
\itemize{
\item \code{.spat}---a \code{\link{SpatRaster}} that defines the possible locations of the individual given the data at each time step;
\item \code{.bathy}---the \code{.bathy} \code{\link{SpatRaster}} (above);
\item \code{.obs}---the \code{.obs} \code{\link{data.table}} (above);
\item \code{.t}---an integer that defines the current time step (i.e., row in \code{.obs});
\item \code{...}---Any additional arguments passed to the function;
}}

\item{.save_record, .save_cumulative}{Logical inputs that control options for saving outputs in memory.
\itemize{
\item \code{.save_record} defines whether or not to save the record of the possible locations of the individual at each time step in the \code{record} element of the output;
\item \code{.save_cumulative} defines whether or not to save a cumulative (probability-of-use) map, derived from the normalised summation of each element in \code{record} in the \code{map} element of the output;
}}

\item{.write_record}{A named list, passed to \code{\link[terra:writeRaster]{terra::writeRaster}}, to save the \code{record} \code{SpatRaster}s to file at each time step. The \code{filename} argument should define the directory in which to write files. Files are named by time step (i.e., 1.tif, 2.tif, ..., N.tif).}

\item{.progress}{A logical variable that defines whether or not to implement a progress bar (via \code{\link[progress:progress_bar]{progress::progress_bar()}}).}

\item{.prompt}{A logical variable that defines whether or not a user prompt is required between time steps. If provided, the function plots the possible locations of the individual at each time step. This is useful for diagnostics.}

\item{.verbose}{A logical variable that defines whether or not to print messages to the console or to file to relay function progress. If \code{con = ""}, messages are printed to the console; otherwise, they are written to file (see below).}

\item{.con}{If \code{.verbose = TRUE}, \code{.con} is character string that defines the full pathway to a \code{.txt} file (which can be created on-the-fly) into which messages are written to relay function progress. This approach, rather than printing to the console, is recommended for clarity, speed and debugging.}
}
\value{
The function returns an \code{\linkS4class{ac_record}} object.
}
\description{
This function is the back-end of the acoustic-container and acoustic-container depth-contour algorithms.
}
\examples{
#### Define datasets
acoustics <- dat_acoustics[individual_id == 25, ]
archival <- dat_archival[individual_id == 25, ]

#### Process datasets
obs <- acs_setup_obs(acoustics, archival, "2 mins", 500)
obs <- obs[1:200, ]
head(obs, 25)

#### Define overlapping receivers
# Define detection containers
gebco <- dat_gebco()
dat_moorings$receiver_range <- 500
containers <- acs_setup_detection_containers(gebco, dat_moorings)
terra::plot(containers[[3]])
# Identify receivers with overlapping containers for each array design
overlaps <- acs_setup_detection_overlaps(containers, dat_moorings)

#### Define detection kernels
kernels <-
  acs_setup_detection_kernels(dat_moorings,
                              .calc_detection_pr = acs_setup_detection_pr,
                              .bathy = gebco)

#### Example (1): AC algorithm minimal implementation
# This implementation assumes there are no overlapping receivers!
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_kernels = kernels,
      .save_record = TRUE)
# The function returns an ac_record-class object
class(out_ac)
summary(out_ac)
# The archive element contains
# * `record` - a time series of maps that define the individual's possible locations
# * `map` - a cumulative map (if requested)
out_ac$archive
terra::plot(out_ac$archive$record[[1]])
terra::plot(out_ac$archive$record[[120]])

#### Example (2): Create a cumulative map on the fly
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_kernels = kernels,
      .save_record = TRUE,
      .save_cumulative = TRUE)
terra::plot(out_ac$archive$map)

#### Example (3): Account for receiver overlaps
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .save_record = TRUE,
      .save_cumulative = TRUE)
terra::plot(out_ac$archive$map)

#### Example (4): Write record to file
# This is useful for longer time series
path <- file.path(tempdir(), "patter")
dir.create(path)
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .write_record = list(filename = path))

#### Customise verbose options
# Suppress progress bar
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .progress = FALSE,
      .save_record = TRUE)
# Use prompt = TRUE for debugging
if (interactive()) {
  out_ac <-
    acs(obs,
        .bathy = gebco,
        .detection_overlaps = overlaps,
        .detection_kernels = kernels,
        .progress = FALSE,
        .save_record = TRUE,
        .prompt = TRUE)
}
# Use con to write messages to file
# * This is highly recommended
log.txt <- tempfile(fileext = ".txt")
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .save_record = TRUE,
      .con = log.txt)
readLines(log.txt) |> utils::head()
# Suppress messages
# * This is not recommended
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .save_record = TRUE,
      .verbose = FALSE)

#### Example (5): Implement ACDC algorithm via depth error function
# Define depth error function
# * We imagine the individual's depth is known Â± 25 m with equal probability
calc_depth_error   <- function(...) matrix(c(-25, 25), nrow = 2)
# Define shallow/deep depth limits
obs$depth_shallow <- obs$depth + calc_depth_error(obs$depth)[1, ]
obs$depth_deep    <- obs$depth + calc_depth_error(obs$depth)[2, ]
# Define function to update AC layer, accepting four arguments
# * The SpatRaster that defines the possible locations of the individual given the AC algorithm
# * The bathymety Raster
# * The observations data.table
# & The time step (used to index obs if necessary)
update_ac <- function(.spat, .bathy, .obs, .t, ...) {
  .spat * (.bathy >= .obs$depth_shallow[.t] & .bathy <= .obs$depth_deep[.t])
}
# Test function works as expected
blank <- terra::setValues(gebco, 1)
update_ac(blank, gebco, obs, 1) |> terra::plot()
# Implement ACDC algorithm
out_acdc <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .update_ac = update_ac,
      .save_record = TRUE,
      .verbose = FALSE)

# Compare AC and ACDC algorithms
require(graphics)
pp <- par(mfrow = c(3, 2))
lapply(1:3, \(i) {
  out_ac$archive$record[[i]] |>
    terra::plot(main = paste("AC", i))
  out_acdc$archive$record[[i]] |>
    terra::plot(main = paste("ACDC", i))
}) |> invisible()
par(pp)

#### Example (6): Implement ACDC algorithm via probabilistic function
# We assume the individual's true depth is normally distributed around the observed depth
calc_pr_given_depth <- function(.depth_seabed, .depth_obs) {
  dnorm(.depth_seabed, mean = .depth_obs, sd = 1)
}
# Test function works as expected
# * If the observed depth is 30 m, this is the implies set of possible locations
pr_given_depth <- terra::app(gebco, fun = \(x) calc_pr_given_depth(x, .depth_obs = 30))
terra::plot(pr_given_depth)
# Update update_ac() function
update_ac <- function(.spat, .bathy, .obs, .t, ...) {
  # (optional) You could add other surfaces in here too
  .spat * terra::app(.bathy, fun = \(x) calc_pr_given_depth(x, .depth_obs = .obs$depth[.t]))
}
# Implement ACDC algorithm
out_acdc <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .update_ac = update_ac,
      .save_record = TRUE,
      .verbose = FALSE)

}
\seealso{
For internal helpers, see \verb{.acs_*} functions.
}
\author{
Edward Lavender
}
