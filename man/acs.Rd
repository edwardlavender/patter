% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/acs.R
\name{acs}
\alias{acs}
\title{AC* algorithms}
\source{
This function evolved from the \code{.acs()}, \code{.acs_pl()}, \href{https://edwardlavender.github.io/flapper/reference/ac.html}{\code{ac}} and \href{https://edwardlavender.github.io/flapper/reference/acdc.html}{\code{acdc}} functions in the \href{https://github.com/edwardlavender/flapper}{\code{flapper}} package. Key developments include:
\itemize{
\item Implementation of the algorithm over a single timeline;
\item Re-parameterisation of container dynamics at each time step with respect to the possible locations of the individual given the data, given the past and given the future;
\item Exploitation of \code{\link{data.table}} and \code{\link{terra}} for substantially improved speed;
\item The use of \code{\link[terra:buffer]{terra::buffer()}} to represent container dynamics, which is faster and removes the polygon versus grid discrepancy in \href{https://github.com/edwardlavender/flapper}{\code{flapper}};
\item Implementation of the \code{.ac_update} argument to implement the ACDC algorithm (and related approaches) with enhanced flexibility;
}
}
\usage{
acs(
  .obs,
  .bathy,
  .detection_overlaps = NULL,
  .detection_kernels,
  .update_ac = NULL,
  ...,
  .save_cumulative = FALSE,
  .save_record = FALSE,
  .write_record = NULL,
  .progress = TRUE,
  .prompt = FALSE,
  .verbose = TRUE,
  .con = ""
)
}
\arguments{
\item{.obs}{A \code{\link{data.table}} with observations, typically from \code{\link[=acs_setup_obs]{acs_setup_obs()}}. At a minimum, \code{.obs} is expected to contain the following columns:
\itemize{
\item \code{timestep}---an \code{integer} that defines the time step;
\item \code{timestamp}---a regular sequences of \code{POSIXct} time stamps;
\item \code{date}---a \code{character} that defines the date;
\item \code{detection_id}---an \code{integer} vector that uniquely defines each detection;
\item \code{detection}---an \code{integer} that distinguishes the time steps at which detections were (1) or were not (0) recorded;
\item \code{receiver_id}---a \code{list} that defines the receiver(s) that recorded detections at each time step;
\item \code{buffer_past}---a \code{double} that controls container growth from the past to the present;
\item \code{buffer_future}---a \code{double} that controls container shrinkage from the future to the present;
}

Other columns can be included as necessary for \code{.update_ac} (see below).}

\item{.bathy}{A \code{\link{SpatRaster}} that defines the grid over which the algorithms are implemented. This layer should be the same as that used to define \code{.detection_overlaps} (via \code{\link[=acs_setup_detection_containers]{acs_setup_detection_containers()}} and \code{\link[=acs_setup_detection_overlaps]{acs_setup_detection_overlaps()}}) and \code{.detection_kernels} (via \code{\link[=acs_setup_detection_kernels]{acs_setup_detection_kernels()}}).}

\item{.detection_overlaps}{(optional) A named \code{list} of detection container overlaps, defined over \code{.bathy}, from \code{\link[=acs_setup_detection_overlaps]{acs_setup_detection_overlaps()}}. If un-supplied, it is silently assumed that receiver detection containers do not overlap. If supplied, receiver overlaps are taken into account in detection probability calculations.}

\item{.detection_kernels}{A named \code{list} of detection probability kernels, defined over \code{.bathy}, from \code{\link[=acs_setup_detection_kernels]{acs_setup_detection_kernels()}}.}

\item{.update_ac, ...}{(optional) A function and additional arguments used to update the \code{\link{SpatRaster}} that defines the possible locations of the individual given the data (according to the AC algorithm) at each time step. For example, if you have depth observations, you could use a depth-error model to define a probability surface that describes the possible locations of the individual at each time step and combine this, via \code{.update_ac}, with the surface from the AC algorithm. Information from other variables can be integrated in the same way. The function must accept five arguments in the following order (even if they are unused):
\itemize{
\item \code{.spat}---a \code{\link{SpatRaster}} that defines the possible locations of the individual given the data at each time step;
\item \code{.bathy}---the \code{.bathy} \code{\link{SpatRaster}} (above);
\item \code{.obs}---the \code{.obs} \code{\link{data.table}} (above);
\item \code{.t}---an integer that defines the current time step (i.e., row in \code{.obs});
\item \code{...}---Any additional arguments passed to the function;
}}

\item{.save_record, .save_cumulative}{Logical inputs that control options for saving outputs in memory.
\itemize{
\item \code{.save_record} defines whether or not to save the record of the possible locations of the individual at each time step in the \code{record} element of the output. This is only sensible for relatively short time series (use \code{.write_record}, below, otherwise).
\item \code{.save_cumulative} defines whether or not to save a cumulative (probability-of-use) map, derived from the normalised summation of each element in \code{record} in the \code{map} element of the output. In general, this is not necessary since AC* outputs are refined by particle filtering (see \code{\link[=pf_forward]{pf_forward()}}) before mapping.
}}

\item{.write_record}{A named list, passed to \code{\link[terra:writeRaster]{terra::writeRaster}}, to save the \code{record} \code{\link{SpatRaster}}s to file at each time step. The \code{filename} argument should define the directory in which to write files. Files are named by \code{.obs$timestep} (i.e., \verb{1.tif}, \verb{2.tif}, ..., \code{N.tif}). This is typically desirable but considerably reduces speed.}

\item{.progress}{A logical variable that defines whether or not to implement a progress bar (via \code{\link[progress:progress_bar]{progress::progress_bar()}}).}

\item{.prompt}{A logical variable that defines whether or not a user prompt is required between time steps. If provided, the function plots the possible locations of the individual at each time step. This is useful for diagnostics.}

\item{.verbose}{A logical variable that defines whether or not to print messages to the console or to file to relay function progress. If \code{con = ""}, messages are printed to the console; otherwise, they are written to file (see below).}

\item{.con}{If \code{.verbose = TRUE}, \code{.con} is character string that defines the full pathway to a \code{.txt} file (which can be created on-the-fly) into which messages are written to relay function progress. This approach, rather than printing to the console, is recommended for clarity, speed and debugging.}
}
\value{
The function returns an \code{\linkS4class{acs}} object.
}
\description{
This function implements the acoustic-container (AC) algorithm and its extensions (e.g., the acoustic-container depth-contour (ACDC) algorithm).
}
\section{Background}{
For a full description of the AC* algorithms, see the resources linked in 'Source' below.
}

\section{Tips}{
\itemize{
\item \strong{Datasets}. It is good practice to ensure that the datasets that underpin the AC* algorithms (e.g., acoustic data, receiver servicing dates, archival data, receiver locations), as used in \verb{acs_setup_*} functions are aligned (i.e., defined for the same individual, the same receiver(s) and the same time frame). Use a consistent bathymetry grid in all functions. We have tested functions using a bathymetry grid with a Universal Transverse Mercator Projection. We believe other projections should work, providing the units of variables are comparable, but this is untested.
\item \strong{False detections.}. The usual data processing considerations for passive acoustic telemetry data apply with the AC* algorithms. Of particular importance is to check for false detections and to check whether, given the assumed detection range(s) (see \code{\link[=acs_setup_detection_containers]{acs_setup_detection_containers()}}) and mobility parameter (see \code{\link[=acs_setup_obs]{acs_setup_obs()}}), the individual could have moved have between sequential receivers within the available time. It is worth checking this before implementing \code{\link[=acs]{acs()}} because this check only requires you to consider sequential detections (and should take seconds), while \code{\link[=acs]{acs()}} may consider may intermediate time steps (depending on the implementation) and generally requires longer computation times. See the following functions as a starting point:
\itemize{
\item \href{https://rdrr.io/github/ocean-tracking-network/glatos/man/false_detections.html}{\code{false_detections}} in the \href{https://github.com/ocean-tracking-network/glatos}{\code{glatos}} package;
\item \href{https://edwardlavender.github.io/flapper/reference/process_false_detections_sf.html}{\code{process_false_detections_sf}} in the \href{https://github.com/edwardlavender/flapper}{\code{flapper}} package;
\item \href{https://edwardlavender.github.io/flapper/reference/get_detection_overlaps.html}{\code{get_detection_overlaps}} in the \href{https://github.com/edwardlavender/flapper}{\code{flapper}} package;
}
\item \strong{Mobility}. Before you implement the AC* algorithms, check your parameterisation of \code{.mobility} (see \code{\link[=acs_setup_obs]{acs_setup_obs()}}) aligns with the data. See the following functions as a starting point:
\itemize{
\item \href{https://edwardlavender.github.io/flapper/reference/get_mvt_mobility.html}{\code{get_mvt_mobility_from_acoustics}} in the \href{https://github.com/edwardlavender/flapper}{\code{flapper}} package;
\item \href{https://edwardlavender.github.io/flapper/reference/get_mvt_mobility.html}{\code{get_mvt_mobility_from_archival}} in the \href{https://github.com/edwardlavender/flapper}{\code{flapper}} package;
}
\item \strong{Depth}. For implementations of the ACDC algorithm and its derivatives via \code{.update_ac}, it is often preferable to check that the assumed models always identify at least some locations in which the individual could have been located at each time step. For example, in the ACDC algorithm, if your depth-error model is too restrictive, there may be no possible locations in which the individual can be located at a given time step. It is quicker to identify this and resolve it before implementing an AC* algorithm with an inappropriate depth-error model.
}
}

\section{Feature requests}{
Please submit a \href{https://github.com/edwardlavender/patter/issues}{feature request} if you would like to see new features added to this function (and associated routines).
\itemize{
\item \strong{Time-specific detection kernels.} This function does not currently support temporally varying detection kernels (although receiver-specific detection kernels are fine).
\item \strong{Paralellisation.} This function does not currently implement parallelisation (unlike predecessor functions in the \href{https://github.com/edwardlavender/flapper}{\code{flapper}} package). However, the new approach is simpler and faster.
}
}

\examples{
#### Define datasets
acoustics <- dat_acoustics[individual_id == 25, ]
archival <- dat_archival[individual_id == 25, ]

#### Process datasets
obs <- acs_setup_obs(acoustics, archival, "2 mins", 500)
obs <- obs[1:200, ]
head(obs, 25)

#### Define overlapping receivers
# Define detection containers
gebco <- dat_gebco()
dat_moorings$receiver_range <- 500
containers <- acs_setup_detection_containers(gebco, dat_moorings)
terra::plot(containers[[3]])
# Identify receivers with overlapping containers for each array design
overlaps <- acs_setup_detection_overlaps(containers, dat_moorings)

#### Define detection kernels
kernels <-
  acs_setup_detection_kernels(dat_moorings,
                              .calc_detection_pr = acs_setup_detection_pr,
                              .bathy = gebco)

#### Example (1): AC algorithm minimal implementation
# This implementation assumes there are no overlapping receivers!
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_kernels = kernels,
      .save_record = TRUE)
# The function returns an acs-class object
class(out_ac)
summary(out_ac)
# This contains:
# * `record` - a time series of maps that define the individual's possible locations
# * `map` - a cumulative map (if requested)
terra::plot(out_ac$record[[1]])
terra::plot(out_ac$record[[120]])

#### Example (2): Create a cumulative map on the fly
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_kernels = kernels,
      .save_record = TRUE,
      .save_cumulative = TRUE)
terra::plot(out_ac$map)

#### Example (3): Account for receiver overlaps
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .save_record = TRUE,
      .save_cumulative = TRUE)
terra::plot(out_ac$map)

#### Example (4): Write record to file
# This is useful for longer time series
path <- file.path(tempdir(), "patter")
dir.create(path)
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .write_record = list(filename = path))

#### Customise verbose options
# Suppress progress bar
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .progress = FALSE,
      .save_record = TRUE)
# Use prompt = TRUE for debugging
if (interactive()) {
  # This produces a map of possible locations at each time step
  # * red: possible location boundaries given data
  # * orange: possible location boundaries given past
  # * green: possible location boundaries given future
  # * background: possible locations at the present time given data, past and future
  out_ac <-
    acs(obs,
        .bathy = gebco,
        .detection_overlaps = overlaps,
        .detection_kernels = kernels,
        .progress = FALSE,
        .save_record = TRUE,
        .prompt = TRUE)
}
# Use con to write messages to file
# * This is highly recommended
log.txt <- tempfile(fileext = ".txt")
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .save_record = TRUE,
      .con = log.txt)
readLines(log.txt) |> utils::head()
# Suppress messages
# * This is not recommended
out_ac <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .save_record = TRUE,
      .verbose = FALSE)

#### Example (5): Implement ACDC algorithm via depth error function
# Define depth error function
# * We imagine the individual's depth is known ± 25 m with equal probability
calc_depth_error   <- function(...) matrix(c(-25, 25), nrow = 2)
# Define shallow/deep depth limits
obs$depth_shallow <- obs$depth + calc_depth_error(obs$depth)[1, ]
obs$depth_deep    <- obs$depth + calc_depth_error(obs$depth)[2, ]
# Define function to update AC layer, accepting four arguments
# * The SpatRaster that defines the possible locations of the individual given the AC algorithm
# * The bathymety Raster
# * The observations data.table
# & The time step (used to index obs if necessary)
update_ac <- function(.spat, .bathy, .obs, .t, ...) {
  .spat * (.bathy >= .obs$depth_shallow[.t] & .bathy <= .obs$depth_deep[.t])
}
# Test function works as expected
blank <- terra::setValues(gebco, 1)
update_ac(blank, gebco, obs, 1) |> terra::plot()
# Implement ACDC algorithm
out_acdc <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .update_ac = update_ac,
      .save_record = TRUE,
      .verbose = FALSE)

# Compare AC and ACDC algorithms
require(graphics)
pp <- par(mfrow = c(3, 2))
lapply(1:3, \(i) {
  out_ac$record[[i]] |>
    terra::plot(main = paste("AC", i))
  out_acdc$record[[i]] |>
    terra::plot(main = paste("ACDC", i))
}) |> invisible()
par(pp)

#### Example (6): Implement ACDC algorithm via probabilistic function
# We assume the individual's true depth is normally distributed around the observed depth
calc_pr_given_depth <- function(.depth_seabed, .depth_obs) {
  dnorm(.depth_seabed, mean = .depth_obs, sd = 1)
}
# Test function works as expected
# * If the observed depth is 30 m, this is the implies set of possible locations
pr_given_depth <- terra::app(gebco, fun = \(x) calc_pr_given_depth(x, .depth_obs = 30))
terra::plot(pr_given_depth)
# Update update_ac() function
update_ac <- function(.spat, .bathy, .obs, .t, ...) {
  # (optional) You could add other surfaces in here too
  .spat * terra::app(.bathy, fun = \(x) calc_pr_given_depth(x, .depth_obs = .obs$depth[.t]))
}
# Implement ACDC algorithm
out_acdc <-
  acs(obs,
      .bathy = gebco,
      .detection_overlaps = overlaps,
      .detection_kernels = kernels,
      .update_ac = update_ac,
      .save_record = TRUE,
      .verbose = FALSE)

}
\seealso{
This function is part of a series of functions designed to implement the AC* algorithms. See:
\enumerate{
\item \code{\link[=acs_setup_obs]{acs_setup_obs()}} to set up observations;
\item \code{\link[=acs_setup_detection_containers]{acs_setup_detection_containers()}} and \code{\link[=acs_setup_detection_overlaps]{acs_setup_detection_overlaps()}} to identify receiver overlaps (used in detection probability calculations);
\item \code{\link[=acs_setup_detection_kernels]{acs_setup_detection_kernels()}} to define detection probability kernels;
\item \code{\link[=acs]{acs()}} to implement the AC algorithm;
}

For internal helpers, see \verb{.acs_*()} functions.
}
\author{
Edward Lavender
}
