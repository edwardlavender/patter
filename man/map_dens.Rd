% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map.R
\name{as.im.SpatRaster}
\alias{as.im.SpatRaster}
\alias{as.owin.SpatRaster}
\alias{as.owin.sf}
\alias{map_dens}
\title{Map: point density}
\usage{
as.im.SpatRaster(.map)

as.owin.SpatRaster(.map, .im = NULL)

as.owin.sf(.poly, .bbox = sf::st_bbox(.poly), .invert = TRUE)

map_dens(
  .map,
  .owin = as.owin.SpatRaster(.map),
  .coord = NULL,
  .discretise = FALSE,
  .shortcut = list(),
  ...,
  .fterra = FALSE,
  .plot = TRUE,
  .use_tryCatch = TRUE,
  .verbose = getOption("patter.verbose")
)
}
\arguments{
\item{.map}{A \code{\link{SpatRaster}} that defines the grid on which the UD is represented. If \code{.coord = NULL}, \code{.map} also defines the points (and associated weights) that are smoothed (see \code{\link[=.map_coord]{.map_coord()}}). \strong{The coordinate reference system of \code{.map} must be planar} and specified.}

\item{.im, .owin}{A pixel image representation of \code{.map} (see \code{\link[=as.im.SpatRaster]{as.im.SpatRaster()}} and \code{\link[spatstat.geom:im]{spatstat.geom::im()}}) and an observation window (see \code{\link[=as.owin.SpatRaster]{as.owin.SpatRaster()}}, \code{\link[=as.owin.sf]{as.owin.sf()}} and \code{\link[spatstat.geom:owin]{spatstat.geom::owin()}}). If un-supplied, \code{.owin} is defined automatically from \code{.map} via \code{\link[=as.owin.SpatRaster]{as.owin.SpatRaster()}}, which uses \code{\link[=as.im.SpatRaster]{as.im.SpatRaster()}} internally (see Details). For faster results, use a rectangular or polygon observation window (see \code{\link[=as.owin.sf]{as.owin.sf()}}).}

\item{.poly, .bbox, .invert}{For \code{\link[=as.owin.sf]{as.owin.sf()}} to construct observation windows from \code{sf} objects.
\itemize{
\item \code{.poly} is an \code{sf} polygon object;
\item \code{.bbox} is the bounding of a simple feature (see \code{\link[sf:st_bbox]{sf::st_bbox()}});
\item \code{.invert} is a logical variable that defines whether or not to invert \code{.poly} (e.g., to turn a terrestrial polygon into an aquatic polygon);
}}

\item{.coord}{(optional) Coordinates for density estimation, provided in any format accepted by \code{\link[=.map_coord]{.map_coord()}}. \strong{Coordinates must be planar}.}

\item{.discretise}{If \code{.coord} is provided, \code{.discretise} is a \code{logical} variable that defines whether or not to discretise coordinates on \code{.map} (see \code{\link[=.map_coord]{.map_coord()}}).}

\item{.shortcut}{(optional) A named \code{list} from a previous call to \code{\link[=map_dens]{map_dens()}}. If supplied, the function short-cuts straight to smoothing (\code{.owin}, \code{.coord} and \code{.discretise} are silently unused).}

\item{...}{Arguments for density estimation, passed to \code{\link[spatstat.explore:density.ppp]{spatstat.explore::density.ppp()}}, such as \code{sigma} (i.e., the bandwidth). \code{at} and \code{se} are not permitted.}

\item{.fterra}{A \code{logical} variable that defines whether or not to parallelise \code{\link[terra:resample]{terra::resample()}}.}

\item{.plot}{A \code{logical} variable that defines whether or not to plot the output.}

\item{.use_tryCatch}{A \code{logical} variable that controls error handling:
\itemize{
\item If \code{.use_tryCatch = FALSE}, if density estimation fails with an error, the function fails with the same error.
\item If \code{.use_tryCatch = TRUE}, if density estimation fails with an error, the function produces a warning with the error message and returns \code{NULL}.
}}

\item{.verbose}{User output control (see \code{\link{patter-progress}} for supported options).}
}
\value{
The function returns a named \code{list}, with the following elements:
\itemize{
\item \code{x}: a \code{\link[spatstat.geom:ppp]{spatstat.geom::ppp}} object that defines points for density estimation;
\item \code{D}: a \code{\link[spatstat.geom:im]{spatstat.geom::im}} object of estimated intensities, from \code{\link[spatstat.explore:density.ppp]{spatstat.explore::density.ppp()}};
\item \code{ud}: a normalised \code{\link{SpatRaster}};
}

\code{D} and \code{ud} are \code{NULL} if \code{\link[spatstat.explore:density.ppp]{spatstat.explore::density.ppp()}} fails and \code{.use_tryCatch = TRUE}.
}
\description{
\code{\link[=map_dens]{map_dens()}} creates a smoothed utilisation distribution (UD).
}
\details{
\code{\link[=map_dens]{map_dens()}} smooths (a) a \code{\link{SpatRaster}} or (b) a set of inputted coordinates.

\code{\link[=.map_coord]{.map_coord()}} (and \code{\link[=.map_mark]{.map_mark()}}) are used to define coordinates and weights:
\itemize{
\item If \code{.coords} is \code{NULL}, \code{.map} cell coordinates are used for density estimation and cell values are used as weights.
\item If coordinates are supplied, coordinates are optionally re-expressed on \code{.map} and then used for density estimation. This option is generally faster. Coordinate weights are defined by \code{\link[=.map_mark]{.map_mark()}}.
}

Cell coordinates and associated weights are converted to a \code{\link[spatstat.geom:ppp]{spatstat.geom::ppp()}} object, which is passed, alongside the observation window (\code{.owin}), to \code{\link[spatstat.explore:density.ppp]{spatstat.explore::density.ppp()}} for the estimation. Weights must sum to one.

\code{\link[=as.im.SpatRaster]{as.im.SpatRaster()}}, \code{\link[=as.owin.SpatRaster]{as.owin.SpatRaster()}} and \code{\link[=as.owin.sf]{as.owin.sf()}} are helper functions that convert a \code{\link{SpatRaster}} to a pixel image and an observation window (see \code{\link[spatstat.geom:owin]{spatstat.geom::owin()}}). \code{\link[=as.im.SpatRaster]{as.im.SpatRaster()}} is based on \code{maptools::as.im.RasterLayer()}. \code{\link[=as.owin.SpatRaster]{as.owin.SpatRaster()}} either defines a rectangular window, if there are no NAs on \code{.map}, or converts \code{.map} directly to an \code{owin} object. Gridded observation windows, especially if high resolution, considerably slow down density estimation and may exhaust vector memory. Use rectangular windows, or convert \code{sf} objects to polygon windows (via \code{\link[=as.owin.sf]{as.owin.sf()}}) if possible.

If \code{.shortcut} is supplied, the preceding steps can be skipped and the function short-cuts straight to smoothing. Use this option if the preceding steps are slow and you want to trial different smoothing options (such as \code{sigma} functions).

Coordinates and associated weights are smoothed via \code{\link[spatstat.explore:density.ppp]{spatstat.explore::density.ppp()}} into an image. Pixel resolution and smoothing parameters such as bandwidth can be controlled via \code{...} arguments which are passed directly to this function. The output is translated into a gridded probability density surface (on the geometry defined by \code{.map}). This process may use \code{\link[terra:resample]{terra::resample()}}, which can be parallelised via \code{.fterra} (which controls the \code{threads} argument of that function).

This function replaces \verb{flapper::kud*()} and \verb{flapper::pf_kud*()} routines based on \code{adehabitatHR} (see \href{https://edwardlavender.github.io/flapper/reference/}{here}).
}
\examples{
library(data.table)
library(dtplyr)
library(dplyr, warn.conflicts = FALSE)
library(spatstat.explore)

#### Define map
map <- dat_gebco()

#### Example (1): Use sample coordinates
# Sample example coordinates
coord <-
  map |>
  terra::spatSample(size = 5000L, xy = TRUE, cell = TRUE, na.rm = TRUE) |>
  select("x", "y") |>
  as.data.table()
# Use x, y coordinates
map_dens(map, .coord = coord)
# Other formats are acceptable
map_dens(map, .coord = as.matrix(coord))
map_dens(map, .coord = as.data.frame(coord))
# `cell_x` and `cell_y` coordinates are acceptable
map_dens(map, .coord = coord[, .(cell_x = x, cell_y = y)])
# A SpatRaster is also acceptable
pou <- map_pou(map, .coord = coord, .plot = FALSE)$ud
map_dens(pou)

#### Example (2): Use coordinates from `sim_path_walk()`
coord <- dat_path()
map_dens(map, .coord = coord)
points(coord$x, coord$y, cex = 0.5)

#### Example (3): Use coordinates from `coa()`
# Use example dataset
coord <- dat_coa()
map_dens(map, .coord = coord)
points(coord$x, coord$y, cex = 0.5)

#### Example (4): Use a time series of coordinates from `pf_*()`
# Use example dataset
# * We use particles from the forward filter (`?pf_filter()`);
# * Particles are equally weighted b/c re-sampling is implemented every time step;
# * It is better to use outputs from the particle smoother;
coord <- dat_pff()$states
map_dens(map, .coord = coord)
# points(coord$x, coord$y, cex = 0.5)

#### Example (5): Control smoothing via `spatstat.explore::density.ppp()`
# E.g. use fixed bandwidth:
map_dens(map, .coord = coord, sigma = 5)
map_dens(map, .coord = coord, sigma = 100)
# E.g., perform automatic bandwidth selection using cross validation:
map_dens(map, .coord = coord, sigma = bw.diggle)
map_dens(map, .coord = coord, sigma = bw.scott)
map_dens(map, .coord = coord, sigma = bw.ppl)
map_dens(map, .coord = coord, sigma = bw.CvL)
}
\seealso{
\verb{map_*()} functions build maps of space use:
\itemize{
\item \code{\link[=map_pou]{map_pou()}} maps probability-of-use;
\item \code{\link[=map_dens]{map_dens()}} maps point density;
\item \code{\link{map_hr}}\verb{_*()} functions map home ranges;
}

All maps are represented as \code{\link{SpatRaster}}s.

To derive coordinates for mapping patterns of space use for tagged animals, see:
\itemize{
\item \code{\link[=coa]{coa()}} to calculate centre-of-activity;
\item \code{\link[=pf_filter]{pf_filter()}} and associates to sample locations using particle filtering;
}
}
