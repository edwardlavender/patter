% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map.R
\name{as.im.SpatRaster}
\alias{as.im.SpatRaster}
\alias{as.owin.SpatRaster}
\alias{as.owin.sf}
\alias{map_dens}
\title{Map: point density}
\usage{
as.im.SpatRaster(.map)

as.owin.SpatRaster(.map, .im = NULL)

as.owin.sf(.poly, .bbox = sf::st_bbox(.poly), .invert = TRUE)

map_dens(
  .map,
  .im = NULL,
  .owin = NULL,
  .coord = NULL,
  .discretise = FALSE,
  ...,
  .plot = TRUE,
  .use_tryCatch = TRUE,
  .verbose = getOption("patter.verbose")
)
}
\arguments{
\item{.map}{A \code{\link{SpatRaster}} that defines the grid on which the UD is represented. If \code{.coord = NULL}, \code{.map} also defines the points (and associated weights) that are smoothed (see \code{\link[=.map_coord.dt]{.map_coord.dt()}}). \strong{The coordinate reference system of \code{.map} must be planar} and specified.}

\item{.im, .owin}{A pixel image representation of \code{.map} (see \code{\link[=as.im.SpatRaster]{as.im.SpatRaster()}} and \code{\link[spatstat.geom:im]{spatstat.geom::im()}}) and an observation window (see \code{\link[=as.owin.SpatRaster]{as.owin.SpatRaster()}}, \code{\link[=as.owin.sf]{as.owin.sf()}} and \code{\link[spatstat.geom:owin]{spatstat.geom::owin()}}). These objects may be computed automatically from \code{.map} (with rectangular or gridded observation windows used by default, depending on whether or not \code{.map} contains \code{NA}s), but this option can be over-ridden. For faster results, use a rectangular or polygon observation window (see \code{\link[=as.owin.sf]{as.owin.sf()}}). If \code{.coord} is supplied, \code{.im} is necessarily (re)-defined internally (see Details).}

\item{.poly, .bbox, .invert}{For \code{\link[=as.owin.sf]{as.owin.sf()}} to construct observation windows from \code{sf} objects.
\itemize{
\item \code{.poly} is an \code{sf} polygon object;
\item \code{.bbox} is the bounding of a simple feature (see \code{\link[sf:st_bbox]{sf::st_bbox()}});
\item \code{.invert} is a logical variable that defines whether or not to invert \code{.poly} (e.g., to turn a terrestrial polygon into an aquatic polygon);
}}

\item{.coord}{(optional) Coordinates for density estimation, provided in any format accepted by \code{\link[=.map_coord]{.map_coord()}}. \strong{Coordinates must be planar}.}

\item{.discretise}{A \code{logical} variable that defines whether or not to discretise coordinates on \code{.map} (see \code{\link[=.map_coord]{.map_coord()}}).}

\item{...}{Arguments for density estimation, passed to \code{\link[spatstat.explore:density.ppp]{spatstat.explore::density.ppp()}}, such as \code{sigma} (i.e., the bandwidth).}

\item{.plot}{A \code{logical} variable that defines whether or not to plot the output.}

\item{.use_tryCatch}{A \code{logical} variable that controls error handling:
\itemize{
\item If \code{.use_tryCatch = FALSE}, if density estimation fails with an error, the function fails with the same error.
\item If \code{.use_tryCatch = TRUE}, if density estimation fails with an error, the function produces a warning with the error message and returns \code{NULL}.
}}

\item{.verbose}{User output control (see \code{\link{patter-progress}} for supported options).}
}
\value{
The function returns a normalised \code{\link{SpatRaster}} (or \code{NULL} if \code{\link[spatstat.explore:density.ppp]{spatstat.explore::density.ppp()}} fails and \code{.use_tryCatch = TRUE}).
}
\description{
\code{\link[=map_dens]{map_dens()}} creates a smoothed utilisation distribution (UD).
}
\details{
\code{\link[=map_dens]{map_dens()}} smooths (a) a \code{\link{SpatRaster}} or (b) a set of inputted coordinates.

\code{\link[=.map_coord]{.map_coord()}} (and \code{\link[=.map_mark]{.map_mark()}}) are used to define coordinates and weights:
\itemize{
\item If \code{.coords} is \code{NULL}, \code{.map} cell coordinates are used for density estimation and cell values are used as weights.
\item If coordinates are supplied, coordinates are optionally re-expressed on \code{.map} and then used for density estimation. This option is generally faster. Coordinate weights are defined by \code{\link[=.map_mark]{.map_mark()}}.
}

Cell coordinates are converted to a \code{\link[spatstat.geom:ppp]{spatstat.geom::ppp()}} object, which is passed, alongside the observation window (\code{.owin}) and an image of the weights to \code{\link[spatstat.explore:density.ppp]{spatstat.explore::density.ppp()}} for the estimation. Weights must sum to one.

\code{\link[=as.im.SpatRaster]{as.im.SpatRaster()}}, \code{\link[=as.owin.SpatRaster]{as.owin.SpatRaster()}} and \code{\link[=as.owin.sf]{as.owin.sf()}} are helper functions that convert a \code{\link{SpatRaster}} to a pixel image and an observation window (see \code{\link[spatstat.geom:owin]{spatstat.geom::owin()}}). \code{\link{as.im.SpatRaster}} is based on \code{maptools::as.im.RasterLayer()}. \code{\link[=as.owin.SpatRaster]{as.owin.SpatRaster()}} either defines a rectangular window, if there are no NAs on \code{.map}, or converts \code{.map} directly to an \code{owin} object. Gridded observation windows, especially if high resolution, considerably slow down density estimation and may exhaust vector memory. Use rectangular windows, or convert \code{sf} objects to polygon windows (via \code{\link[=as.owin.sf]{as.owin.sf()}}) if possible.

Coordinates and associated weights are smoothed via \code{\link[spatstat.explore:density.ppp]{spatstat.explore::density.ppp()}} into an image. Pixel resolution and smoothing parameters such as bandwidth can be controlled via \code{...} arguments which are passed directly to this function. The output is translated into a gridded probability density surface (on the geometry defined by \code{.map}).
}
\examples{
#### Set up examples
# Packages
require(data.table)
require(dplyr, warn.conflicts = FALSE)
require(spatstat.explore)
# Define grid
gebco <- dat_gebco()

#### Example (1): Use sample coordinates
# Sample example coordinates
cxy <-
  gebco |>
  terra::spatSample(size = 5000L, xy = TRUE, cell = TRUE, na.rm = TRUE) |>
  select("x", "y") |>
  as.data.table()
# Use x, y coordinates
map_dens(gebco, .coord = cxy)
# Other formats are acceptable
map_dens(gebco, .coord = as.matrix(cxy))
map_dens(gebco, .coord = as.data.frame(cxy))
# cell_x and cell_y coordinates are acceptable
map_dens(gebco, .coord = cxy[, .(cell_x = x, cell_y = y)])
# A SpatRaster is also acceptable
pou <- map_pou(gebco, .coord = cxy, .plot = FALSE)
map_dens(pou)

#### Example (2): Use coordinates from coa()
# Use example dataset
out_coa <- dat_coa()
map_dens(gebco, .coord = out_coa[, .(x = coa_x, y = coa_y)])

#### Example (3): Use a time series of coordinates from pf_*()
# Use example dataset
coord <- pf_coord(dat_pfbk(), .bathy = gebco)
map_dens(gebco, .coord = coord)

#### Example (4): Control smoothing via `spatstat.explore::density.ppp()`
# E.g. use fixed bandwidth:
map_dens(gebco, .coord = coord, sigma = 5)
map_dens(gebco, .coord = coord, sigma = 100)
# E.g., perform automatic bandwidth selection using cross validation:
map_dens(gebco, .coord = coord, sigma = bw.diggle)
map_dens(gebco, .coord = coord, sigma = bw.scott)
map_dens(gebco, .coord = coord, sigma = bw.ppl)
map_dens(gebco, .coord = coord, sigma = bw.CvL)
}
