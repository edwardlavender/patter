% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/models.R
\name{ModelMove}
\alias{ModelMove}
\alias{model_move_xy}
\alias{.model_move}
\alias{ModelMoveXY}
\alias{ModelMoveXYZ}
\alias{ModelMoveCXY}
\alias{ModelMoveCXYZ}
\alias{model_move_xyz}
\alias{model_move_cxy}
\alias{model_move_cxyz}
\title{Movement models}
\usage{
model_move_xy(
  .mobility = "750.0",
  .dbn_length = "truncated(Gamma(1, 250.0), upper = 750.0)",
  .dbn_heading = "Uniform(-pi, pi)"
)

model_move_xyz(
  .mobility = "750.0",
  .dbn_length = "truncated(Gamma(1, 250.0), upper = 750.0)",
  .dbn_heading = "Uniform(-pi, pi)",
  .dbn_z = "truncated(Normal(100.0, 250.0), lower = 0.0, upper = 350.0)"
)

model_move_cxy(
  .mobility = "750.0",
  .dbn_length = "truncated(Gamma(1.0, 750.0), upper = 750.0)",
  .dbn_heading_delta = "Normal(0, 0.5)"
)

model_move_cxyz(
  .mobility = "750.0",
  .dbn_length = "truncated(Gamma(1.0, 750.0), upper = 750.0)",
  .dbn_heading_delta = "Normal(0, 0.5)",
  .dbn_z_delta = "Normal(0, 3.5)"
)
}
\arguments{
\item{.mobility, .dbn_length, .dbn_heading, .dbn_heading_delta, .dbn_z, .dbn_z_delta}{\code{Character} strings that define movement model components:
\itemize{
\item \code{.mobility}---the maximum movement distance between two time steps (m);
\item \code{.dbn_length}---the distribution of step lengths (m);
\item \code{.dbn_heading}---the distribution of headings (rad);
\item \code{.dbn_heading_delta}---the distribution of changes in heading, i.e., turning angle (rad);
\item \code{.dbn_z}---the distribution of depths;
\item \code{.dbn_z_delta}---the distribution of changes in depth;
}}
}
\value{
\verb{model_move_*()} functions return a \code{character} string that defines a \code{\link{ModelMove}} instance for evaluation in \code{Julia}. The \code{\link{class}} of the output is \code{character} plus \code{ModelMove} and \code{ModelMoveXY}, \code{ModelMoveXYZ}, \code{ModelMoveCXY} or \code{ModelMoveCXYZ} (see \code{\link{plot.ModelMove}}). If the map (\code{env}) does not exist in \code{Julia}, an error is thrown.
}
\description{
\code{\link{ModelMove}} is Abstract Type in \href{https://edwardlavender.github.io/Patter.jl}{\code{Patter.jl}} that groups movement model sub-types, of which instances can be created via an \code{R} \verb{model_move_*()} function.
}
\details{
Movement model sub-types are \code{Julia} structures that hold the components of movement models. From an \code{R}-user perspective, you can think of a \code{\link{ModelMove}} sub-type as an \code{S4}-\code{\link{class}}-like object, with slots for the components of a movement model. With a movement model instance, we can simulate movements and evaluate the density of movements from one state (location) to another.

The following movement models are built in to \href{https://edwardlavender.github.io/Patter.jl}{\code{Patter.jl}}:
\itemize{
\item Random walks (RWs):
\itemize{
\item \code{\link{ModelMoveXY}}
\item \code{\link{ModelMoveXYZ}}
}
\item Correlated random walks (CRWs):
\itemize{
\item \code{\link{ModelMoveCXY}}
\item \code{\link{ModelMoveCXYZ}}
}
}

See \href{https://edwardlavender.github.io/Patter.jl}{\code{Patter.jl}} or \code{JuliaCall::julia_help("ModelMove")} for the fields of the built-in sub-types. Briefly, all sub-types include:
\itemize{
\item A \code{map} field, that defines the region(s) within which movements are permitted. In \code{R}, it is convenient to represent \code{map} as a \code{\link{SpatRaster}}, where \code{NAs} define inhospitable habitats (e.g., land). This should made available to \code{Julia} \code{\link{ModelMove}} constructors as \code{env} via \code{\link[=set_map]{set_map()}};
\item The \code{mobility} parameter;
\item Additional model-specific components (such as fields for the distribution of step lengths and headings in the case of two-dimensional random walks);
}

In \code{\link{patter}}, movement models are required:
\itemize{
\item To simulate movement paths, via \code{\link[=sim_path_walk]{sim_path_walk()}};
\item To run the particle filter, via \code{\link[=pf_filter]{pf_filter()}};
\item To run the particle smoother, via \code{\link[=pf_smoother_two_filter]{pf_smoother_two_filter()}};
}

In \code{R} functions, the movement-model instance is specified via the \code{.model_move} argument. This argument expects a \code{character} string defining a \code{\link{ModelMove}} instance that can be evaluated in \code{Julia} (that is, a \code{\link{ModelMove}} constructor). \verb{model_move_*()} functions are convenience functions for the specification of these constructors for the built-in sub-types. All \code{\link{ModelMove}} instances contain a \code{map} field that defines the region(s) within which movements are permitted. To use a \verb{model_move_*()} function, the map should be available in \code{Julia} as \code{env} (see \code{\link[=set_map]{set_map()}}). The additional components of the movement model are specified via \verb{model_move_*()} function arguments as \code{character} strings of \code{Julia} code. Currently implemented \verb{model_move_*()} functions are:
\itemize{
\item \code{\link[=model_move_xy]{model_move_xy()}}, which specifies a RW in X and Y of sub-type \code{\link{ModelMoveXY}} in terms of the distributions of step lengths and headings;
\item \code{\link[=model_move_xyz]{model_move_xyz()}}, which specifies a RW in X, Y and Z of sub-type \code{\link{ModelMoveXY}} in terms of the distributions of step lengths, headings and depths;
\item \code{\link[=model_move_cxy]{model_move_cxy()}}, which specifies a CRW in X and Y of sub-type \code{\link{ModelMoveXY}} in terms of the distributions of step lengths and turning angles;
\item \code{\link[=model_move_cxyz]{model_move_cxyz()}}, which specifies a CRW in X, Y and Z of sub-type \code{\link{ModelMoveCXYZ}} in terms of the distributions of step lengths, turning angles and changes in depth;
}

See \href{https://discourse.julialang.org/t/a-comparison-of-common-distributions-in-julia-python-and-r/61604}{here} for the translations of distributions in \code{R} (e.g., \verb{*norm()}) into \code{Julia} (e.g., \code{Normal()}).

To plot the dimensions of a movement model, see \code{\link{plot.ModelMove}}. To visualise realisations of a model, see \code{\link[=sim_path_walk]{sim_path_walk()}}.

In \code{Julia}, \code{\link{ModelMove}} instances are used to simulate states via \href{https://edwardlavender.github.io/Patter.jl}{\code{Patter.simulate_step()}}. In the particle smoother, the density of movement from one state to another is evaluated by \href{https://edwardlavender.github.io/Patter.jl}{\code{Patter.logpdf_step()}}. These are generic functions. Different methods are dispatched according to the input model. For the built-in \code{\link{ModelMove}} sub-types, corresponding methods for these routines are also built-in. For custom \code{\link{ModelMove}} sub-types, the methods need to be provided.

To use custom \code{\link{ModelMove}} sub-types, see Examples.
}
\examples{
if (patter_run(.geospatial = FALSE)) {

  library(data.table)
  library(JuliaCall)

  #### Connect to Julia
  julia_connect()
  set_seed()

  #### Define the `map`
  # `map` is the region within which movements are permitted
  # In `R`, we represent this as a `SpatRaster`
  # Here, we have a bathymetry `SpatRaster` for the west coast of Scotland:
  # * NaNs define regions into which movement is not permitted
  # * (i.e., on land, in the case of aquatic animals)
  map <- dat_gebco()
  # Plot map (on Windows/MacOS only!)
  # terra::plot(map)

  # Using `set_map()` makes the map available as a object called 'env' in `Julia`
  # > This is required as a component of all movement models
  set_map(map)

  #### Example (1a): Use `model_move_xy()` with default options
  # `model_move_*()` functions simply return a character string of Julia code
  # (Downstream functions can evaluate this code, as shown below)
  model_move_xy()

  #### Example (1b): Customise `model_move_xy()`
  # Use a truncated normal distribution for step lengths:
  model_move_xy(.mobility = "750.0",
          .dbn_length = "truncated(Normal(250, 50), lower = 0.0, upper = 750.0)")
  # Use an exponential distribution for step lengths
  model_move_xy(.mobility = "750.0",
          .dbn_length = "truncated(Exponential(0.01), upper = 750.0)")
  # Use a biased random walk
  model_move_xy(.dbn_heading = "VonMises(0, 1)")
  # Get help on a distribution in Julia:
  julia_help("Exponential")

  #### Example (2): Use `model_move_xyz()`
  # Use default options
  model_move_xyz()
  # Customise model components
  model_move_xyz(.mobility = "750.0",
           .dbn_length = "truncated(Exponential(0.01), upper = 750.0)",
           .dbn_z = "truncated(Gamma(1.0, 250.0), lower = 0.0, upper = 350.0)")

  #### Example (3): Use `model_move_cxy()`
  # Use default options
  model_move_cxy()
  # Customise model components
  model_move_cxy(.mobility = "750.0",
            .dbn_length = "truncated(Normal(250, 50), lower = 0.0, upper = 750.0)",
            .dbn_heading_delta = "Normal(0, 0.25)")

  #### Example (4): Use `model_move_cxyz()`
  # Use default options
  model_move_cxyz()
  # Customise model components
  model_move_cxyz(.mobility = "750.0",
            .dbn_length = "truncated(Normal(250, 50), lower = 0.0, upper = 750.0)",
            .dbn_heading_delta = "Normal(0, 0.25)",
            .dbn_z_delta = "Normal(0, 2.5)")

  #### Example (4): Visualise movement model component distributions
  # See `?plot.ModelMove`
  plot(model_move_xy())

  #### Example (5): Visualise movement model realisations (trajectories)
  if (patter_run()) {

    # See `?sim_path_walk`
    # Define a timeline for the simulation
    timeline <- seq(as.POSIXct("2016-01-01", tz = "UTC"),
                    length.out = 1000L, by = "2 mins")
    # Define an initial location
    x <- 708212.6
    y <- 6251684
    origin <- data.table(map_value = terra::extract(map, cbind(x, y))[1, 1],
                         x = x, y = y)
    # Collect essential arguments for `sim_path_walk()`
    args <- list(.map = map,
                 .xinit = origin,
                 .timeline = timeline,
                 .state = "StateXY",
                 .n_path = 2L, .one_page = FALSE)
    # Compare different movement models via `sim_path_walk()`
    pp <- par(mfrow = c(2, 2))
    args$.model_move <- model_move_xy()
    do.call(sim_path_walk, args)
    args$.model_move <- model_move_xy(.dbn_heading = "VonMises(0.1, 0.1)")
    do.call(sim_path_walk, args)
    par(pp)

  }

  #### Example (6): Use movement models in the particle filter
  # See `?pf_filter()`

  #### Example (7): Use custom movement model types
  # Patter contains multiple built-in `State` and `ModelMove` sub-types that you can use
  # ... (with custom parameters) simulate movements and for particle filtering.
  # See the help file for `?State` to use a new sub-type.

}
}
\seealso{
The routines in \code{\link{patter}} for the simulation of individual movements, observations and statistical modelling are built upon three Abstract Types defined in \code{Julia}:
\itemize{
\item See \code{\link{State}} for individual-state (location) structures;
\item See \code{\link{ModelMove}} for movement model structures;
\item See \code{\link{ModelObs}} for observation model structures;
}
}
\author{
Edward Lavender
}
