% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cl_lapply-internal.R
\name{cl}
\alias{cl}
\alias{cl_lapply_chunk}
\alias{cl_lapply_elm}
\alias{cl_check}
\alias{cl_check_chunk}
\alias{cl_cores}
\alias{cl_chunks}
\alias{cl_export}
\alias{cl_stop}
\title{Parallelisation helpers (internal)}
\usage{
cl_lapply_chunk(.x, .fun, ..., .chunk_fun, .cl, .varlist, .envir)

cl_lapply_elm(.x, .fun, ..., .cl, .varlist, .envir)

cl_check(.cl = NULL, .varlist = NULL)

cl_check_chunk(.fun, .cl, .chunk, .chunk_fun)

cl_cores(.cl = NULL)

cl_chunks(.cl = NULL, .length, .nout = getOption("pboptions")$nout)

cl_export(.cl = NULL, .varlist = NULL, .envir = .GlobalEnv)

cl_stop(.cl = NULL)
}
\value{
\itemize{
\item \code{\link[=cl_lapply_chunk]{cl_lapply_chunk()}} returns a \code{list}.
\item \code{\link[=cl_lapply_elm]{cl_lapply_elm()}} returns a \code{list}.
\item \code{\link[=cl_cores]{cl_cores()}} returns an \code{integer}.
\item \code{\link[=cl_chunks]{cl_chunks()}} returns a list of \code{integer}s.
\item \code{\link[=cl_check]{cl_check()}}, \code{\link[=cl_check_chunk]{cl_check_chunk()}}, \code{\link[=cl_export]{cl_export()}} and \code{\link[=cl_stop]{cl_stop()}} return \code{invisible(NULL)}.
}
}
\description{
A set of internal wrappers for \code{\link[parallel:parallel-package]{parallel::parallel}} functions that facilitate the implementation of parallel routines in functions via \code{\link[pbapply:pbapply]{pbapply::pblapply()}}.
}
\details{
\code{\link[=cl_lapply]{cl_lapply()}} is the main function. This is a wrapper for \code{\link[pbapply:pbapply]{pbapply::pblapply()}} that handles cluster checking, set up, batch processing and cluster closure, using the following functions:
\itemize{
\item \code{\link[=cl_lapply_chunk]{cl_lapply_chunk()}} implements a function over chunks;
\item \code{\link[=cl_lapply_elm]{cl_lapply_elm()}} implements a function over individual elements;
\item \code{\link[=cl_check]{cl_check()}} checks \code{.cl} and \code{.varlist} arguments, as inputted to a parent function. For example, if \code{.cl = NULL}, \code{.varlist} should also be \code{NULL}.
\item \code{\link[=cl_check_chunk]{cl_check_chunk()}} checks \code{.chunk} arguments.
\item \code{\link[=cl_cores]{cl_cores()}} identifies the number of cores specified.
\item \code{\link[=cl_chunks]{cl_chunks()}} defines a \code{list}, with one element for each 'chunk' that contains an \code{integer} vector of the positions of an object over which to iterate serially in each chunk.
\item \code{\link[=cl_export]{cl_export()}} implements \code{\link[parallel:clusterApply]{parallel::clusterExport()}} if both \code{.cl} and \code{.varlist} are specified
\item \code{\link[=cl_stop]{cl_stop()}} implements \code{\link[parallel:makeCluster]{parallel::stopCluster()}} if \code{.cl} is a \code{cluster} object from \code{\link[parallel:makeCluster]{parallel::makeCluster()}}.
}

These routines evolved from \href{https://edwardlavender.github.io/flapper/reference/cl.html}{\verb{flapper::cl_*()}} functions.
}
\author{
Edward Lavender
}
\keyword{internal}
