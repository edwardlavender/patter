% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cl_lapply.R
\name{cl}
\alias{cl}
\alias{cl_lapply}
\alias{cl_check}
\alias{cl_cores}
\alias{cl_chunks}
\alias{cl_export}
\alias{cl_stop}
\title{Parallelisation helpers}
\usage{
cl_lapply(.x, .fun, ..., .cl = NULL, .varlist = NULL, .use_chunks = FALSE)

cl_check(.cl = NULL, .varlist = NULL)

cl_cores(.cl = NULL)

cl_chunks(.cl = NULL, .length)

cl_export(.cl = NULL, .varlist = NULL)

cl_stop(.cl = NULL)
}
\arguments{
\item{.x}{A \code{list} over which to iterate.}

\item{.fun, ...}{A function that is applied to elements of \code{.x} alongside any optional arguments to \code{.fun}.}

\item{.cl}{(optional) A cluster from \code{\link[parallel:makeCluster]{parallel::makeCluster()}} or an integer that defines the number of child processes (see \code{\link[pbapply:pbapply]{pbapply::pblapply()}}).}

\item{.varlist}{(optional) A character vector of objects for export (see \code{\link[parallel:clusterApply]{parallel::clusterExport()}}). If \code{.cl} is a cluster, this may be required. Exported objects must be located in the global environment.}

\item{.use_chunks}{A logical vector that defines whether to parallelise over 'chunks' (\code{TRUE}) or over the elements of \code{.x} (\code{FALSE}). If \code{.use_chunks = TRUE}, \code{.x} is split into \emph{n} chunks (one per core) that are processed in parallel; within each chunk \code{.x} is updated iteratively.}

\item{.length}{An integer that defines the number of elements in the iteration.}
}
\value{
\itemize{
\item \code{\link[=cl_lapply]{cl_lapply()}} returns a \code{list}.
\item \code{\link[=cl_cores]{cl_cores()}} returns an \code{integer}.
\item \code{\link[=cl_chunks]{cl_chunks()}} returns a list of \code{integer}s.
\item \code{\link[=cl_check]{cl_check()}}, \code{\link[=cl_export]{cl_export()}} and \code{\link[=cl_stop]{cl_stop()}} return \code{invisible(NULL)}.
}
}
\description{
A set of wrappers for \code{\link[parallel:parallel-package]{parallel::parallel}} functions that facilitate the implementation of parallel routines in functions via \code{\link[pbapply:pbapply]{pbapply::pblapply()}}.
}
\details{
\code{\link[=cl_lapply]{cl_lapply()}} is a wrapper for \code{\link[pbapply:pbapply]{pbapply::pblapply()}} that handles cluster checking, set up and closure, using the following functions:
\itemize{
\item \code{\link[=cl_check]{cl_check()}} checks \code{.cl} and \code{.varlist} arguments, as inputted to a parent function. For example, if \code{.cl = NULL}, \code{.varlist} should also be \code{NULL}.
\item \code{\link[=cl_cores]{cl_cores()}} identifies the number of cores specified.
\item \code{\link[=cl_chunks]{cl_chunks()}} defines a list, with one element for core specified, that contains an integer vector of the positions of an object over which to iterate serially in each chunk.
\item \code{\link[=cl_export]{cl_export()}} implements \code{\link[parallel:clusterApply]{parallel::clusterExport()}} if both \code{.cl} and \code{.varlist} are specified.
\item \code{\link[=cl_stop]{cl_stop()}} implements \code{\link[parallel:makeCluster]{parallel::stopCluster}} if \code{.cl} is a \code{cluster} object from \code{\link[parallel:makeCluster]{parallel::makeCluster()}}.
}

These routines evolved from the \href{https://edwardlavender.github.io/flapper/reference/cl.html}{\verb{cl_*()}} functions in \href{https://github.com/edwardlavender/flapper}{\code{flapper}}.
}
\seealso{
See \href{https://edwardlavender.github.io/flapper/reference/flapper-tips-parallel.html}{\code{flapper-tips-parallel}} for further information about parallelisation.
}
\author{
Edward Lavender
}
