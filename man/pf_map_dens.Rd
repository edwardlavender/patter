% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pf_map.R
\name{as.im.SpatRaster}
\alias{as.im.SpatRaster}
\alias{as.owin.SpatRaster}
\alias{as.owin.sf}
\alias{pf_map_dens}
\title{PF: map point density}
\usage{
as.im.SpatRaster(.xpf)

as.owin.SpatRaster(.xpf, .im = NULL)

as.owin.sf(.poly, .bbox = sf::st_bbox(.poly), .invert = TRUE)

pf_map_dens(
  .xpf,
  .im = NULL,
  .owin = NULL,
  .coord = NULL,
  .plot = TRUE,
  .use_tryCatch = TRUE,
  .verbose = TRUE,
  ...
)
}
\arguments{
\item{.xpf}{A \code{\link{SpatRaster}} that defines the grid for density estimation and, if \code{.coord = NULL}, the points (and associated weights) that are smoothed. Weights must sum to one. The coordinate reference system of \code{.xpf} must be planar and specified.}

\item{.im, .owin}{A pixel image representation of \code{.xpf} (see \code{\link[=as.im.SpatRaster]{as.im.SpatRaster()}} and \code{\link[spatstat.geom:im]{spatstat.geom::im()}}) and an observation window (see \code{\link[=as.owin.SpatRaster]{as.owin.SpatRaster()}}, \code{\link[=as.owin.sf]{as.owin.sf()}} and \code{\link[spatstat.geom:owin]{spatstat.geom::owin()}}). These objects may be computed automatically from \code{.xpf} (with rectangular or gridded observation windows used by default, depending on whether or not \code{.xpf} contains \code{NA}s), but this option can be over-ridden. For faster results, use a rectangular or polygon observation window (see \code{\link[=as.owin.sf]{as.owin.sf()}}). If \code{.coord} is supplied, \code{.im} is necessarily (re)-defined internally (see Details).}

\item{.poly, .bbox, .invert}{For \code{\link{as.owin.sf}} to construct observation windows from \code{sf} objects.
\itemize{
\item \code{.poly} is an \code{sf} polygon object;
\item \code{.bbox} is the bounding of a simple feature (see \code{\link[sf:st_bbox]{sf::st_bbox()}});
\item \code{.invert} is a logical variable that defines whether or not to invert \code{.poly} (e.g., to turn a terrestrial polygon into an aquatic polygon);
}}

\item{.coord}{(optional) A \code{\link{matrix}}, \code{\link{data.frame}} or \code{\link{data.table}} with x and y coordinates, in columns named \code{x} and \code{y} or \code{cell_x} and \code{cell_y}. \code{x} and \code{y} columns are used preferentially. Coordinates must be planar.  A \code{timestep} column can also be included if there are multiple possible locations at each time step. A \code{mark} column can be included with coordinate weights; otherwise, equal weights are assumed (see Details). Other columns are ignored.}

\item{.plot}{A \code{logical} variable that defines whether or not to plot the output.}

\item{.use_tryCatch}{A \code{logical} variable that controls error handling:
\itemize{
\item If \code{.use_tryCatch = FALSE}, if density estimation fails with an error, the function fails with the same error.
\item If \code{.use_tryCatch = TRUE}, if density estimation fails with an error, the function produces a warning with the error message and returns \code{NULL}.
}}

\item{.verbose}{Controls on function prompts and messages (see \code{\link[=pf_forward]{pf_forward()}}.}

\item{...}{Arguments passed to \code{\link[spatstat.explore:density.ppp]{spatstat.explore::density.ppp()}}, such as \code{sigma} (i.e., the bandwidth).}
}
\value{
The function returns a normalised \code{\link{SpatRaster}} (or \code{NULL} if \code{\link[spatstat.explore:density.ppp]{spatstat.explore::density.ppp()}} fails and \code{.use_tryCatch = TRUE}).
}
\description{
\code{\link[=pf_map_dens]{pf_map_dens()}} creates a smoothed density map (e.g., of particle samples).
}
\details{
\code{\link[=pf_map_dens]{pf_map_dens()}} smooths (a) a \code{\link{SpatRaster}} or (b) a set of inputted coordinates:
\itemize{
\item If \code{.coords} is \code{NULL}, \code{.xpf} cell coordinates are used for density estimation and cell values are used as weights.
\item If coordinates are supplied, coordinates are re-expressed on \code{.xpf} and then used for density estimation. This option is generally faster. Equal weights are assumed unless specified. Default or supplied weights are normalised to sum to one at each time step. The total weight of each location within time steps is calculated and then these weights are aggregated by location across the whole time series and renomalised. See the internal \code{\link[=.pf_map_weights]{.pf_map_weights()}} function for full details.
}

Cell coordinates are converted to a \code{\link[spatstat.geom:ppp]{spatstat.geom::ppp()}} object, which is passed, alongside the observation window (\code{.owin}) and an image of the weights to \code{\link[spatstat.explore:density.ppp]{spatstat.explore::density.ppp()}} for the estimation. Weights must sum to one.

\code{\link[=as.im.SpatRaster]{as.im.SpatRaster()}}, \code{\link[=as.owin.SpatRaster]{as.owin.SpatRaster()}} and \code{\link[=as.owin.sf]{as.owin.sf()}} are helper functions that convert a \code{\link{SpatRaster}} to a pixel image and an observation window (see \code{\link[spatstat.geom:owin]{spatstat.geom::owin()}}). \code{\link{as.im.SpatRaster}} is based on \code{maptools::as.im.RasterLayer()}. \code{\link[=as.owin.SpatRaster]{as.owin.SpatRaster()}} either defines a rectangular window, if there are no NAs on \code{.xpf}, or converts \code{.xpf} directly to an \code{owin} object. Gridded observation windows, especially if high resolution, considerably slow down density estimation and may exhaust vector memory. Use rectangular windows, or convert \code{sf} objects to polygon windows (via \code{as.owin.sf()}]) if possible.

Coordinates and associated weights are smoothed via \code{\link[spatstat.explore:density.ppp]{spatstat.explore::density.ppp()}} into an image. Pixel resolution and smoothing parameters such as bandwidth can be controlled via \code{...} arguments which are passed directly to this function. The output is translated into a gridded probability density surface (on the geometry defined by \code{.xpf}).
}
\seealso{
\itemize{
\item The PF (forward simulation) is implemented by \code{\link[=pf_forward]{pf_forward()}};
\item PF is supported by:
\itemize{
\item Setup helpers, namely \code{\link[=pf_setup_files]{pf_setup_files()}};
}
\item The backward pass is implemented by \code{\link[=pf_backward_*]{pf_backward_*()}};
\item Movement paths are built from PF outputs via \code{pf_path()} functions:
\itemize{
\item \code{\link[=pf_path]{pf_path()}} reconstructs paths;
\item \code{\link[=pf_path_pivot]{pf_path_pivot()}} supports path reconstruction;
}
\item To reconstruct maps of space use, see:
\itemize{
\item \code{\link[=pf_coords]{pf_coords()}} to extract particle coordinates;
\item \code{\link[=pf_map_pou]{pf_map_pou()}} for probability-of-use maps;
\item \code{\link[=pf_map_dens]{pf_map_dens()}} for smooth utilisation distributions;
\item \code{\link[=get_hr]{get_hr()}} for home range estimates;
}
}
}
