% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/models.R
\name{ModelObs}
\alias{ModelObs}
\alias{.model_obs}
\alias{ModelObsAcousticLogisTrunc}
\alias{ModelObsDepthUniform}
\alias{ModelObsDepthNormalTrunc}
\title{Observation models}
\description{
\code{\link{ModelObs}} is Abstract Type in \href{https://edwardlavender.github.io/Patter.jl}{\code{Patter.jl}} that groups observation model sub-types.
}
\details{
Observation model sub-types are \code{Julia} structures that hold the parameters of observation models. From an \code{R}-user perspective, you can think of a \code{\link{ModelObs}} sub-type as an \code{S4}-\code{\link{class}}-like object, with slots for the parameters of an observation model. With an observation model structure, we can simulate new observations and evaluate the log-probability of existing observations.

The following observation models are built in to \href{https://edwardlavender.github.io/Patter.jl}{\code{Patter.jl}}:
\itemize{
\item \code{\link{ModelObsAcousticLogisTrunc}}
\item \code{\link{ModelObsDepthUniform}}
\item \code{\link{ModelObsDepthNormalTrunc}}
}

See \href{https://edwardlavender.github.io/Patter.jl}{\code{Patter.jl}} or \code{JuliaCall::julia_help("ModelObs")} for the fields of the built-in sub-types.

In \code{\link{patter}}, observation models are required:
\itemize{
\item To simulate new observational datasets, via \code{\link[=sim_observations]{sim_observations()}};
\item To run the particle filter, via \code{\link[=pf_filter]{pf_filter()}};
}

Observation model sub-types should be specified as a \code{character} vector alongside a \code{list} of \href{s}{\code{data.table}} that contain the parameter values for each model. Internally, observation model sub-types and parameters are instantiated and used to simulate observations or in the particle filter. The simulation of observations is implemented via \href{https://edwardlavender.github.io/Patter.jl}{\code{Patter.simulate_obs()}}. In the particle filter, log-probabilities are evaluated by \href{https://edwardlavender.github.io/Patter.jl}{\code{Patter.logpdf_obs()}}. These are generic functions. Different methods are dispatched according to the input model. For the built-in \code{\link{ModelObs}} sub-types, corresponding methods for these routines are also built-in. For custom \code{\link{ModelObs}} sub-types, the methods need to be provided.

To use custom \code{\link{ModelObs}} sub-types, see Examples.
}
\examples{
# Patter contains multiple built-in `ModelObs` sub-types that you can use
# ... (with custom parameters) simulate observations and for particle filtering.
# To use a new sub-type, follow the workflow below. Some extra work is required
# ... because we have to register the sub-type in `Julia` and write the
# ... required methods to simulate observations and/or calculate log probabilities.

if (julia_run()) {

  library(JuliaCall)
  library(data.table)

  #### Julia set up
  # Connect to Julia
  julia <- julia_connect()
  # Set seed
  set_seed()
  # Export map to Julia
  map <- dat_gebco()
  set_map(map)

  #### Simulate path(s)
  # > We simulate a path in four dimensions (see `?StateXYZD`)
  timeline <- seq(as.POSIXct("2016-01-01", tz = "UTC"),
                  length.out = 1000L, by = "2 mins")
  paths <- sim_path_walk(.map = map,
                         .timeline = timeline,
                         .state = "StateXYZD",
                         .xinit = NULL, .n_path = 1L,
                         .model_move = move_xyzd(),
                         .plot = TRUE,
                         .one_page = TRUE)

  #### Simulate observations arising from the simulated path
  # Register a custom `ModelObs` sub-type in Julia
  # * We imagine a pelagic animal in which the depth at each time step
  # * ... is normally distributed around the previous depth.
  # * We write a `ModelObs` sub-type in `Julia` that contains the parameters
  # * ... for this model (i.e., the sigma parameter of the normal distribution).
  julia_command(
    '
    struct ModelObsDepthNormal <: Patter.ModelObs
      sensor_id::Int64
      depth_sigma::Float64
    end
  '
  )
  # Define a `Patter.simulate_obs()` method
  # * We need to specify a function that simulates depths for `ModelObsDepthNormal`
  # * We simulate depths around the previous depth (`state.z`), truncated between
  # * ... the depth of the seabed (`state.map_value`) and the surface.
  julia_command(
    '
  function Patter.simulate_obs(state::StateXYZD, model::ModelObsDepthNormal, t::Int64)
    dbn   = truncated(Normal(state.z, model.depth_sigma), 0, state.map_value)
    rand(dbn)
  end
  '
  )
  # Simulate observations
  obs <- sim_observations(.timeline = timeline,
                          .model_obs = "ModelObsDepthNormal",
                          .model_obs_pars = list(data.table(sensor_id = 1L, depth_sigma = 5)))
  obs <- obs$ModelObsDepthNormal[[1]]
  # Plot simulated depth trajectory
  # * Blue: simulated time series
  # * Grey: seabed depth for simulated time series
  ylim <- range(c(obs$obs, paths$map_value) * -1)
  plot(obs$timestamp, obs$obs * -1, ylim = ylim, col = "royalblue", type = "l")
  lines(paths$timestamp, paths$map_value * -1, col = "grey")

  #### Run the forward filter
  # (optional) Define initial states, by:
  # A) Starting the filter in the correct location by masking `.map`
  # B) Specifying a `map_init()` method based on the observation model
  # C) Specifying a complete data.table of initial state(s)
  origin       <- terra::setValues(map, NA)
  cell         <- terra::cellFromXY(map, cbind(paths$x[1], paths$y[1]))
  origin[cell] <- paths$map_value[1]
  # Define a `Patter.logpdf_obs()` method
  # * This is used to evaluate the log probability of a depth observation
  julia_command(
    '
  function Patter.logpdf_obs(state::State, model::ModelObsDepthNormal, t::Int64, obs::Float64)
    dbn   = truncated(Normal(state.map_value, model.depth_sigma),
                      0.0, state.map_value)
    logpdf(dbn, obs)
  end
  '
  )
  # Run the filter
  fwd <- pf_filter(.map = origin,
                   .timeline = timeline,
                   .state = "StateXYZD",
                   .yobs = list(obs),
                   .model_obs = "ModelObsDepthNormal",
                   .model_move = move_xyzd(),
                   .n_particle = 1000L)
  # Visualise reconstructed time series
  # * Black: particle depths
  # * Blue: simulated time series
  # * Grey: seabed depth for simulated time series
  ylim <- range(c(fwd$states$z, obs$obs, paths$map_value) * -1)
  plot(fwd$states$timestamp, fwd$states$z * -1, ylim = ylim, pch = ".")
  lines(obs$timestamp, obs$obs * -1 , col = "royalblue")
  lines(paths$timestamp, paths$map_value * -1, col = "grey")

}
}
\seealso{
The routines in \code{\link{patter}} for the simulation of individual movements, observations and statistical modelling are built upon three Abstract Types defined in \code{Julia}:
\itemize{
\item See \code{\link{State}} for individual-state (location) structures;
\item See \code{\link{ModelMove}} for movement model structures;
\item See \code{\link{ModelObs}} for observation model structures;
}
}
\author{
Edward Lavender
}
