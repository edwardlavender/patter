% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/acs-setup.R
\name{acs_setup_detection_kernels}
\alias{acs_setup_detection_kernels}
\title{AC* set up: detection kernels}
\source{
This function is based on \href{https://edwardlavender.github.io/flapper/reference/acs_setup_detection_kernels.html}{\code{flapper::acs_setup_detection_kernels}}.
}
\usage{
acs_setup_detection_kernels(
  .dlist,
  .pdetkernel = acs_setup_detection_kernel,
  .verbose = getOption("patter.verbose"),
  ...
)
}
\arguments{
\item{.dlist}{A named \code{list} of data and parameters from \code{\link[=pat_setup_data]{pat_setup_data()}}. This function requires:
\itemize{
\item \code{.dlist$data$moorings}, with the following columns: \code{receiver_id}, \code{receiver_start}, \code{receiver_end}, \code{receiver_x} and \code{receiver_y}, plus any columns used internally by \code{.pdetkernel} (see below).
\item (optional) \code{.dlist$data$services}, with the following columns: \code{receiver_id}, \code{service_start} and \code{service_end} (see \code{\link[=make_matrix_receivers]{make_matrix_receivers()}}).
\item \code{.dlist$spatial$bathy}, which defines the grid on which detection kernels are represented. \code{NA}s are used as a mask.
\item \code{.dlist$pars$spatna}, which defines whether or not masking is required.
}}

\item{.pdetkernel, ...}{A \code{function} that defines the detection kernel as a \code{\link{SpatRaster}} around a receiver (see \code{\link[=acs_setup_detection_kernel]{acs_setup_detection_kernel()}} for an example). This must accept three arguments (even if they are ignored):
\itemize{
\item \code{.mooring}---A one-row \code{\link{data.table}} that contains the information in \code{.dlist$data$moorings} for a specific receiver;
\item \code{.bathy}---A cropped \code{.dlist$spatial$bathy} \code{\link{SpatRaster}};
\item \code{.mask}---A \code{logical} variable passed down from \code{.dlist$pars$spatna};
\item \code{...} Additional arguments passed via \code{\link[=acs_setup_detection_kernels]{acs_setup_detection_kernels()}};
}}

\item{.verbose}{User output control (see \code{\link{patter-progress}} for supported options).}
}
\value{
The function returns a named \code{list}, with the following elements:
\itemize{
\item \strong{\code{pkernel}}. A named \code{list}, with one element for each receiver. Each element is a \code{\link{SpatRaster}} of the detection kernel around that receiver. Cells values define the probability of a detection, as modelled by \code{.pdetkernel}. In an AC*PF algorithm, these kernels are used to calculate the likelihood of the acoustic data (detections/non-detections). This process effectively up-weights particles near to the receiver(s) that recorded detections and down-weights particles further afield.
\item \strong{\code{loglik}}. A named \code{list}, with one element for each array design. Each element is a \code{\link{SpatRaster}} that defines the log-likelihood of non-detection at all operational receivers in that array. In an AC*PF algorithm, during detection gaps, we can extract the log-likelihood of the acoustic data (non detection) at particle locations directly from this layer.
}
}
\description{
This function is part of a set of \verb{acs_setup_*()} functions that prepare the layers required to evaluate the likelihood of acoustic observations in an AC*PF algorithm using the inbuilt functions. The function prepares the detection kernels.
}
\details{
An AC*PF algorithm is a particle filtering algorithm that incorporates acoustic observations to reconstruct the possible movements of an individual (see \code{\link[=pf_forward]{pf_forward()}}). At each time step in such an algorithm, we evaluate the likelihood of acoustic observations (the presence or absence of detections at each operational receiver, accounting for receiver placement) given particle samples. The likelihood is of each acoustic observation given each particle evaluated using a Bernoulli distribution and a detection probability parameter.

The first purpose of this function is to pre-compute detection kernels. A detection kernel is a spatial representation of detection probability \emph{around a specific receiver}. Detection kernels are computed iteratively. For each receiver, we crop \code{.dlist$spatial$bathy} to the detection range of that receiver and compute the detection kernel via \code{.pdetkernel}. This function is formulated such that detection probability declines with distance away from the receiver. Receiver-specific kernels are supported (but time-varying kernels require custom likelihood functions in \code{\link[=pf_forward]{pf_forward()}}). In \code{\link[=pf_forward]{pf_forward()}}, we evaluate the log-likelihood of acoustic observations given particle locations via \code{\link[=pf_lik_ac]{pf_lik_ac()}} using a Binomial distribution given the probabilities extracted from these layers (avoiding on-the-fly computation).

The second purpose of this function is to pre-compute the log-likelihood of non-detection at all operational receivers. The log-likelihood surface is calculated for each array design within the domain spanned by the operational receivers. In the gaps between detection, we extract log-likelihood of non detections, given particle locations, directly from these layers (avoiding on-the-fly computation).

Within the domain of receiver(s), detection kernels and non-detection log-likelihood surfaces are masked by \code{NA}s on \code{.dlist$spatial$bathy}. (Detection kernels are set to \code{0} and log-likelihoods to \code{log(0)} in cells that are \code{NA}.) However, since detection kernels (and in some instances non-detection log-likelihood surfaces) only span a subset of the study area, it may still necessary to account for inhospitable habitats in \code{\link[=pf_forward]{pf_forward()}}, either via the movement model or via a likelihood function (see \code{\link[=acs_filter_land]{acs_filter_land()}}).

Pre-calculating detection kernels is a potentially slow operation, especially for large and/or high-resolution grids (and we would like to improve this in future). However, this penalty is only required once and improves the speed of downstream likelihood calculations in \code{\link[=pf_lik_ac]{pf_lik_ac()}} in \code{\link[=pf_forward]{pf_forward()}}.

To improve speed in \code{\link[=pf_forward]{pf_forward()}}, use \code{terra:::readAll()} to force \code{\link{SpatRaster}}s into memory, if possible.
}
\examples{
require(data.table)

#### Define example datasets
# Define example 'moorings' dataset
# * Receivers 3 and 4 overlap in space but receiver 5 is further afield
m <- data.table(receiver_id = c(3, 4, 5),
                receiver_start = as.Date(c("2016-01-01", "2016-01-01", "2016-01-01")),
                receiver_end = as.Date(c("2016-01-05", "2016-01-05", "2016-01-05")),
                receiver_easting = c(706124.9, 706012.7, 709379.0),
                receiver_northing = c(6265030, 6264993, 6260093),
                receiver_range = 750)
# Define example 'services' dataset
s <- data.table(receiver_id = c(3, 5),
                service_start = as.Date(c("2016-01-01", "2016-01-01")),
                service_end = as.Date(c("2016-01-01", "2016-01-01")))
# Set up data list as usual
dlist <- pat_setup_data(.moorings = m,
                        .services = s,
                        .bathy = dat_gebco(),
                        .lonlat = FALSE)

#### Example (1): Implement function using specified inputs
# Implement function
k <- acs_setup_detection_kernels(.dlist = dlist,
                                 .pdetkernel = acs_setup_detection_kernel)
# Examine list elements
summary(k)
# Examine detection probability kernels
pp <- par(mfrow = c(1, 3))
lapply(as.character(m$receiver_id), \(id) {
  terra::plot(k$pkernel[[id]])
  points(m[m$receiver_id == id, .(receiver_easting, receiver_northing)],
         cex = 2)
}) |> invisible()
par(pp)
# Examine likelihood of non detection for each unique array design
n <- length(k$loglik)
pp <- par(mfrow = c(1, n))
lapply(seq_len(n), \(id) {
  terra::plot(exp(k$loglik[[id]]))
  points(m[m$receiver_id == id, .(receiver_easting, receiver_northing)],
         cex = 2)
}) |> invisible()
par(pp)
}
\seealso{
To implement an AC*PF algorithm, see:
\enumerate{
\item \code{\link[=pat_setup_data]{pat_setup_data()}} to set up datasets;
\item \verb{acs_setup_*()} functions to prepare layers required for likelihood calculations, i.e.:
\itemize{
\item \code{\link[=acs_setup_detection_overlaps]{acs_setup_detection_overlaps()}}, which identifies detection overlaps;
\item \code{\link[=acs_setup_detection_kernel]{acs_setup_detection_kernel()}}, which prepares a detection kernel;
\item \code{\link[=acs_setup_detection_kernels]{acs_setup_detection_kernels()}}, which prepares detection kernels;
}
\item \code{\link[=pf_setup_obs]{pf_setup_obs()}} to define a timeline of observations;
\item \code{\link[=pf_forward]{pf_forward()}} to run the simulation (using \code{\link[=pf_lik_ac]{pf_lik_ac()}} to evaluate the likelihood of acoustic observations);
}
}
\author{
Edward Lavender
}
