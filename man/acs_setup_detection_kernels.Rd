% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/acs-setup.R
\name{acs_setup_detection_kernels}
\alias{acs_setup_detection_kernels}
\title{AC* set up: define detection kernels}
\source{
This function is based on the \href{https://edwardlavender.github.io/flapper/reference/acs_setup_detection_kernels.html}{\code{acs_setup_detection_kernels}} function in the \href{https://github.com/edwardlavender/flapper}{\code{flapper}} package, where the role of detection kernels in the AC* algorithms is described extensively (see Details).
}
\usage{
acs_setup_detection_kernels(
  .dlist,
  .calc_detection_pr = acs_setup_detection_pr,
  .verbose = getOption("patter.verbose"),
  ...
)
}
\arguments{
\item{.dlist}{A named \code{list} of data and parameters from \code{\link[=pat_setup_data]{pat_setup_data()}}. This function requires:
\itemize{
\item \code{.dlist$data$moorings}, with the following columns: \code{receiver_id}, \code{receiver_start}, \code{receiver_end}, \code{receiver_x} and \code{receiver_y}, plus any columns used internally by \code{.calc_detection_pr} (see below).
\item \code{.dlist$data$services}, with the following columns: \code{receiver_id}, \code{service_start} and \code{service_end} (see \code{\link[=make_matrix_receivers]{make_matrix_receivers()}}).
\item \code{.dlist$spatial$bathy}, which defines the grid over which detection kernels are defined.
}}

\item{.calc_detection_pr, ...}{A function that defines a receiver-specific detection kernel (see \code{\link[=acs_setup_detection_pr]{acs_setup_detection_pr()}} for an example). This must accept three arguments (even if they are ignored):
\itemize{
\item \code{.mooring}---A one-row \code{\link{data.table}} that contains the information in \code{.moorings} for a specific receiver;
\item \code{.bathy}---A \code{\link{SpatRaster}} that defines the grid over which detection probability is calculated (see below);
\item \code{...} Additional arguments passed via \code{\link[=acs_setup_detection_kernels]{acs_setup_detection_kernels()}}.
Using these inputs, the function must return a \code{\link{SpatRaster}} that defines the detection kernel around a specific receiver (see Examples).
}}

\item{.verbose}{User output control (see \code{\link{patter-progress}} for supported options).}
}
\value{
The function returns a named \code{list}, with the following elements:
\itemize{
\item \strong{\code{receiver_specific_kernels}}. A \code{list}, with one element for all integers from 1 to the maximum receiver number. Any elements that do not correspond to receivers contain a \code{NULL} element. List elements that correspond to receivers contain a \code{\link{SpatRaster}} of the detection probability kernel around the relevant receiver. Cells values define the detection probability around a receiver, given \code{.calc_detection_pr} In the AC* algorithm(s), these kernels are used to up-weight location probabilities near to a receiver when it is detected (following modification to account for overlapping areas, if necessary).
\item \strong{\code{receiver_specific_inv_kernels}}. A \code{list}, as for \code{receiver_specific_kernels}, but in which elements contain the inverse detection probability kernels (i.e., 1 - detection probability). In the AC* algorithm(s), these is used to down-weight-weight location probabilities in the overlapping regions between a receiver that recorded detections and others that did not at the same time.
\item \strong{\code{array_design}}. A \code{data.frame} that defines the number and deployment times of each unique array design, resulting from receiver deployment, servicing and removal. In the times between detections, this is used to select the appropriate 'background' detection probability surface (see below). This contains the following columns:
\itemize{
\item \code{array_id}. An integer vector that defines each unique array design.
\item \code{array_start_date}. A Date that defines the start date of each array design.
\item \code{array_end_date}. A Date that defines the end date of each array design.
\item \code{array_interval}. A \code{\link[lubridate:Interval-class]{lubridate::Interval}} vector that defines the deployment period of each array design.
}
\item \strong{\code{array_design_by_date}}. A named \code{list} that defines, for each date (list element), the array design on that date (based on \code{array_id} in \code{array_design}).
\item \strong{\code{bkg_surface_by_design}}. A \code{list}, with one element for each array design, that defines the detection probability surface across all receivers deployed in that phase of the study. In areas that are covered by the detection probability kernel of a single receiver, the detection probability depends only on distance to that receiver (via \code{.calc_detection_pr}). In areas covered by multiple, overlapping kernels, detection probability represents the combined detection probability across all overlapping kernels (see Details).
\item \strong{\code{bkg_inv_surface_by_design}}. A \code{list}, as above for \code{bkg_surface_by_design}, but which contains the inverse detection probability surface (i.e., 1 - \code{bkg_surface_by_design}). In the AC* algorithm(s), this is used to up-weight areas away from receivers (or, equivalently, down-weight areas near to receivers) in the time steps between detections.
}
}
\description{
This function defines the detection kernels for the AC* algorithms.
}
\details{
This function permits receiver-specific detection kernels.
}
\examples{
require(data.table)

#### Define function inputs
# Define example 'moorings' dataset
# * Receivers 3 and 4 overlap in space but receiver 5 is further afield
m <- data.table(receiver_id = c(3, 4, 5),
                receiver_start = as.Date(c("2016-01-01", "2016-01-01", "2016-01-01")),
                receiver_end = as.Date(c("2016-01-05", "2016-01-05", "2016-01-05")),
                receiver_easting = c(706124.9, 706012.7, 709379.0),
                receiver_northing = c(6265030, 6264993, 6260093),
                receiver_range = 750)
# Define example 'services' dataset
s <- data.table(receiver_id = c(3, 5),
                service_start = as.Date(c("2016-01-01", "2016-01-01")),
                service_end = as.Date(c("2016-01-01", "2016-01-01")))
# Set up data as usual
dlist <- pat_setup_data(.moorings = m,
                       .services = s,
                       .bathy = dat_gebco(),
                       .lonlat = FALSE)

#### Example (1): Implement function using specified inputs
# Implement function
k <- acs_setup_detection_kernels(dlist, .calc_detection_pr = acs_setup_detection_pr)
# Examine list elements
summary(k)
# Examine example receiver-specific kernels
pp <- par(mfrow = c(1, 2))
lapply(c(3, 4), \(id) {
  terra::plot(k$receiver_specific_kernels[[id]])
  points(m[m$receiver_id == id, .(receiver_easting, receiver_northing)], cex = 2)
}) |> invisible()
par(pp)
# Examine example receiver-specific inverse kernels
pp <- par(mfrow = c(1, 2))
lapply(c(3, 4), \(id) {
  terra::plot(k$receiver_specific_kernels[[id]])
  points(m[m$receiver_id == id, .(receiver_easting, receiver_northing)], cex = 2)
}) |> invisible()
par(pp)
# Examine background detection Pr surfaces
# (for each unique combination of receivers that were deployed)
pp <- par(mfrow = c(1, 2))
lapply(k$bkg_surface_by_design, \(bkg) {
  terra::plot(bkg, axes = FALSE)
  box()
}) |> invisible()
par(pp)
# Examine background inverse detection Pr surfaces
pp <- par(mfrow = c(1, 2))
lapply(k$bkg_inv_surface_by_design, \(bkg) {
  terra::plot(bkg, axes = FALSE)
  box()
}) |> invisible()
par(pp)
}
\author{
Edward Lavender
}
