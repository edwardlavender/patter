% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/acs-setup.R
\name{acs_setup_detection_kernels}
\alias{acs_setup_detection_kernels}
\title{Setup detection kernels}
\usage{
acs_setup_detection_kernels(
  .moorings,
  .services = NULL,
  .calc_detection_pr,
  .bathy,
  .verbose = TRUE,
  ...
)
}
\arguments{
\item{.moorings}{TO DO}

\item{.services}{TO DO}

\item{.calc_detection_pr, ...}{TO DO}

\item{.bathy}{TO DO}

\item{.verbose}{TO DO}
}
\description{
TO DO
}
\examples{
#### Define example 'moorings' & 'services' dataset
# receivers 3 and 4 overlap in space but receiver 5 is further afield
require(data.table)
m <- data.table(receiver_id = c(3, 4, 5),
                receiver_start = as.Date(c("2016-01-01", "2016-01-01", "2016-01-01")),
                receiver_end = as.Date(c("2016-01-05", "2016-01-05", "2016-01-05")),
                receiver_easting = c(706124.9, 706012.7, 709379.0),
                receiver_northing = c(6265030, 6264993, 6260093),
                receiver_range = 500)
s <- data.table(receiver_id = c(3, 5),
                service_start = as.Date(c("2016-01-01", "2016-01-01")),
                service_end = as.Date(c("2016-01-01", "2016-01-01")))

#### Define function to calculate detection probability
# This must accept a .data & .bathy argument:
# * .data is the .moorings data for a specific receiver (e.g., containing receiver coordinates)
# * .bathy is as described above
# Using these arguments, the function must calculate detection probability around the receiver
# * This implementation supports receiver-specific detection ranges
acs_setup_detection_pr <- function(.data, .bathy, ...) {

  # Define helper function to calculate detection probability give distance
  calc_dpr <- function(distance) {
    pr <- stats::plogis(2.5 + -0.02 * distance)
    pr[distance > .data$receiver_range] <- 0
    pr
  }
  # Calculate Euclidean distance around receiver
  rxy <- matrix(c(.data$receiver_easting, .data$receiver_northing), ncol = 2)
  cell <- terra::cellFromXY(.bathy, rxy)
  grid <- terra::setValues(.bathy, NA)
  grid[cell] <- 1
  dist <- terra::distance(grid, unit = "m")
  dist <- terra::mask(dist, .bathy)
  # Convert distances to detection pr
  terra::app(dist, calc_dpr)
}
# Examine output of function for example receiver
pr <- lapply(seq_len(max(m$receiver_id)), function(id) {
  if (!(id \%in\% m$receiver_id)) return(NULL)
  acs_setup_detection_pr(m[m$receiver_id == id, , drop = FALSE], dat_gebco())
})


#### Implement function
k <- acs_setup_detection_kernels(m, s,
                                 .calc_detection_pr = acs_setup_detection_pr,
                                 .bathy = dat_gebco())

#### TO DO (continue)

}
\author{
Edward Lavender
}
