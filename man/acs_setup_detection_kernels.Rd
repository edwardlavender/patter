% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/acs-setup.R
\name{acs_setup_detection_kernels}
\alias{acs_setup_detection_kernels}
\title{AC* set up: detection kernels}
\source{
This function is based on \href{https://edwardlavender.github.io/flapper/reference/acs_setup_detection_kernels.html}{\code{flapper::acs_setup_detection_kernels}}.
}
\usage{
acs_setup_detection_kernels(
  .dlist,
  .pdetkernel = acs_setup_detection_kernel,
  .verbose = getOption("patter.verbose"),
  ...
)
}
\arguments{
\item{.dlist}{A named \code{list} of data and parameters from \code{\link[=pat_setup_data]{pat_setup_data()}}. This function requires:
\itemize{
\item \code{.dlist$data$moorings}, with the following columns: \code{receiver_id}, \code{receiver_start}, \code{receiver_end}, \code{receiver_x} and \code{receiver_y}, plus any columns used internally by \code{.pdetkernel} (see below).
\item (optional) \code{.dlist$data$services}, with the following columns: \code{receiver_id}, \code{service_start} and \code{service_end} (see \code{\link[=make_matrix_receivers]{make_matrix_receivers()}}).
\item \code{.dlist$spatial$bathy}, which defines the grid on which detection kernels are represented. \code{NA}s are used as a mask.
\item \code{.dlist$pars$spatna}, which defines whether or not masking is required.
}}

\item{.pdetkernel, ...}{A \code{function} that defines the detection kernel as a \code{\link{SpatRaster}} around a receiver (see \code{\link[=acs_setup_detection_kernel]{acs_setup_detection_kernel()}} for an example). This must accept three arguments (even if they are ignored):
\itemize{
\item \code{.mooring}---A one-row \code{\link{data.table}} that contains the information in \code{.dlist$data$moorings} for a specific receiver;
\item \code{.bathy}---the \code{.dlist$spatial$bathy} \code{\link{SpatRaster}};
\item \code{.mask}---a \code{logical} variable passed down from \code{.dlist$pars$spatna};
\item \code{...} Additional arguments passed via \code{\link[=acs_setup_detection_kernels]{acs_setup_detection_kernels()}};
}}

\item{.verbose}{User output control (see \code{\link{patter-progress}} for supported options).}
}
\value{
The function returns a named \code{list}, with the following elements:
\itemize{
\item \strong{\code{pkernel}}. A named \code{list}, with one element for each receiver. Each element is a \code{\link{SpatRaster}} of the detection kernel around that receiver. Cells values define the probability of a detection, as modelled by \code{.pdetkernel}. In an AC*PF algorithm, these kernels are used to calculate the likelihood of the acoustic data (detections/non-detections). This process effectively up-weights particles near to the receiver(s) that recorded detections and down-weights particles further afield.
\item \strong{\code{loglik}}. A named \code{list}, with one element for each array design. Each element is a \code{\link{SpatRaster}} that defines the log-likelihood of non-detection at all operational receivers in that array. In an AC*PF algorithm, during detection gaps, we can extract the log-likelihood of the acoustic data (non detection) at particle locations directly from this layer.
}

To improve speed in \code{\link[=pf_forward]{pf_forward()}}, use \code{terra:::readAll()} to force \code{\link{SpatRaster}}s into memory, if possible.
}
\description{
This function is part of a set of \verb{acs_setup_*()} functions that prepare the layers required to evaluate the likelihood of acoustic observations in an AC*PF algorithm. The function prepares the detection kernels.
}
\details{
An AC*PF algorithm is a particle filtering algorithm that incorporates acoustic observations to reconstruct the possible movements of an individual (see \code{\link[=pf_forward]{pf_forward()}}). At each time step in such an algorithm, we evaluate the likelihood of acoustic observations (the presence or absence of detections at each operational receiver, accounting for receiver placement) given particle samples. The likelihood is evaluated using a Bernoulli distribution and a detection probability parameter. A detection kernel is a spatial representation of detection probability \emph{around a specific receiver}. This typically declines with distance around a receiver, hence the default formulation of the \code{.pdetkernel} function. This function permits receiver-specific kernels, if required (but time-varying kernels are not currently supported and require custom likelihood functions in \code{\link[=pf_forward]{pf_forward()}}). Pre-calculating detection kernels is a potentially slow operation, especially for large and/or high-resolution grids (and we would like to improve this in future). However, this penalty is only required once and improves the speed of downstream likelihood calculations in \code{\link[=pf_lik_ac]{pf_lik_ac()}} in \code{\link[=pf_forward]{pf_forward()}}.
}
\examples{
require(data.table)

#### Define example datasets
# Define example 'moorings' dataset
# * Receivers 3 and 4 overlap in space but receiver 5 is further afield
m <- data.table(receiver_id = c(3, 4, 5),
                receiver_start = as.Date(c("2016-01-01", "2016-01-01", "2016-01-01")),
                receiver_end = as.Date(c("2016-01-05", "2016-01-05", "2016-01-05")),
                receiver_easting = c(706124.9, 706012.7, 709379.0),
                receiver_northing = c(6265030, 6264993, 6260093),
                receiver_range = 750)
# Define example 'services' dataset
s <- data.table(receiver_id = c(3, 5),
                service_start = as.Date(c("2016-01-01", "2016-01-01")),
                service_end = as.Date(c("2016-01-01", "2016-01-01")))
# Set up data list as usual
dlist <- pat_setup_data(.moorings = m,
                        .services = s,
                        .bathy = dat_gebco(),
                        .lonlat = FALSE)

#### Example (1): Implement function using specified inputs
# Implement function
k <- acs_setup_detection_kernels(.dlist = dlist,
                                 .pdetkernel = acs_setup_detection_kernel)
# Examine list elements
summary(k)
# Examine detection probability kernels
pp <- par(mfrow = c(1, 3))
lapply(as.character(m$receiver_id), \(id) {
  terra::plot(k$pkernel[[id]])
  points(m[m$receiver_id == id, .(receiver_easting, receiver_northing)],
         cex = 2)
}) |> invisible()
par(pp)
# Examine likelihood of non detection for each unique array design
n <- length(k$loglik)
pp <- par(mfrow = c(1, n))
lapply(seq_len(n), \(id) {
  terra::plot(exp(k$loglik[[id]]))
  points(m[m$receiver_id == id, .(receiver_easting, receiver_northing)],
         cex = 2)
}) |> invisible()
par(pp)
}
\seealso{
To implement an AC*PF algorithm, see:
\enumerate{
\item \code{\link[=pat_setup_data]{pat_setup_data()}} to set up datasets;
\item \verb{acs_setup_*()} functions to prepare layers required for likelihood calculations, i.e.:
\itemize{
\item \code{\link[=acs_setup_detection_overlaps]{acs_setup_detection_overlaps()}}, which identifies detection overlaps;
\item \code{\link[=acs_setup_detection_kernel]{acs_setup_detection_kernel()}}, which prepares a detection kernel;
\item \code{\link[=acs_setup_detection_kernels]{acs_setup_detection_kernels()}}, which prepares detection kernels;
}
\item \code{\link[=pf_setup_obs]{pf_setup_obs()}} to define a timeline of observations
\item \code{\link[=pf_forward]{pf_forward()}} to run the simulation (using \code{\link[=pf_lik_ac]{pf_lik_ac()}} to evaluate the likelihood of acoustic observations);
}
}
\author{
Edward Lavender
}
