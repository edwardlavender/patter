% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/acs-setup.R
\name{acs_setup_detection_kernels}
\alias{acs_setup_detection_kernels}
\title{AC* set up: detection kernels}
\source{
This function is based on the \href{https://edwardlavender.github.io/flapper/reference/acs_setup_detection_kernels.html}{\code{acs_setup_detection_kernels}} function in the \href{https://github.com/edwardlavender/flapper}{\code{flapper}} package.
}
\usage{
acs_setup_detection_kernels(
  .dlist,
  .calc_detection_pr = acs_setup_detection_pr,
  .verbose = getOption("patter.verbose"),
  ...
)
}
\arguments{
\item{.dlist}{A named \code{list} of data and parameters from \code{\link[=pat_setup_data]{pat_setup_data()}}. This function requires:
\itemize{
\item \code{.dlist$data$moorings}, with the following columns: \code{receiver_id}, \code{receiver_start}, \code{receiver_end}, \code{receiver_x} and \code{receiver_y}, plus any columns used internally by \code{.calc_detection_pr} (see below).
\item \code{.dlist$data$services}, with the following columns: \code{receiver_id}, \code{service_start} and \code{service_end} (see \code{\link[=make_matrix_receivers]{make_matrix_receivers()}}).
\item \code{.dlist$spatial$bathy}, which defines the grid on which detection kernels are represented. \code{NA}s are used as a mask.
}}

\item{.calc_detection_pr, ...}{A function that defines the detection kernel as a \code{\link{SpatRaster}} around a receiver (see \code{\link[=acs_setup_detection_pr]{acs_setup_detection_pr()}} for an example). This must accept three arguments (even if they are ignored):
\itemize{
\item \code{.mooring}---A one-row \code{\link{data.table}} that contains the information in \code{.dlist$data$moorings} for a specific receiver;
\item \code{.bathy}---the \code{.dlist$spatial$bathy} \code{\link{SpatRaster}};
\item \code{...} Additional arguments passed via \code{\link[=acs_setup_detection_kernels]{acs_setup_detection_kernels()}};
}}

\item{.verbose}{User output control (see \code{\link{patter-progress}} for supported options).}
}
\value{
The function returns a named \code{list}, with the following elements:
\itemize{
\item \strong{\code{receiver_specific_kernels}}. A \code{list}, with one element for all integers from 1 to the maximum receiver number. Any elements that do not correspond to receivers contain a \code{NULL} element. List elements that correspond to receivers contain a \code{\link{SpatRaster}} of the detection kernel around the relevant receiver. Cells values define the likelihood of a detection in that location, as modelled by \code{.calc_detection_pr}. In an AC*PF algorithm, at the moment of detection, these kernels effectively up-weight particles near to the receiver(s) that recorded detections.
\item \strong{\code{receiver_specific_inv_kernels}}. A \code{list}, as for \code{receiver_specific_kernels}, but in which elements contain the inverse detection kernels (i.e., 1 - detection kernel). In an AC*PF algorithm, at the moment of detection, inverse detection kernels effectively down-weight particles in the overlapping regions between the receiver(s) that recorded detections those that did not.
\item \strong{\code{array_design}}. A \code{data.frame} that defines the number and deployment times of each unique array design, resulting from receiver deployment, servicing and removal. In the times between detections, this is used to select the appropriate 'background' likelihood surface (see below). This contains the following columns:
\itemize{
\item \code{array_id}. An \code{integer} vector that defines each unique array design.
\item \code{array_start_date}. A \code{Date} that defines the start date of each array design.
\item \code{array_end_date}. A \code{Date} that defines the end date of each array design.
\item \code{array_interval}. A \code{\link[lubridate:Interval-class]{lubridate::Interval}} vector that defines the deployment period of each array design.
}
\item \strong{\code{array_design_by_date}}. A named \code{list} that defines, for each date (list element), the array design on that date (based on \code{array_id} in \code{array_design}).
\item \strong{\code{bkg_surface_by_design}}. A \code{list}, with one element for each array design, that defines the detection surface across all receivers deployed in that phase of the study. In areas that are covered by the detection kernel of a single receiver, the detection surface depends only on the kernel for that receiver (via \code{.calc_detection_pr}). In areas covered by multiple, overlapping kernels, the surface is influenced by the combination of overlapping kernels.
\item \strong{\code{bkg_inv_surface_by_design}}. A \code{list}, as above for \code{bkg_surface_by_design}, but which contains the inverse detection surface (i.e., 1 - \code{bkg_surface_by_design}). In the AC*PF algorithm(s), in the gaps between detections, this effectively up-weights particles away from receivers (or, equivalently, down-weights particles near to receivers).
}
}
\description{
This function is part of a set of \verb{acs_setup_*()} functions that prepare the layers required to evaluate the likelihood of acoustic observations in an AC*PF algorithm. This function prepares the detection kernels.
}
\details{
An AC*PF algorithm is a particle filtering algorithm that incorporates acoustic observations to reconstruct the possible movements of an individual. At each time step in such an algorithm, we evaluate the likelihood of acoustic observations (the presence or absence of detections at each operational receiver, accounting for receiver placement) given particle samples. A detection kernel is a spatial representation of the likelihood of a detection \emph{around a specific receiver}. This typically declines with distance around a receiver, hence the default formulation of the \code{.calc_detection_pr} function. This function permits receiver-specific kernels, if required. Pre-calculating detection kernels is a potentially slow operation, especially for large and/or high-resolution grids (and we would like to improve this in future). However, this penalty is only required once and greatly improves the speed of downstream likelihood calculations in \code{\link[=pf_lik_ac]{pf_lik_ac()}} in \code{\link[=pf_forward]{pf_forward()}}, which only needs to appropriately combine the relevant values at each time step.
}
\examples{
require(data.table)

#### Define example datasets
# Define example 'moorings' dataset
# * Receivers 3 and 4 overlap in space but receiver 5 is further afield
m <- data.table(receiver_id = c(3, 4, 5),
                receiver_start = as.Date(c("2016-01-01", "2016-01-01", "2016-01-01")),
                receiver_end = as.Date(c("2016-01-05", "2016-01-05", "2016-01-05")),
                receiver_easting = c(706124.9, 706012.7, 709379.0),
                receiver_northing = c(6265030, 6264993, 6260093),
                receiver_range = 750)
# Define example 'services' dataset
s <- data.table(receiver_id = c(3, 5),
                service_start = as.Date(c("2016-01-01", "2016-01-01")),
                service_end = as.Date(c("2016-01-01", "2016-01-01")))
# Set up data list as usual
dlist <- pat_setup_data(.moorings = m,
                       .services = s,
                       .bathy = dat_gebco(),
                       .lonlat = FALSE)

#### Example (1): Implement function using specified inputs
# Implement function
k <- acs_setup_detection_kernels(dlist,
                                 .calc_detection_pr = acs_setup_detection_pr)
# Examine list elements
summary(k)
# Examine example receiver-specific kernels
pp <- par(mfrow = c(1, 2))
lapply(c(3, 4), \(id) {
  terra::plot(k$receiver_specific_kernels[[id]])
  points(m[m$receiver_id == id, .(receiver_easting, receiver_northing)],
         cex = 2)
}) |> invisible()
par(pp)
# Examine example receiver-specific inverse kernels
pp <- par(mfrow = c(1, 2))
lapply(c(3, 4), \(id) {
  terra::plot(k$receiver_specific_kernels[[id]])
  points(m[m$receiver_id == id, .(receiver_easting, receiver_northing)],
         cex = 2)
}) |> invisible()
par(pp)
# Examine background detection surfaces
# (for each unique combination of receivers that were deployed)
pp <- par(mfrow = c(1, 2))
lapply(k$bkg_surface_by_design, \(bkg) {
  terra::plot(bkg, axes = FALSE)
  box()
}) |> invisible()
par(pp)
# Examine background inverse detection surfaces
pp <- par(mfrow = c(1, 2))
lapply(k$bkg_inv_surface_by_design, \(bkg) {
  terra::plot(bkg, axes = FALSE)
  box()
}) |> invisible()
par(pp)
}
\seealso{
To implement such an AC*PF algorithm, see:
\enumerate{
\item \code{\link[=pat_setup_data]{pat_setup_data()}} to set up datasets;
\item \verb{acs_setup_*()} functions to prepare layers required for likelihood calculations, i.e.:
\itemize{
\item \code{\link[=acs_setup_detection_overlaps]{acs_setup_detection_overlaps()}}, which identifies detection overlaps;
\item \code{\link[=acs_setup_detection_kernels]{acs_setup_detection_kernels()}}, which prepares detection kernels;
\item \code{\link[=acs_setup_detection_pr]{acs_setup_detection_pr()}}, which is an example detection probability model;
}
\item \code{\link[=pf_lik_ac]{pf_lik_ac()}} to define the likelihood of acoustic data;
\item \code{\link[=pf_forward]{pf_forward()}} to run the simulation;
}
}
\author{
Edward Lavender
}
