% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/acs-setup.R
\name{acs_setup_detection_kernels}
\alias{acs_setup_detection_kernels}
\title{Setup detection kernels}
\source{
This function is based on the \href{https://edwardlavender.github.io/flapper/reference/acs_setup_detection_kernels.html}{\code{acs_setup_detection_kernels}} function in the \href{https://github.com/edwardlavender/flapper}{flapper} package, where the role of detection kernels in the AC* algorithms is described extensively (see Details).
}
\usage{
acs_setup_detection_kernels(
  .moorings,
  .services = NULL,
  .calc_detection_pr,
  .bathy,
  .verbose = TRUE,
  ...
)
}
\arguments{
\item{.moorings}{TO DO}

\item{.services}{TO DO}

\item{.calc_detection_pr, ...}{TO DO}

\item{.bathy}{TO DO}

\item{.verbose}{TO DO}
}
\value{
The function returns a named \code{list}, with the following elements:
\itemize{
\item \strong{\code{receiver_specific_kernels}}. A list, with one element for all integers from 1 to the maximum receiver number. Any elements that do not correspond to receivers contain a \code{NULL} element. List elements that correspond to receivers contain a \code{\link{SpatRaster}} of the detection probability kernel around the relevant receiver. Cells values define the detection probability around a receiver, given \code{.calc_detection_pr} In the AC* algorithm(s), these kernels are used to up-weight location probabilities near to a receiver when it is detected (following modification to account for overlapping areas, if necessary).
\item \strong{\code{receiver_specific_inv_kernels}}. A list, as for \code{receiver_specific_kernels}, but in which elements contain the inverse detection probability kernels (i.e., 1 - detection probability). In the AC* algorithm(s), these is used to down-weight-weight location probabilities in the overlapping regions between a receiver that recorded detections and others that did not at the same time.
\item \code{array_design_intervals}. A dataframe that defines the number and deployment times of each unique array design, resulting from receiver deployment, servicing and removal. In the times between detections, this is used to select the appropriate 'background' detection probability surface (see below). This contains the following columns:
\itemize{
\item \code{array_id}. An integer vector that defines each unique array design.
\item \code{array_start_date}. A Date that defines the start date of each array design.
\item \code{array_end_date}. A Date that defines the end date of each array design.
\item \code{array_interval}. A \code{\link[lubridate:Interval-class]{lubridate::Interval}} vector that defines the deployment period of each array design.
}
\item \strong{\code{bkg_surface_by_design}}. A list, with one element for each array design, that defines the detection probability surface across all receivers deployed in that phase of the study. In areas that are covered by the detection probability kernel of a single receiver, the detection probability depends only on distance to that receiver (via \code{.calc_detection_pr}). In areas covered by multiple, overlapping kernels, detection probability represents the combined detection probability across all overlapping kernels (see Details).
\item \strong{\code{bkg_inv_surface_by_design}}. A list, as above for \code{bkg_surface_by_design}, but which contains the inverse detection probability surface (i.e., 1 - \code{bkg_surface_by_design}). In the AC* algorithm(s), this is used to up-weight areas away from receivers (or, equivalently, down-weight areas near to receivers) in the time steps between detections.
}
}
\description{
TO DO
}
\examples{
#### Define example 'moorings' & 'services' dataset
# receivers 3 and 4 overlap in space but receiver 5 is further afield
require(data.table)
m <- data.table(receiver_id = c(3, 4, 5),
                receiver_start = as.Date(c("2016-01-01", "2016-01-01", "2016-01-01")),
                receiver_end = as.Date(c("2016-01-05", "2016-01-05", "2016-01-05")),
                receiver_easting = c(706124.9, 706012.7, 709379.0),
                receiver_northing = c(6265030, 6264993, 6260093),
                receiver_range = 500)
s <- data.table(receiver_id = c(3, 5),
                service_start = as.Date(c("2016-01-01", "2016-01-01")),
                service_end = as.Date(c("2016-01-01", "2016-01-01")))

#### Define function to calculate detection probability
# This must accept a .data & .bathy argument:
# * .data is the .moorings data for a specific receiver (e.g., containing receiver coordinates)
# * .bathy is as described above
# Using these arguments, the function must calculate detection probability around the receiver
# * This implementation supports receiver-specific detection ranges
acs_setup_detection_pr <- function(.data, .bathy, ...) {

  # Define helper function to calculate detection probability give distance
  calc_dpr <- function(distance) {
    pr <- stats::plogis(2.5 + -0.02 * distance)
    pr[distance > .data$receiver_range] <- 0
    pr
  }
  # Calculate Euclidean distance around receiver
  rxy <- matrix(c(.data$receiver_easting, .data$receiver_northing), ncol = 2)
  cell <- terra::cellFromXY(.bathy, rxy)
  grid <- terra::setValues(.bathy, NA)
  grid[cell] <- 1
  dist <- terra::distance(grid, unit = "m")
  dist <- terra::mask(dist, .bathy)
  # Convert distances to detection pr
  terra::app(dist, calc_dpr)
}
# Examine output of function for example receiver
pr <- lapply(seq_len(max(m$receiver_id)), function(id) {
  if (!(id \%in\% m$receiver_id)) return(NULL)
  acs_setup_detection_pr(m[m$receiver_id == id, , drop = FALSE], dat_gebco())
})

#### Implement function
k <- acs_setup_detection_kernels(m, s,
                                 .calc_detection_pr = acs_setup_detection_pr,
                                 .bathy = dat_gebco())

#### TO DO (continue)

}
\author{
Edward Lavender
}
