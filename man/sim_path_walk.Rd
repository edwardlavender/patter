% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sims.R
\name{sim_path_walk}
\alias{sim_path_walk}
\alias{rtruncgamma}
\alias{rwn}
\alias{sim_length}
\alias{sim_angle_rw}
\alias{sim_angle_crw}
\title{Simulate movement paths}
\usage{
sim_path_walk(
  .bathy = rast_template(),
  .origin = NULL,
  .n_step = 10L,
  .sim_length = sim_length,
  .sim_angle = sim_angle_rw,
  ...,
  .n_path = 1L,
  .plot = TRUE,
  .one_page = FALSE
)

rtruncgamma(.n = 1, .shape = 15, .scale = 15, .mobility = 500, ...)

rwn(.n = 1, .mu = 0, .rho = 0, .sd = 1, ...)

sim_length(.n = 1, .prior = NULL, .t = NULL, ...)

sim_angle_rw(.n = 1, .prior = NULL, .t = NULL, ...)

sim_angle_crw(.n = 1, .prior = NULL, .t = NULL, ...)
}
\arguments{
\item{.bathy}{A \code{\link{SpatRaster}} that defines the region within which movements are simulated. Movements are simulated in continuous space but restricted within the boundaries defined by \code{.bathy} and non-NA regions.}

\item{.origin}{(optional) A one-row, two-column matrix that defines the origin. If unsupplied, \code{.origin} is sampled at random from \code{.bathy}. One origin is used for all simulated paths (see \code{.n_path}).}

\item{.n_step}{An \code{integer} that defines the number of time steps.}

\item{.sim_length, .sim_angle, ...}{Functions and accompanying arguments that simulate step lengths and turning angles. These must accept four named arguments, even if unused:
\itemize{
\item \code{.n}---an \code{integer} that defines the number of simulated outcome(s);
\item \code{.prior}---a \code{numeric} vector that defines the simulated value(s) from the previous time step;
\item \code{.t}---an \code{integer} that defines the time step;
\item \code{...}---additional arguments, if needed;
}

If \code{.prior} is used, the function should be able to handle the first time step (when \code{.prior} is set to \code{NULL}). See \code{\link[=sim_angle_crw]{sim_angle_crw()}} (below) for an example.

Note that \code{...} is passed down from \code{\link[=sim_path_walk]{sim_path_walk()}} to both \code{.sim_length} and \code{.sim_angle} so care is required to ensure that \code{...} parameters are handled correctly).

The following template functions are provided:
\itemize{
\item \code{\link[=sim_length]{sim_length()}} is an example \code{.sim_length} function that simulates step lengths from a truncated Gamma distribution (via \code{\link[=rtruncgamma]{rtruncgamma()}});
\item \code{\link[=sim_angle_rw]{sim_angle_rw()}} is an example \code{.sim_angle} function that simulates uncorrelated turning angles from a wrapped normal distribution (via \code{\link[=rwn]{rwn()}});
\item \code{\link[=sim_angle_crw]{sim_angle_crw()}} is an example \code{.sim_angle} function that can simulate correlated turning angles (via \code{\link[=rwn]{rwn()}});
}}

\item{.n_path}{An \code{integer} that defines the number of paths to simulate.}

\item{.plot, .one_page}{Plot options.
\itemize{
\item \code{.plot} is a \code{logical} variable that defined whether or not to plot \code{.bathy} and simulated path(s). Each path is plotted on a separate plot.
\item \code{.one_page} is a logical variable that defines whether or not to produce all plots on a single page.
}}

\item{.n, .prior, .t}{Arguments required for \code{.sim_length} and \code{.sim_step} functions (defined above).}

\item{.shape, .scale, .mobility}{Arguments for \code{\link[=rtruncgamma]{rtruncgamma()}} for the simulation of step lengths:
\itemize{
\item \code{.shape} is a \code{numeric} value that defines the shape parameter of a Gamma distribution (see \code{\link[stats:GammaDist]{stats::rgamma()}}).
\item \code{.scale} is a \code{numeric} value that defines the scale parameter of a Gamma distribution (see \code{\link[stats:GammaDist]{stats::rgamma()}}).
\item \code{.mobility} is a \code{numeric} value that defines the maximum length (see \code{\link[truncdist:rtrunc]{truncdist::rtrunc()}}).
}}

\item{.mu, .rho, .sd}{Arguments for \code{\link{rwn}} for the simulation of turning angles, passed to the \code{mu}, \code{rho} and \code{sd} arguments of \code{\link[circular:wrappednormal]{circular::rwrappednormal()}}.}
}
\value{
\code{\link[=sim_path_walk]{sim_path_walk()}} returns a \code{\link{data.table}} with 10 columns:
\itemize{
\item \code{path_id}--- an \code{integer} that identifies each path;
\item \code{timestep}---an \code{integer} that defines the time step;
\item \code{cell_id}, \code{cell_x}, \code{cell_y}, \code{cell_z}---\code{integer}/\code{numeric} vectors that define the locations of the simulated positions on \code{.bathy};
\item \code{x},\code{y}---\code{numeric} vectors that define simulated x and y coordinates;
\item \code{length},\code{angle}---\code{numeric} vectors that define simulated step lengths and angles (for the movement from timestep \code{t} to time step \code{t + 1});
}
}
\description{
These functions facilitate the simulation of discrete-time animal movement paths from walk models (e.g., random walks, biased random walks, correlated random walks).
}
\details{
\itemize{
\item \code{\link[=rtruncgamma]{rtruncgamma()}} and \code{\link[=rwn]{rwn()}} simulate step lengths (from a truncated Gamma distribution) and turning angles (from a wrapped normal distribution);
\item \code{\link[=sim_length]{sim_length()}}, \code{\link[=sim_angle_rw]{sim_angle_rw()}} and \code{\link[=sim_angle_crw]{sim_angle_crw()}} are wrappers in the form required by \code{\link[=sim_path_walk]{sim_path_walk()}};
\item \code{\link[=sim_path_walk]{sim_path_walk()}} simulates the movement path(s);
}
}
\examples{
if (rlang::is_installed(c("circular", "truncdist"))) {

  require(data.table)
  require(dtplyr)
  require(dplyr, warn.conflicts = FALSE)
  require(circular)
  require(graphics)

  #### Example (1): Implement function with default options
  # The function returns a data.table with simulated locations
  set.seed(1)
  p <- sim_path_walk()
  p

  #### Example (2): Update region for simulation
  p <- sim_path_walk(dat_gebco())
  p

  #### Example (3): Specify origin
  origin <- cbind(710275.3, 6259763)
  p <- sim_path_walk(dat_gebco(), .origin = cbind(710275.3, 6259763))

  #### Example (4): Update number of steps/number of paths
  p <- sim_path_walk(dat_gebco(),
                     .origin = origin,
                     .n_step = 100L, .n_path = 5L,
                     .plot = TRUE, .one_page = TRUE)
  # The output contains 5 paths, each of 100 steps
  p |>
    group_by(path_id) |>
    summarise(n = n()) |>
    as.data.table()

  #### Example (5): Modify step length parameters
  hist(rtruncgamma(1e3, .shape = 5, .mobility = 100))
  p <- sim_path_walk(dat_gebco(),
                     .origin = origin,
                     .n_step = 100L,
                     .shape = 5, .mobility = 100)
  p

  #### Example (6): Modify .step_length() model
  # Use time-varying step lengths dependent upon some behavioural state
  b <- data.table(x = c(0, 0, 1, 1, 1, 1, 1))
  hist(rtruncgamma(.n = 1e3, .shape = 5, .scale = 5))
  hist(rtruncgamma(.n = 1e3, .shape = 15, .scale = 15))
  sim_length <- function(.n = 1,
                         .prior = NULL, .t = NULL, .state, ...) {
    if (.state$x[.t] == 0L) {
      rtruncgamma(.n = .n, .shape = 5, .scale = 5, .mobility = 50)
    } else if (.state$x[.t] == 1L) {
      rtruncgamma(.n = .n, .shape = 15, .scale = 15, .mobility = 500)
    }
  }
  p <- sim_path_walk(dat_gebco(),
                     .origin = origin,
                     .n_step = nrow(b) + 1,
                     .sim_length = sim_length, .state = b)
  p

  #### Example (7): Update model for turning angles
  # Use biased random walk by modifying the .mu parameter in sim_angle_rw()
  # E.g., To simulate movement north in a straight line, we use .mu = -99
  # (accounting for the longitude of natural origin = -9 in dat_gebco())
  # and .rho = 1:
  rwn(.n = 10, .mu =  -(90 + 9), .rho = 1)
  p <- sim_path_walk(dat_gebco(),
                     .origin = origin,
                     .n_step = 10L,
                     .sim_angle = sim_angle_rw, .mu = -(90 + 9), .rho = 1,
                     .one_page = FALSE)
  p

  #### Example (8): Use a correlated random walk model
  p <- sim_path_walk(dat_gebco(),
                     .origin = origin,
                     .n_step = 1000L, .n_path = 1L,
                     .sim_angle = sim_angle_crw, .rho = 0.9,
                     .one_page = FALSE)
  # The correlation between sequential angles is close to the simulated value:
  adt <- data.table(a0 = p$angle, a1 = dplyr::lead(p$angle)) |> na.omit()
  cor.circular(degrees(adt$a0), degrees(adt$a1))

  #### Example (9): Use custom step/length or turning angle models
  sim_angle_vmd <- function(.n = 1L, .prior = NULL, ...) {
    as.numeric(
      circular::rvonmises(
        n = .n,
        mu = degrees(0),
        kappa = 0,
        control.circular = list(units = "degrees")
      )
    )
  }
  p <- sim_path_walk(dat_gebco(),
                     .origin = origin,
                     .n_step = 1000L,
                     .sim_angle = sim_angle_vmd, .rho = 0.5,
                     .one_page = FALSE)
  p

}
}
\author{
Edward Lavender
}
