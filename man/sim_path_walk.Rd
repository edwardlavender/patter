% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sims.R
\name{sim_path_walk}
\alias{sim_path_walk}
\title{Simulation: movement walks}
\usage{
sim_path_walk(
  .bathy = spatTemplate(),
  .origin = NULL,
  .lonlat = FALSE,
  .n_step = 10L,
  .timestamp = NULL,
  .rlen = rlen,
  .rang = rangrw,
  ...,
  .n_path = 1L,
  .plot = TRUE,
  .one_page = FALSE
)
}
\arguments{
\item{.bathy}{A \code{\link{SpatRaster}} that defines the region within which movements are simulated. Movements are simulated in continuous space but restricted within the boundaries defined by \code{.bathy} and non-\code{NA} regions.}

\item{.origin}{(optional) A one-row, two-column matrix that defines the origin. If unsupplied, \code{.origin} is sampled at random from \code{.bathy}. One origin is used for all simulated paths (see \code{.n_path}).}

\item{.lonlat}{A \code{logical} variable that defines whether or not \code{.bathy} (and, if applicable, \code{.origin}) use longitude/latitude or planar coordinates.}

\item{.n_step}{An \code{integer} that defines the number of time steps.}

\item{.timestamp}{(optional) A vector of time stamps, one for each time step, for inclusion in the output \code{\link{data.table}} as a \code{timestamp} column.}

\item{.rlen, .rang, ...}{Functions and accompanying arguments that simulate step lengths and turning angles. Simulated step lengths should be in map units (e.g., metres) if \code{.lonlat = FALSE} or metres if \code{.lonlat = TRUE}. Turning angles should be in degrees. The functions must accept four named arguments, even if unused:
\itemize{
\item \code{.n}---an \code{integer} that defines the number of simulated outcome(s);
\item \code{.prior}---a \code{numeric} vector that defines the simulated value(s) from the previous time step;
\item \code{.t}---an \code{integer} that defines the time step;
\item \code{...}---additional arguments, if needed;
}

If \code{.prior} is used, the function should be able to handle the first time step (when \code{.prior} is set to \code{NULL}). See \code{\link[=rangcrw]{rangcrw()}} (below) for an example.

Note that \code{...} is passed down from \code{\link[=sim_path_walk]{sim_path_walk()}} to both \code{.rlen} and \code{.rang} so care is required to ensure that \code{...} parameters are handled correctly.

The following template functions are provided:
\itemize{
\item \code{\link[=rlen]{rlen()}} is an example \code{.rlen} function that simulates step lengths from a truncated Gamma distribution (via \code{\link[=rtruncgamma]{rtruncgamma()}});
\item \code{\link[=rangrw]{rangrw()}} is an example \code{.rang} function that simulates uncorrelated turning angles from a wrapped normal distribution (via \code{\link[=rwn]{rwn()}});
\item \code{\link[=rangcrw]{rangcrw()}} is an example \code{.rang} function that can simulate correlated turning angles (via \code{\link[=rwn]{rwn()}});
}}

\item{.n_path}{An \code{integer} that defines the number of paths to simulate.}

\item{.plot, .one_page}{Plot options.
\itemize{
\item \code{.plot} is a \code{logical} variable that defined whether or not to plot \code{.bathy} and simulated path(s). Each path is plotted on a separate plot.
\item \code{.one_page} is a logical variable that defines whether or not to produce all plots on a single page.
}}
}
\value{
\code{\link[=sim_path_walk]{sim_path_walk()}} returns a \code{\link{data.table}} with 10 columns:
\itemize{
\item \code{path_id}--- an \code{integer} vector that identifies each path;
\item \code{timestep}---an \code{integer} vector that defines the time step;
\item \code{cell_id}, \code{cell_x}, \code{cell_y}, \code{cell_z}---\code{integer}/\code{numeric} vectors that define the locations of the simulated positions on \code{.bathy};
\item \code{x},\code{y}---\code{numeric} vectors that define simulated x and y coordinates;
\item \code{length},\code{angle}---\code{numeric} vectors that define simulated step lengths and angles (for the movement from timestep \code{t} to time step \code{t + 1});
}
}
\description{
\code{\link[=sim_path_walk]{sim_path_walk()}} facilitates the simulation of discrete-time animal movement paths from walk models (e.g., random walks, biased random walks, correlated random walks).
}
\details{
The following convenience functions are provided:
\itemize{
\item \code{\link[=rtruncgamma]{rtruncgamma()}} and \code{\link[=rwn]{rwn()}} simulate step lengths (from a truncated Gamma distribution) and turning angles (from a wrapped normal distribution);
\item \code{\link[=rlen]{rlen()}}, \code{\link[=rangrw]{rangrw()}} and \code{\link[=rangcrw]{rangcrw()}} are wrappers in the form required by \code{\link[=sim_path_walk]{sim_path_walk()}};
\item \code{\link[=sim_path_walk]{sim_path_walk()}} simulates the movement path(s);
}

Within \code{\link[=sim_path_walk]{sim_path_walk()}}, at each time step, if \code{.lonlat = TRUE}, current locations are updated via \code{\link[geosphere:destPoint]{geosphere::destPoint()}}. If \code{.lonlat = FALSE}, current locations (x, y) are updated via \code{x + length * cos(angle)} and \code{y + length * sin(angle)}, where \code{length} is the simulated vector of step lengths and \code{angle} is the simulated vector of angles (re-expressed for consistency with \code{\link[geosphere:destPoint]{geosphere::destPoint()}} via \code{\link[=geoangle]{geoangle()}}).

\code{.lonlat} support is experimental. Be especially careful with correlated random walks if \code{lonlat = TRUE}. On an ellipsoid, the initial (simulated) bearing is not the same as the final bearing, but is not currently updated.

\code{\link[=sim_path_walk]{sim_path_walk()}} replaces \href{https://edwardlavender.github.io/flapper/reference/sim_path_sa.html}{\code{flapper::sim_path_sa()}}. Other \href{https://edwardlavender.github.io/flapper/reference/sim_path_-times.html}{\verb{flapper::sim_path_*()}} functions are not currently implemented in \code{\link{patter}}.
}
\examples{
require(data.table)
require(dtplyr)
require(dplyr, warn.conflicts = FALSE)
require(circular)

#### Example (1): Implement function with default options
# The function returns a data.table with simulated locations
ssv()
p <- sim_path_walk()
p

#### Example (2): Update region for simulation
ssv()
p <- sim_path_walk(dat_gebco())
p

#### Example (3): Specify origin
origin <- cbind(710275.3, 6259763)
ssv()
p <- sim_path_walk(dat_gebco(), .origin = cbind(710275.3, 6259763))

#### Example (4): Update number of steps/number of paths
ssv()
p <- sim_path_walk(dat_gebco(),
                   .origin = origin,
                   .n_step = 100L, .n_path = 5L,
                   .plot = TRUE, .one_page = TRUE)
# The output contains 5 paths, each of 100 steps
p |>
  group_by(path_id) |>
  summarise(n = n()) |>
  as.data.table()

#### Example (5): Modify step length parameters
hist(rtruncgamma(1e3, .shape = 5, .mobility = 100))
ssv()
p <- sim_path_walk(dat_gebco(),
                   .origin = origin,
                   .n_step = 100L,
                   .shape = 5, .mobility = 100)
p

#### Example (6): Modify `.rlen` model
# Use time-varying step lengths dependent upon some behavioural state
b <- data.table(x = c(0, 0, 1, 1, 1, 1, 1))
hist(rtruncgamma(.n = 1e3, .shape = 5, .scale = 5))
hist(rtruncgamma(.n = 1e3, .shape = 15, .scale = 15))
rlenbs <- function(.n = 1,
                   .prior = NULL, .t = NULL, .state, ...) {
  if (.state$x[.t] == 0L) {
    rtruncgamma(.n = .n, .shape = 5, .scale = 5, .mobility = 50)
  } else if (.state$x[.t] == 1L) {
    rtruncgamma(.n = .n, .shape = 15, .scale = 15, .mobility = 500)
  }
}
ssv()
p <- sim_path_walk(dat_gebco(),
                   .origin = origin,
                   .n_step = nrow(b) + 1,
                   .rlen = rlenbs, .state = b)
p

#### Example (7): Update model for turning angles
# Use biased random walk by modifying the .mu parameter in rangrw()
# E.g., To simulate movement north in a straight line, we use .mu = -99
# (accounting for the longitude of natural origin = -9 in dat_gebco())
# and .rho = 1:
rwn(.n = 10, .mu =  -(90 + 9), .rho = 1)
ssv()
p <- sim_path_walk(dat_gebco(),
                   .origin = origin,
                   .n_step = 10L,
                   .rang = rangrw, .mu = -(90 + 9), .rho = 1,
                   .one_page = FALSE)
p

#### Example (8): Use a correlated random walk model
ssv()
p <- sim_path_walk(dat_gebco(),
                   .origin = origin,
                   .n_step = 1000L, .n_path = 1L,
                   .rang = rangcrw, .rho = 0.4,
                   .one_page = FALSE)
# The correlation between sequential angles is close to the simulated value:
adt <- data.table(a0 = p$angle, a1 = lead(p$angle)) |> na.omit()
cor.circular(degrees(adt$a0), degrees(adt$a1))

#### Example (9): Use custom step/length or turning angle models
rangvmd <- function(.n = 1L, .prior = NULL, ...) {
  as.numeric(
    circular::rvonmises(
      n = .n,
      mu = degrees(0),
      kappa = 0,
      control.circular = list(units = "degrees")
    )
  )
}
ssv()
p <- sim_path_walk(dat_gebco(),
                   .origin = origin,
                   .n_step = 1000L,
                   .rang = rangvmd,
                   .one_page = FALSE)
p
}
\seealso{
\itemize{
\item \verb{sim_*} functions implement \emph{de novo} simulation of movements and observations:
\itemize{
\item \code{\link{sim_helpers}} are convenience functions for simulations;
\item \code{\link[=sim_array]{sim_array()}} simulates acoustic array(s);
\item \code{\link[=sim_path_walk]{sim_path_walk()}} simulates movement path(s) via a walk model;
\item \code{\link[=sim_detections]{sim_detections()}} simulates detection(s) at receivers;
}
\item \code{\link[=pf_forward]{pf_forward()}} and associates implement the simulation-based reconstruction of movements;
\item \code{\link{skill}} functions compared simulated and reconstructed patterns to evaluate model skill;
}
}
\author{
Edward Lavender
}
